[{"EN": {"name": "dfs", "description": "Depth-first search - DFS\njill-j\u00eann vie et christoph durr - 2015-2019\n", "functions": [{"name": "dfs_grid", "description": "DFS on a grid, mark connected component, iterative version\n\n    :param grid: matrix, 4-neighborhood\n    :param i,j: cell in this matrix, start of DFS exploration\n    :param free: symbol for walkable cells\n    :param mark: symbol to overwrite visited vertices\n    :complexity: linear\n    ", "examples": []}, {"name": "dfs_grid_recursive", "description": "DFS on a grid, mark connected component, iterative version\n\n    :param grid: matrix, 4-neighborhood\n    :param i,j: cell in this matrix, start of DFS exploration\n    :param free: symbol for walkable cells\n    :param mark: symbol to overwrite visited vertices\n    :complexity: linear\n    "}, {"name": "dfs_iterative", "description": "DFS, detect connected component, iterative implementation\n\n    :param graph: directed graph in listlist or listdict format\n    :param int node: to start graph exploration\n    :param boolean-table seen: will be set true for the connected component\n          containing node.\n    :complexity: `O(|V|+|E|)`\n    ", "examples": [{"args": [{"name": "graph", "value": "[[]]", "type": "list"}, {"name": "start", "value": "0", "type": "int"}, {"name": "seen", "value": "[False]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[{}]", "type": "list"}, {"name": "start", "value": "0", "type": "int"}, {"name": "seen", "value": "[False]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[1], []]", "type": "list"}, {"name": "start", "value": "0", "type": "int"}, {"name": "seen", "value": "[False, False]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[{1: None}, {}]", "type": "list"}, {"name": "start", "value": "0", "type": "int"}, {"name": "seen", "value": "[False, False]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[1], []]", "type": "list"}, {"name": "start", "value": "1", "type": "int"}, {"name": "seen", "value": "[False, False]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[{1: None}, {}]", "type": "list"}, {"name": "start", "value": "1", "type": "int"}, {"name": "seen", "value": "[False, False]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[1], [2], []]", "type": "list"}, {"name": "start", "value": "1", "type": "int"}, {"name": "seen", "value": "[False, False, False]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[{1: None}, {2: None}, {}]", "type": "list"}, {"name": "start", "value": "1", "type": "int"}, {"name": "seen", "value": "[False, False, False]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[1, 5], [2, 3, 5], [3], [4, 5], [5], []]", "type": "list"}, {"name": "start", "value": "2", "type": "int"}, {"name": "seen", "value": "[False, False, False, False, False, False]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[{1: None, 5: None}, {2: None, 3: None, 5: None}, {3: None}, {4: None, 5: None}, {5: None}, {}]", "type": "list"}, {"name": "start", "value": "2", "type": "int"}, {"name": "seen", "value": "[False, False, False, False, False, False]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}]}, {"name": "dfs_recursive", "description": "DFS, detect connected component, recursive implementation\n\n    :param graph: directed graph in listlist or listdict format\n    :param int node: to start graph exploration\n    :param boolean-table seen: will be set true for the connected component\n          containing node.\n    :complexity: `O(|V|+|E|)`\n    ", "examples": [{"args": [{"name": "graph", "value": "[[]]", "type": "list"}, {"name": "node", "value": "0", "type": "int"}, {"name": "seen", "value": "[False]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[{}]", "type": "list"}, {"name": "node", "value": "0", "type": "int"}, {"name": "seen", "value": "[False]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[1], []]", "type": "list"}, {"name": "node", "value": "1", "type": "int"}, {"name": "seen", "value": "[True, False]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[1], []]", "type": "list"}, {"name": "node", "value": "0", "type": "int"}, {"name": "seen", "value": "[False, False]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[{1: None}, {}]", "type": "list"}, {"name": "node", "value": "1", "type": "int"}, {"name": "seen", "value": "[True, False]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[{1: None}, {}]", "type": "list"}, {"name": "node", "value": "0", "type": "int"}, {"name": "seen", "value": "[False, False]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[1], []]", "type": "list"}, {"name": "node", "value": "1", "type": "int"}, {"name": "seen", "value": "[False, False]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[{1: None}, {}]", "type": "list"}, {"name": "node", "value": "1", "type": "int"}, {"name": "seen", "value": "[False, False]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[1], [2], []]", "type": "list"}, {"name": "node", "value": "2", "type": "int"}, {"name": "seen", "value": "[False, True, False]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[1], [2], []]", "type": "list"}, {"name": "node", "value": "1", "type": "int"}, {"name": "seen", "value": "[False, False, False]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}]}, {"name": "dfs_tree", "description": "DFS, build DFS tree in unweighted graph\n\n       :param graph: directed graph in listlist or listdict format\n       :param int start: source vertex\n       :returns: precedence table\n       :complexity: `O(|V|+|E|)`\n       "}, {"name": "find_cycle", "description": "find a cycle in an undirected graph\n\n    :param graph: undirected graph in listlist or listdict format\n    :returns: list of vertices in a cycle or None\n    :complexity: `O(|V|+|E|)`\n    ", "examples": [{"args": [{"name": "graph", "value": "[]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[]]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[{}]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[], []]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[{}, {}]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[1], [0]]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[{1: None}, {0: None}]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[], [2], [1]]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[{}, {2: None}, {1: None}]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[1, 2], [0, 2], [0, 1]]", "type": "list"}], "return": {"value": "[1, 2, 0]", "type": "list"}}]}], "classes": []}, "FR": {"name": "dfs", "description": "Depth-first search - DFS\njill-j\u00eann vie et christoph durr - 2015-2019\n", "functions": [{"name": "dfs_grid", "description": "DFS sur une grille, marque du composant connect\u00e9, it\u00e9ratif version\n\n:param grille: matrix, le 4-voisinage\n:param i,j: cellule dans cette matrice, d\u00e9but de DFS exploration\n:param gratuit: symbole pour les pi\u00e9tons, les cellules\n:param marque: symbole de remplacer visit\u00e9s sommets\n:complexit\u00e9: lin\u00e9aire\n"}, {"name": "dfs_grid_recursive", "description": "DFS sur une grille, marque du composant connect\u00e9, it\u00e9ratif version\n\n:param grille: matrix, le 4-voisinage\n:param i,j: cellule dans cette matrice, d\u00e9but de DFS exploration\n:param gratuit: symbole pour les pi\u00e9tons, les cellules\n:param marque: symbole de remplacer visit\u00e9s sommets\n:complexit\u00e9: lin\u00e9aire\n"}, {"name": "dfs_iterative", "description": "DFS, de d\u00e9tecter les composants connect\u00e9s, it\u00e9ratif de mise en \u0153uvre\n\n:param graphe: graphe orient\u00e9 dans listlist ou listdict format\n:param int n\u0153ud: pour d\u00e9marrer le graphe d'exploration\n:param boolean-table vu: sera fix\u00e9 \u00e0 true pour le composant connect\u00e9\ncontenant le n\u0153ud.\n:complexit\u00e9: O(|V|+|E|)`\n"}, {"name": "dfs_recursive", "description": "DFS, de d\u00e9tecter les composants connect\u00e9s, r\u00e9cursive de la mise en \u0153uvre\n\n:param graphe: graphe orient\u00e9 dans listlist ou listdict format\n:param int n\u0153ud: pour d\u00e9marrer le graphe d'exploration\n:param boolean-table vu: sera fix\u00e9 \u00e0 true pour le composant connect\u00e9\ncontenant le n\u0153ud.\n:complexit\u00e9: O(|V|+|E|)`\n"}, {"name": "dfs_tree", "description": "DFS, construire arborescence DFS dans le graphe non pond\u00e9r\u00e9\n\n:param graphe: graphe orient\u00e9 dans listlist ou listdict format\n:param int start: source: vertex\n:retourne: tableau de pr\u00e9c\u00e9dence\n:complexit\u00e9: O(|V|+|E|)`\n"}, {"name": "find_cycle", "description": "trouver un cycle dans un graphe non-dirig\u00e9\n\n:param graphe: graphe non-dirig\u00e9 dans listlist ou listdict format\n:renvoie la liste des sommets dans un cycle ou Aucun\n:complexit\u00e9: O(|V|+|E|)`\n"}], "classes": []}}, {"EN": {"name": "arithm", "description": "arithmetic functions\nchristoph d\u00fcrr - jill-j\u00eann vie - 2013-2019\n", "functions": [{"name": "bezout", "description": "B\u00e9zout coefficients for a and b\n\n    :param a,b: non-negative integers\n    :complexity: O(log a + log b)\n    ", "examples": [{"args": [{"name": "a", "value": "1", "type": "int"}, {"name": "b", "value": "0", "type": "int"}], "return": {"value": "(1, 0)", "type": "tuple"}}, {"args": [{"name": "a", "value": "8", "type": "int"}, {"name": "b", "value": "1", "type": "int"}], "return": {"value": "(0, 1)", "type": "tuple"}}, {"args": [{"name": "a", "value": "17", "type": "int"}, {"name": "b", "value": "8", "type": "int"}], "return": {"value": "(1, -2)", "type": "tuple"}}, {"args": [{"name": "a", "value": "8", "type": "int"}, {"name": "b", "value": "17", "type": "int"}], "return": {"value": "(-2, 1)", "type": "tuple"}}]}, {"name": "binom", "description": "Binomial coefficients for :math:`n choose k`\n\n    :param n,k: non-negative integers\n    :complexity: O(k)\n    "}, {"name": "binom_modulo", "description": "Binomial coefficients for :math:`n choose k`, modulo p\n\n    :param n,k: non-negative integers\n    :complexity: O(k)\n    "}, {"name": "inv", "description": "Inverse of a in :math:`{mathbb Z}_p`\n\n    :param a,p: non-negative integers\n    :complexity: O(log a + log p)\n    ", "examples": [{"args": [{"name": "a", "value": "8", "type": "int"}, {"name": "p", "value": "17", "type": "int"}], "return": {"value": "15", "type": "int"}}]}, {"name": "pgcd", "description": "Greatest common divisor for a and b\n\n    :param a,b: non-negative integers\n    :complexity: O(log a + log b)\n    "}], "classes": []}, "FR": {"name": "arithm", "description": "des fonctions arithm\u00e9tiques\nchristoph d\u00fcrr - jill-j\u00eann vie - 2013-2019\n", "functions": [{"name": "bezout", "description": "Les coefficients de B\u00e9zout pour a et b\n\n:param a,b: entiers non n\u00e9gatifs\n:complexit\u00e9: O(log a + log b)\n"}, {"name": "binom", "description": "Coefficients binomiaux pour :math:`n choisir k`\n\n:param n,k: entiers non n\u00e9gatifs\n:complexit\u00e9: O(k)\n"}, {"name": "binom_modulo", "description": "Coefficients binomiaux pour :math:`n choisir k`, modulo p\n\n:param n,k: entiers non n\u00e9gatifs\n:complexit\u00e9: O(k)\n"}, {"name": "inv", "description": "L'Inverse de a dans :math:`{mathbb Z}_p`\n\n:param a,p: nombres entiers non n\u00e9gatifs\n:complexit\u00e9: O(log a + log p)\n"}, {"name": "pgcd", "description": "Le plus grand commun diviseur de a et b\n\n:param a,b: entiers non n\u00e9gatifs\n:complexit\u00e9: O(log a + log b)\n"}], "classes": []}}, {"EN": {"name": "fenwick", "description": "Fenwick tree\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [], "classes": [{"name": "Fenwick", "description": "maintains a tree to allow quick updates and queries\n    ", "methods": [{"name": "__init__", "description": "stores a table t and allows updates and queries\n        of prefix sums in logarithmic time.\n\n        :param array t: with numerical values\n        "}, {"name": "add", "description": "\n        :param int a: index in t\n        :modifies: adds val to t[a]\n        "}, {"name": "get", "description": "Variant, reads t[a]\n\n        :param int i: negative a will return 0\n        "}, {"name": "intervalAdd", "description": "Variant, adds val to t[a], to t[a + 1] ... and to t[b]\n\n        :param int a b: with 0 <= a <= b < len(t)\n        "}, {"name": "intervalSum", "description": "\n        :param int a b: with 0 <= a <= b\n        :returns: t[a] + ... + t[b]\n        "}, {"name": "prefixSum", "description": "\n        :param int a: index in t, negative a will return 0\n        :returns: t[0] + ... + t[a]\n        "}]}]}, "FR": {"name": "fenwick", "description": "Fenwick arbre\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [], "classes": [{"name": "Fenwick", "description": "maintient un arbre pour permettre des mises \u00e0 jour rapides et les requ\u00eates\n", "methods": [{"name": "__init__", "description": "stocke un tableau t et permet des mises \u00e0 jour et des requ\u00eates\nde pr\u00e9fixe sommes en temps logarithmique.\n\n:param array t: avec des valeurs num\u00e9riques\n"}, {"name": "ajouter", "description": "\n:param int a: indice dans t\n:modifie: ajoute val de t[a]\n"}, {"name": "obtenez de l'", "description": "Variante, lit t[a]\n\n:param int i: n\u00e9gative sera de retour 0\n"}, {"name": "intervalAdd", "description": "Variante, ajoute val de t[a], t[a + 1] ... et \u00e0 t[b]\n\n:param int b: avec 0 <= a <= b < len(t)\n"}, {"name": "intervalSum", "description": "\n:param int b: avec 0 <= a <= b\n:retourne: t[a] + ... + t[b]\n"}, {"name": "prefixSum", "description": "\n:param int a: indice dans t, n\u00e9gative sera de retour 0\n:retourne: t[0] + ... + t[a]\n"}]}]}}, {"EN": {"name": "sudoku", "description": "Solving Sudoku (nanpure)\njill-jenn vie et christoph durr - 2014-2019\n", "functions": [{"name": "assignment", "description": null, "examples": [{"args": [{"name": "r", "value": "0", "type": "int"}, {"name": "c", "value": "1", "type": "int"}, {"name": "v", "value": "14", "type": "int"}], "return": {"value": "30", "type": "int"}}, {"args": [{"name": "r", "value": "0", "type": "int"}, {"name": "c", "value": "5", "type": "int"}, {"name": "v", "value": "13", "type": "int"}], "return": {"value": "93", "type": "int"}}, {"args": [{"name": "r", "value": "0", "type": "int"}, {"name": "c", "value": "6", "type": "int"}, {"name": "v", "value": "5", "type": "int"}], "return": {"value": "101", "type": "int"}}, {"args": [{"name": "r", "value": "0", "type": "int"}, {"name": "c", "value": "7", "type": "int"}, {"name": "v", "value": "7", "type": "int"}], "return": {"value": "119", "type": "int"}}, {"args": [{"name": "r", "value": "0", "type": "int"}, {"name": "c", "value": "9", "type": "int"}, {"name": "v", "value": "0", "type": "int"}], "return": {"value": "144", "type": "int"}}, {"args": [{"name": "r", "value": "0", "type": "int"}, {"name": "c", "value": "10", "type": "int"}, {"name": "v", "value": "11", "type": "int"}], "return": {"value": "171", "type": "int"}}, {"args": [{"name": "r", "value": "0", "type": "int"}, {"name": "c", "value": "13", "type": "int"}, {"name": "v", "value": "15", "type": "int"}], "return": {"value": "223", "type": "int"}}, {"args": [{"name": "r", "value": "1", "type": "int"}, {"name": "c", "value": "1", "type": "int"}, {"name": "v", "value": "4", "type": "int"}], "return": {"value": "276", "type": "int"}}, {"args": [{"name": "r", "value": "1", "type": "int"}, {"name": "c", "value": "2", "type": "int"}, {"name": "v", "value": "6", "type": "int"}], "return": {"value": "294", "type": "int"}}, {"args": [{"name": "r", "value": "1", "type": "int"}, {"name": "c", "value": "3", "type": "int"}, {"name": "v", "value": "12", "type": "int"}], "return": {"value": "316", "type": "int"}}]}, {"name": "blk", "description": null, "examples": [{"args": [{"name": "a", "value": "0", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "1", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "2", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "3", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "4", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "5", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "6", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "7", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "8", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "9", "type": "int"}], "return": {"value": "0", "type": "int"}}]}, {"name": "bv", "description": null, "examples": [{"args": [{"name": "a", "value": "0", "type": "int"}], "return": {"value": "768", "type": "int"}}, {"args": [{"name": "a", "value": "1", "type": "int"}], "return": {"value": "769", "type": "int"}}, {"args": [{"name": "a", "value": "2", "type": "int"}], "return": {"value": "770", "type": "int"}}, {"args": [{"name": "a", "value": "3", "type": "int"}], "return": {"value": "771", "type": "int"}}, {"args": [{"name": "a", "value": "4", "type": "int"}], "return": {"value": "772", "type": "int"}}, {"args": [{"name": "a", "value": "5", "type": "int"}], "return": {"value": "773", "type": "int"}}, {"args": [{"name": "a", "value": "6", "type": "int"}], "return": {"value": "774", "type": "int"}}, {"args": [{"name": "a", "value": "7", "type": "int"}], "return": {"value": "775", "type": "int"}}, {"args": [{"name": "a", "value": "8", "type": "int"}], "return": {"value": "776", "type": "int"}}, {"args": [{"name": "a", "value": "9", "type": "int"}], "return": {"value": "777", "type": "int"}}]}, {"name": "col", "description": null, "examples": [{"args": [{"name": "a", "value": "0", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "1", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "2", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "3", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "4", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "5", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "6", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "7", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "8", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "9", "type": "int"}], "return": {"value": "0", "type": "int"}}]}, {"name": "cv", "description": null, "examples": [{"args": [{"name": "a", "value": "0", "type": "int"}], "return": {"value": "512", "type": "int"}}, {"args": [{"name": "a", "value": "1", "type": "int"}], "return": {"value": "513", "type": "int"}}, {"args": [{"name": "a", "value": "2", "type": "int"}], "return": {"value": "514", "type": "int"}}, {"args": [{"name": "a", "value": "3", "type": "int"}], "return": {"value": "515", "type": "int"}}, {"args": [{"name": "a", "value": "4", "type": "int"}], "return": {"value": "516", "type": "int"}}, {"args": [{"name": "a", "value": "5", "type": "int"}], "return": {"value": "517", "type": "int"}}, {"args": [{"name": "a", "value": "6", "type": "int"}], "return": {"value": "518", "type": "int"}}, {"args": [{"name": "a", "value": "7", "type": "int"}], "return": {"value": "519", "type": "int"}}, {"args": [{"name": "a", "value": "8", "type": "int"}], "return": {"value": "520", "type": "int"}}, {"args": [{"name": "a", "value": "9", "type": "int"}], "return": {"value": "521", "type": "int"}}]}, {"name": "rc", "description": null, "examples": [{"args": [{"name": "a", "value": "0", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "1", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "2", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "3", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "4", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "5", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "6", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "7", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "8", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "9", "type": "int"}], "return": {"value": "0", "type": "int"}}]}, {"name": "row", "description": null, "examples": [{"args": [{"name": "a", "value": "0", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "1", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "2", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "3", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "4", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "5", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "6", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "7", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "8", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "9", "type": "int"}], "return": {"value": "0", "type": "int"}}]}, {"name": "rv", "description": null, "examples": [{"args": [{"name": "a", "value": "0", "type": "int"}], "return": {"value": "256", "type": "int"}}, {"args": [{"name": "a", "value": "1", "type": "int"}], "return": {"value": "257", "type": "int"}}, {"args": [{"name": "a", "value": "2", "type": "int"}], "return": {"value": "258", "type": "int"}}, {"args": [{"name": "a", "value": "3", "type": "int"}], "return": {"value": "259", "type": "int"}}, {"args": [{"name": "a", "value": "4", "type": "int"}], "return": {"value": "260", "type": "int"}}, {"args": [{"name": "a", "value": "5", "type": "int"}], "return": {"value": "261", "type": "int"}}, {"args": [{"name": "a", "value": "6", "type": "int"}], "return": {"value": "262", "type": "int"}}, {"args": [{"name": "a", "value": "7", "type": "int"}], "return": {"value": "263", "type": "int"}}, {"args": [{"name": "a", "value": "8", "type": "int"}], "return": {"value": "264", "type": "int"}}, {"args": [{"name": "a", "value": "9", "type": "int"}], "return": {"value": "265", "type": "int"}}]}, {"name": "sudoku", "description": "Solving Sudoku\n\n    :param G: integer matrix with 0 at empty cells\n    :returns bool: True if grid could be solved\n    :modifies: G will contain the solution\n    :complexity: huge, but linear for usual published 9x9 grids\n    ", "examples": []}, {"name": "val", "description": null, "examples": [{"args": [{"name": "a", "value": "0", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "a", "value": "1", "type": "int"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "a", "value": "2", "type": "int"}], "return": {"value": "2", "type": "int"}}, {"args": [{"name": "a", "value": "3", "type": "int"}], "return": {"value": "3", "type": "int"}}, {"args": [{"name": "a", "value": "4", "type": "int"}], "return": {"value": "4", "type": "int"}}, {"args": [{"name": "a", "value": "5", "type": "int"}], "return": {"value": "5", "type": "int"}}, {"args": [{"name": "a", "value": "6", "type": "int"}], "return": {"value": "6", "type": "int"}}, {"args": [{"name": "a", "value": "7", "type": "int"}], "return": {"value": "7", "type": "int"}}, {"args": [{"name": "a", "value": "8", "type": "int"}], "return": {"value": "8", "type": "int"}}, {"args": [{"name": "a", "value": "9", "type": "int"}], "return": {"value": "9", "type": "int"}}]}], "classes": []}, "FR": {"name": "sudoku", "description": "La r\u00e9solution de Sudoku (nanpure)\njill-jenn vie et christoph durr - 2014-2019\n", "functions": [{"name": "affectation", "description": null}, {"name": "blk", "description": null}, {"name": "bv", "description": null}, {"name": "col", "description": null}, {"name": "cv", "description": null}, {"name": "rc", "description": null}, {"name": "ligne", "description": null}, {"name": "rv", "description": null}, {"name": "sudoku", "description": "La R\u00e9solution De Sudoku\n\n:param G: integer matrice de 0 \u00e0 cellules vides\n:renvoie un bool\u00e9en: True si la grille pourrait \u00eatre r\u00e9solu\n:modifie: G contiendra la solution\n:complexit\u00e9: \u00e9norme, mais lin\u00e9aire pour habitude publi\u00e9 des grilles de 9x9\n"}, {"name": "val", "description": null}], "classes": []}}, {"EN": {"name": "skip_list", "description": "skip-list\nlouis abraham - 2017-2019\n\nInspired by https://kunigami.blog/2012/09/25/skip-lists-in-python/\ncount contains the gap between the positions\n(https://www.cs.bgu.ac.il/~ds112/wiki.files/ds112_ps7.pdf)\n", "functions": [], "classes": [{"name": "AbstractSkipList", "description": null, "methods": [{"name": "__bool__", "description": null}, {"name": "__contains__", "description": null}, {"name": "__getattr__", "description": null}, {"name": "__init__", "description": null}, {"name": "__iter__", "description": "Iterable in ascending order"}, {"name": "__len__", "description": null}, {"name": "_updateList", "description": null}, {"name": "find", "description": null}, {"name": "getkth", "description": "starts from 0"}, {"name": "insert", "description": null}, {"name": "lastKey", "description": "lastKey(key) < key"}, {"name": "nextKey", "description": "nextKey(key) >= key"}, {"name": "nextNode", "description": null}, {"name": "randomHeight", "description": null}, {"name": "remove", "description": null}]}, {"name": "SortedDict", "description": null, "methods": [{"name": "__bool__", "description": null}, {"name": "__contains__", "description": null}, {"name": "__delitem__", "description": null}, {"name": "__getattr__", "description": null}, {"name": "__getitem__", "description": null}, {"name": "__init__", "description": null}, {"name": "__iter__", "description": "Iterable in ascending order"}, {"name": "__len__", "description": null}, {"name": "__repr__", "description": null}, {"name": "__setitem__", "description": null}, {"name": "_updateList", "description": null}, {"name": "find", "description": null}, {"name": "getkth", "description": "starts from 0"}, {"name": "insert", "description": null}, {"name": "keys", "description": null}, {"name": "lastKey", "description": "lastKey(key) < key"}, {"name": "nextKey", "description": "nextKey(key) >= key"}, {"name": "nextNode", "description": null}, {"name": "randomHeight", "description": null}, {"name": "remove", "description": null}]}, {"name": "SortedSet", "description": null, "methods": [{"name": "__bool__", "description": null}, {"name": "__contains__", "description": null}, {"name": "__getattr__", "description": null}, {"name": "__init__", "description": null}, {"name": "__iter__", "description": "Iterable in ascending order"}, {"name": "__len__", "description": null}, {"name": "__repr__", "description": null}, {"name": "_updateList", "description": null}, {"name": "add", "description": null}, {"name": "find", "description": null}, {"name": "getkth", "description": "starts from 0"}, {"name": "insert", "description": null}, {"name": "lastKey", "description": "lastKey(key) < key"}, {"name": "nextKey", "description": "nextKey(key) >= key"}, {"name": "nextNode", "description": null}, {"name": "pop", "description": "Pops the first element"}, {"name": "randomHeight", "description": null}, {"name": "remove", "description": null}]}]}, "FR": {"name": "skip_list", "description": "skip-list\nlouis abraham - 2017-2019\n\nInspir\u00e9 par https://kunigami.blog/2012/09/25/skip-lists-in-python/\nle comte contient l'\u00e9cart entre les positions\n(https://www.cs.bgu.ac.il/~ds112/wiki.fichiers/ds112_ps7.pdf)\n", "functions": [], "classes": [{"name": "AbstractSkipList", "description": null, "methods": [{"name": "__bool__", "description": null}, {"name": "__contient__", "description": null}, {"name": "__getattr__", "description": null}, {"name": "__init__", "description": null}, {"name": "__iter__", "description": "It\u00e9rable dans l'ordre croissant"}, {"name": "__len__", "description": null}, {"name": "_updateList", "description": null}, {"name": "trouver", "description": null}, {"name": "getkth", "description": "commence \u00e0 partir de 0"}, {"name": "ins\u00e9rer", "description": null}, {"name": "lastKey", "description": "lastKey(cl\u00e9) < key"}, {"name": "nextKey", "description": "nextKey(cl\u00e9) >= cl\u00e9"}, {"name": "nextNode", "description": null}, {"name": "randomHeight", "description": null}, {"name": "supprimer", "description": null}]}, {"name": "SortedDict", "description": null, "methods": [{"name": "__bool__", "description": null}, {"name": "__contient__", "description": null}, {"name": "__delitem__", "description": null}, {"name": "__getattr__", "description": null}, {"name": "__getitem__", "description": null}, {"name": "__init__", "description": null}, {"name": "__iter__", "description": "It\u00e9rable dans l'ordre croissant"}, {"name": "__len__", "description": null}, {"name": "__repr__", "description": null}, {"name": "__setitem__", "description": null}, {"name": "_updateList", "description": null}, {"name": "trouver", "description": null}, {"name": "getkth", "description": "commence \u00e0 partir de 0"}, {"name": "ins\u00e9rer", "description": null}, {"name": "touches", "description": null}, {"name": "lastKey", "description": "lastKey(cl\u00e9) < key"}, {"name": "nextKey", "description": "nextKey(cl\u00e9) >= cl\u00e9"}, {"name": "nextNode", "description": null}, {"name": "randomHeight", "description": null}, {"name": "supprimer", "description": null}]}, {"name": "SortedSet", "description": null, "methods": [{"name": "__bool__", "description": null}, {"name": "__contient__", "description": null}, {"name": "__getattr__", "description": null}, {"name": "__init__", "description": null}, {"name": "__iter__", "description": "It\u00e9rable dans l'ordre croissant"}, {"name": "__len__", "description": null}, {"name": "__repr__", "description": null}, {"name": "_updateList", "description": null}, {"name": "ajouter", "description": null}, {"name": "trouver", "description": null}, {"name": "getkth", "description": "commence \u00e0 partir de 0"}, {"name": "ins\u00e9rer", "description": null}, {"name": "lastKey", "description": "lastKey(cl\u00e9) < key"}, {"name": "nextKey", "description": "nextKey(cl\u00e9) >= cl\u00e9"}, {"name": "nextNode", "description": null}, {"name": "pop", "description": "Pop le premier \u00e9l\u00e9ment"}, {"name": "randomHeight", "description": null}, {"name": "supprimer", "description": null}]}]}}, {"EN": {"name": "merge_ordered_lists", "description": "Merge two ordered lists\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "merge", "description": "Merge two ordered lists\n\n    :param x:\n    :param y: x, y are nondecreasing ordered lists\n    :returns: union of x and y in order\n    :complexity: linear\n    ", "examples": [{"args": [{"name": "x", "value": "range(0, 10, 2)", "type": "range"}, {"name": "y", "value": "range(1, 10, 2)", "type": "range"}], "return": {"value": "[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]", "type": "list"}}]}], "classes": []}, "FR": {"name": "merge_ordered_lists", "description": "Fusionner deux listes ordonn\u00e9es\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "fusion", "description": "Fusionner deux listes ordonn\u00e9es\n\n:param x:\n:param y: x, y sont nondecreasing listes ordonn\u00e9es\n:retourne: une union de x et y dans l'ordre\n:complexit\u00e9: lin\u00e9aire\n"}], "classes": []}}, {"EN": {"name": "floyd_warshall", "description": "All pairs shortest paths by Floyd-Warshall\njill-j\u00eann vie, christoph d\u00fcrr et pascal ortiz - 2014-2019\n", "functions": [{"name": "floyd_warshall", "description": "All pairs shortest paths by Floyd-Warshall\n\n    :param weight: edge weight matrix\n    :modifies: weight matrix to contain distances in graph\n    :returns: True if there are negative cycles\n    :complexity: :math:`O(|V|^3)`\n    ", "examples": [{"args": [{"name": "weight", "value": "[[inf, inf, -2, inf], [4, inf, 3, inf], [inf, inf, inf, 2], [inf, -1, inf, inf]]", "type": "list"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "weight", "value": "[[0, inf], [inf, 0]]", "type": "list"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "weight", "value": "[[0, 1, inf, 1, inf], [1, 0, 1, 1, inf], [inf, 1, 0, inf, 1], [1, 1, inf, 0, inf], [inf, inf, 1, inf, 0]]", "type": "list"}], "return": {"value": "False", "type": "bool"}}]}, {"name": "floyd_warshall2", "description": "All pairs shortest paths by Floyd-Warshall.\n    An improved implementation by Pascal-Ortiz\n\n    :param weight: edge weight matrix\n    :modifies: weight matrix to contain distances in graph\n    :returns: True if there are negative cycles\n    :complexity: :math:`O(|V|^3)`\n    ", "examples": [{"args": [{"name": "weight", "value": "[[inf, inf, -2, inf], [4, inf, 3, inf], [inf, inf, inf, 2], [inf, -1, inf, inf]]", "type": "list"}], "return": {"value": "False", "type": "bool"}}]}], "classes": []}, "FR": {"name": "floyd_warshall", "description": "Toutes les paires les plus courts chemins Floyd-Warshall\njill-j\u00eann vie, christoph d\u00fcrr et pascal ortiz - 2014-2019\n", "functions": [{"name": "floyd_warshall", "description": "Toutes les paires les plus courts chemins Floyd-Warshall\n\n:param poids: edge matrice de poids\n:modifie: matrice de poids pour contenir les distances dans le graphique\n:retourne: True si il y a des cycles n\u00e9gatifs\n:complexit\u00e9: :math:`O(|V|^3)`\n"}, {"name": "floyd_warshall2", "description": "Toutes les paires les plus courts chemins Floyd-Warshall.\nUne am\u00e9lioration de la mise en \u0153uvre par Pascal-Ortiz\n\n:param poids: edge matrice de poids\n:modifie: matrice de poids pour contenir les distances dans le graphique\n:retourne: True si il y a des cycles n\u00e9gatifs\n:complexit\u00e9: :math:`O(|V|^3)`\n"}], "classes": []}}, {"EN": {"name": "partition_refinement", "description": "Partition refinement\nchristoph d\u00fcrr - 2016-2019\n\nlog: 10/11/2016 modified to preserve class order after refinement\n     15/11/2016 this was nonsense, moved back\n", "functions": [], "classes": [{"name": "DoubleLinkedListItem", "description": "Item of a circular double linked list\n    ", "methods": [{"name": "__init__", "description": "Create a new item to be inserted before item anchor.\n           if anchor is None: create a single item circular double linked list\n        "}, {"name": "__iter__", "description": "iterate trough circular list.\n        warning: might end stuck in an infinite loop if chaining is not valid\n        "}, {"name": "insert", "description": "insert list item before anchor\n        "}, {"name": "remove", "description": null}]}, {"name": "PartitionClass", "description": "A partition is a list of classes\n    ", "methods": [{"name": "__init__", "description": null}, {"name": "__iter__", "description": "iterate trough circular list.\n        warning: might end stuck in an infinite loop if chaining is not valid\n        "}, {"name": "append", "description": "add item to the end of the item list\n        "}, {"name": "insert", "description": "insert list item before anchor\n        "}, {"name": "remove", "description": null}]}, {"name": "PartitionItem", "description": "A class is a list of items\n    ", "methods": [{"name": "__init__", "description": null}, {"name": "__iter__", "description": "iterate trough circular list.\n        warning: might end stuck in an infinite loop if chaining is not valid\n        "}, {"name": "insert", "description": "insert list item before anchor\n        "}, {"name": "remove", "description": "remove item from its class\n        "}]}, {"name": "PartitionRefinement", "description": "This data structure implements an order preserving\n    partition with refinements.\n    ", "methods": [{"name": "__init__", "description": "Start with the partition consisting of the unique class {0,1,..,n-1}\n        complexity: O(n) both in time and space\n        "}, {"name": "order", "description": "Produce a flatten list of the partition, ordered by classes\n        "}, {"name": "refine", "description": "Split every class C in the partition into C intersection pivot\n        and C setminus pivot complexity: linear in size of pivot\n        "}, {"name": "tolist", "description": "produce a list representation of the partition\n        "}]}]}, "FR": {"name": "partition_refinement", "description": "Partition de raffinement\nchristoph d\u00fcrr - 2016-2019\n\njournal: 10/11/2016 modifi\u00e9s pour pr\u00e9server l'ordre de classe apr\u00e8s raffinement\n15/11/2016 c'\u00e9tait une b\u00eatise, s'est d\u00e9plac\u00e9 en arri\u00e8re\n", "functions": [], "classes": [{"name": "DoubleLinkedListItem", "description": "\u00c9l\u00e9ment d'une circulaire doublement cha\u00een\u00e9e liste\n", "methods": [{"name": "__init__", "description": "Cr\u00e9er un nouvel \u00e9l\u00e9ment \u00e0 ins\u00e9rer, avant l'article d'ancrage.\nsi l'ancre est Aucun: cr\u00e9er un seul \u00e9l\u00e9ment circulaire doublement cha\u00een\u00e9e liste\n"}, {"name": "__iter__", "description": "it\u00e9rer auge circulaire de la liste.\navertissement: peut-fin bloqu\u00e9 dans une boucle infinie si le cha\u00eenage n'est pas valide\n"}, {"name": "ins\u00e9rer", "description": "ins\u00e9rer un \u00e9l\u00e9ment de la liste avant d'ancrage\n"}, {"name": "supprimer", "description": null}]}, {"name": "PartitionClass", "description": "Une partition est une liste de classes\n", "methods": [{"name": "__init__", "description": null}, {"name": "__iter__", "description": "it\u00e9rer auge circulaire de la liste.\navertissement: peut-fin bloqu\u00e9 dans une boucle infinie si le cha\u00eenage n'est pas valide\n"}, {"name": "ajouter", "description": "ajouter un \u00e9l\u00e9ment \u00e0 la fin de l'\u00e9l\u00e9ment de la liste\n"}, {"name": "ins\u00e9rer", "description": "ins\u00e9rer un \u00e9l\u00e9ment de la liste avant d'ancrage\n"}, {"name": "supprimer", "description": null}]}, {"name": "PartitionItem", "description": "Une classe est une liste d'\u00e9l\u00e9ments\n", "methods": [{"name": "__init__", "description": null}, {"name": "__iter__", "description": "it\u00e9rer auge circulaire de la liste.\navertissement: peut-fin bloqu\u00e9 dans une boucle infinie si le cha\u00eenage n'est pas valide\n"}, {"name": "ins\u00e9rer", "description": "ins\u00e9rer un \u00e9l\u00e9ment de la liste avant d'ancrage\n"}, {"name": "supprimer", "description": "supprimer un \u00e9l\u00e9ment \u00e0 partir de sa cat\u00e9gorie\n"}]}, {"name": "PartitionRefinement", "description": "Cette structure de donn\u00e9es met en \u0153uvre un ordre de pr\u00e9servation de\npartition avec des raffinements.\n", "methods": [{"name": "__init__", "description": "Commencer avec la partition compos\u00e9e de la classe unique {0,1,..,n-1}\ncomplexit\u00e9: O(n) \u00e0 la fois dans le temps et l'espace\n"}, {"name": "afin", "description": "Produire un aplatir liste de la partition, class\u00e9s par cat\u00e9gories\n"}, {"name": "affiner", "description": "Diviser chaque classe C dans la partition en C intersection de pivot\net C setminus pivot complexit\u00e9 lin\u00e9aire en la taille de pivot\n"}, {"name": "tolist", "description": "produire une liste \u00e0 la repr\u00e9sentation de la partition\n"}]}]}}, {"EN": {"name": "subsetsum_divide", "description": "Subsetsum by splitting\nchristoph d\u00fcrr et jill-j\u00eann vie - 2014-2019\n", "functions": [{"name": "part_sum", "description": "All subsetsums from x_table[i:]\n\n    :param x_table: table of values\n    :param int i: index_table defining suffix_table of x_table to be considered\n    :iterates: over all values, in arbitrary order\n    :complexity: :math:`O(2^{len(x_table)-i})`\n    ", "examples": [{"args": [{"name": "x_table", "value": "[2, 4]", "type": "list"}, {"name": "i", "value": "2", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "x_table", "value": "[2, 4]", "type": "list"}, {"name": "i", "value": "1", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "x_table", "value": "[2, 4]", "type": "list"}, {"name": "i", "value": "0", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "x_table", "value": "[2, 4]", "type": "list"}, {"name": "i", "value": "0", "type": "int"}], "return": {"value": "2", "type": "int"}}, {"args": [{"name": "x_table", "value": "[2, 4]", "type": "list"}, {"name": "i", "value": "1", "type": "int"}], "return": {"value": "4", "type": "int"}}, {"args": [{"name": "x_table", "value": "[2, 4]", "type": "list"}, {"name": "i", "value": "0", "type": "int"}], "return": {"value": "4", "type": "int"}}, {"args": [{"name": "x_table", "value": "[2, 4]", "type": "list"}, {"name": "i", "value": "0", "type": "int"}], "return": {"value": "6", "type": "int"}}, {"args": [{"name": "x_table", "value": "[2, 4]", "type": "list"}, {"name": "i", "value": "2", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "x_table", "value": "[2, 4]", "type": "list"}, {"name": "i", "value": "1", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "x_table", "value": "[2, 4]", "type": "list"}, {"name": "i", "value": "0", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}]}, {"name": "part_sum2", "description": "All subsetsums from a list x\n\n    :param x_table: list of values\n    :complexity: :math:`O(2^{len(x)})`\n    ", "examples": [{"args": [{"name": "x_table", "value": "[2, 4]", "type": "list"}], "return": {"value": "{0, 2, 4, 6}", "type": "set"}}, {"args": [{"name": "x_table", "value": "[8, 16, 32]", "type": "list"}], "return": {"value": "{0, 32, 8, 40, 16, 48, 24, 56}", "type": "set"}}]}, {"name": "subset_sum", "description": "Subsetsum by splitting\n\n    :param x_table: table of values\n    :param r_target: target value\n    :returns bool: if there is a subsequence of x_table with total sum r_target\n    :complexity: :math:`O(n^{\\lceil n/2 \\rceil})`\n    ", "examples": [{"args": [{"name": "x_table", "value": "[2, 4, 8, 16, 32]", "type": "list"}, {"name": "r_target", "value": "27", "type": "int"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "x_table", "value": "[2, 4, 8, 16, 32]", "type": "list"}, {"name": "r_target", "value": "28", "type": "int"}], "return": {"value": "True", "type": "bool"}}]}, {"name": "subset_sum2", "description": "Subsetsum by splitting\n\n    :param x_table: table of values\n    :param r_target: target value\n    :returns bool: if there is a subsequence of x_table with total sum r_target\n    :complexity: :math:`O(n^{\\lceil n/2 \\rceil})`\n    ", "examples": [{"args": [{"name": "x_table", "value": "[2, 4, 8, 16, 32]", "type": "list"}, {"name": "r_target", "value": "27", "type": "int"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "x_table", "value": "[2, 4, 8, 16, 32]", "type": "list"}, {"name": "r_target", "value": "28", "type": "int"}], "return": {"value": "True", "type": "bool"}}]}], "classes": []}, "FR": {"name": "subsetsum_divide", "description": "Subsetsum par fractionnement\nchristoph d\u00fcrr et jill-j\u00eann vie - 2014-2019\n", "functions": [{"name": "part_sum", "description": "Tous les subsetsums de x_table[i:]\n\n:param x_table: tableau de valeurs\n:param int i: index_table d\u00e9finition suffix_table de x_table \u00eatre consid\u00e9r\u00e9 comme\n:it\u00e8re: plus de toutes les valeurs, dans un ordre arbitraire\n:complexit\u00e9: :math:`O(2^{len(x_table)-i})`\n"}, {"name": "part_sum2", "description": "Tous les subsetsums \u00e0 partir d'une liste x\n\n:param x_table: liste de valeurs\n:complexit\u00e9: :math:`O(2^{len(x)})`\n"}, {"name": "subset_sum", "description": "Subsetsum par fractionnement\n\n:param x_table: tableau de valeurs\n:param r_target: valeur cible\n:renvoie un bool: si il existe une sous-suite de x_table \u00e0 la somme totale r_target\n:complexit\u00e9: :math:`O(n^{\\lceil n/2 \\rceil})`\n"}, {"name": "subset_sum2", "description": "Subsetsum par fractionnement\n\n:param x_table: tableau de valeurs\n:param r_target: valeur cible\n:renvoie un bool: si il existe une sous-suite de x_table \u00e0 la somme totale r_target\n:complexit\u00e9: :math:`O(n^{\\lceil n/2 \\rceil})`\n"}], "classes": []}}, {"EN": {"name": "rectangles_from_histogram", "description": "Largest Rectangular Area in a Histogram\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "rectangles_from_histogram", "description": "Largest Rectangular Area in a Histogram\n\n    :param H: histogram table\n    :returns: area, left, height, right, rect. is [0, height] * [left, right)\n    :complexity: linear\n    ", "examples": [{"args": [{"name": "H", "value": "[1, 0, 1, 1, 0, 1, 1, 1]", "type": "list"}], "return": {"value": "(3, 5, 1, 8)", "type": "tuple"}}, {"args": [{"name": "H", "value": "[0, 1, 0, 0, 0, 2, 0, 2]", "type": "list"}], "return": {"value": "(2, 7, 2, 8)", "type": "tuple"}}, {"args": [{"name": "H", "value": "[1, 2, 0, 1, 1, 0, 0, 0]", "type": "list"}], "return": {"value": "(2, 3, 1, 5)", "type": "tuple"}}, {"args": [{"name": "H", "value": "[0, 0, 1, 2, 2, 0, 1, 0]", "type": "list"}], "return": {"value": "(4, 3, 2, 5)", "type": "tuple"}}, {"args": [{"name": "H", "value": "[1, 1, 0, 3, 3, 1, 0, 1]", "type": "list"}], "return": {"value": "(6, 3, 3, 5)", "type": "tuple"}}, {"args": [{"name": "H", "value": "[0, 2, 0, 0, 0, 2, 0, 2]", "type": "list"}], "return": {"value": "(2, 7, 2, 8)", "type": "tuple"}}, {"args": [{"name": "H", "value": "[]", "type": "list"}], "return": {"value": "(-inf, 0, 0, 0)", "type": "tuple"}}, {"args": [{"name": "H", "value": "[12]", "type": "list"}], "return": {"value": "(12, 0, 12, 1)", "type": "tuple"}}, {"args": [{"name": "H", "value": "[8, 42]", "type": "list"}], "return": {"value": "(42, 1, 42, 2)", "type": "tuple"}}, {"args": [{"name": "H", "value": "[90, 23, 94]", "type": "list"}], "return": {"value": "(94, 2, 94, 3)", "type": "tuple"}}]}], "classes": []}, "FR": {"name": "rectangles_from_histogram", "description": "Plus grande Zone Rectangulaire dans un Histogramme\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "rectangles_from_histogram", "description": "Plus grande Zone Rectangulaire dans un Histogramme\n\n:param H: histogramme de la table\n:r\u00e9sultat: domaine, \u00e0 gauche, en hauteur, \u00e0 droite, rect. est [0, hauteur] * [gauche, droite)\n:complexit\u00e9: lin\u00e9aire\n"}], "classes": []}}, {"EN": {"name": "kruskal", "description": "Minimum spanning tree by kruskal\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "dist", "description": "\n    distance between point a and point b\n    "}, {"name": "kruskal", "description": "Minimum spanning tree by Kruskal\n\n    :param graph: undirected graph in listlist or listdict format\n    :param weight: in matrix format or same listdict graph\n    :returns: list of edges of the tree\n    :complexity: ``O(|E|log|E|)``\n    ", "examples": [{"args": [{"name": "graph", "value": "[{1: 11, 2: 13, 3: 12}, {0: 11, 3: 14}, {0: 13, 3: 10}, {0: 12, 1: 14, 2: 10}]", "type": "list"}, {"name": "weight", "value": "[{1: 11, 2: 13, 3: 12}, {0: 11, 3: 14}, {0: 13, 3: 10}, {0: 12, 1: 14, 2: 10}]", "type": "list"}], "return": {"value": "[(2, 3), (0, 1), (0, 3)]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1, 2, 3], [0, 3], [0, 3], [0, 1, 2]]", "type": "list"}, {"name": "weight", "value": "[[None, 11, 13, 12], [11, None, None, 14], [13, None, None, 10], [12, 14, 10, None]]", "type": "list"}], "return": {"value": "[(2, 3), (0, 1), (0, 3)]", "type": "list"}}]}], "classes": [{"name": "UnionFind", "description": "Maintains a partition of {0, ..., n-1}\n    ", "methods": [{"name": "__init__", "description": null}, {"name": "find", "description": "\n        :returns: identifier of part containing x_index\n        :complex_indexity: O(inverse_ackerman(n))\n        "}, {"name": "union", "description": "\n        Merges part that contain x and part containing y\n        :returns: False if x_index, y_index are already in same part\n        :complexity: O(inverse_ackerman(n))\n        "}]}]}, "FR": {"name": "kruskal", "description": "Minimum spanning tree par kruskal\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "dist", "description": "\nla distance entre le point a et le point b\n"}, {"name": "kruskal", "description": "Minimum spanning tree par Kruskal\n\n:param graphe: graphe non-dirig\u00e9 dans listlist ou listdict format\n:param poids: dans un format de matrice ou m\u00eame listdict graphique\n:retourne: liste des bords de l'arbre\n:complexit\u00e9: `O(|E|log|E|)`\n"}], "classes": [{"name": "UnionFind", "description": "Maintient d'une partition de {0, ..., n-1}\n", "methods": [{"name": "__init__", "description": null}, {"name": "trouver", "description": "\n:retourne: identificateur de la partie contenant x_index\n:complex_indexity: O(inverse_ackerman(n))\n"}, {"name": "union", "description": "\nFusionne la partie qui contiennent x et y contenant\n:retourne False si x_index, y_index sont d\u00e9j\u00e0 dans la m\u00eame partie\n:complexit\u00e9: O(inverse_ackerman(n))\n"}]}]}}, {"EN": {"name": "levenshtein", "description": "Levenshtein edit distance\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "levenshtein", "description": "Levenshtein edit distance\n\n    :param x:\n    :param y: strings\n    :returns: distance\n    :complexity: `O(|x|*|y|)`\n    ", "examples": [{"args": [{"name": "x", "value": "'AUDI'", "type": "str"}, {"name": "y", "value": "'LADA'", "type": "str"}], "return": {"value": "3", "type": "int"}}, {"args": [{"name": "x", "value": "'kitten'", "type": "str"}, {"name": "y", "value": "'sitting'", "type": "str"}], "return": {"value": "3", "type": "int"}}]}], "classes": []}, "FR": {"name": "levenshtein", "description": "Levenshtein distance d'\u00e9dition\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "levenshtein", "description": "Levenshtein distance d'\u00e9dition\n\n:param x:\n:param y: les cha\u00eenes de caract\u00e8res\n:retourne: distance\n:complexit\u00e9: O(|x|*|y|)`\n"}], "classes": []}}, {"EN": {"name": "convex_hull", "description": "Convex hull by Andrew\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "andrew", "description": "Convex hull by Andrew\n\n    :param S: list of points as coordinate pairs\n    :requires: S has at least 2 points\n    :returns: list of points of the convex hull\n    :complexity: `O(n log n)`\n    ", "examples": [{"args": [{"name": "S", "value": "[(0, 0), (1, 0), (2, 1), (2, 4), (1, 3), (0, 3), (1, 2)]", "type": "list"}], "return": {"value": "[(0, 0), (1, 0), (2, 1), (2, 4), (0, 3)]", "type": "list"}}, {"args": [{"name": "S", "value": "[(0, 0), (1, 0), (2, 1), (2, 4), (1, 3), (0, 3), (0, 2)]", "type": "list"}], "return": {"value": "[(0, 0), (1, 0), (2, 1), (2, 4), (0, 3)]", "type": "list"}}, {"args": [{"name": "S", "value": "[(0, 0), (1, 0), (2, 1), (2, 4), (1, 3), (0, 3), (-1, 2)]", "type": "list"}], "return": {"value": "[(-1, 2), (0, 0), (1, 0), (2, 1), (2, 4), (0, 3)]", "type": "list"}}, {"args": [{"name": "S", "value": "[(0, 0), (1, 0)]", "type": "list"}], "return": {"value": "[(0, 0), (1, 0)]", "type": "list"}}, {"args": [{"name": "S", "value": "[(0, 0), (0, 1)]", "type": "list"}], "return": {"value": "[(0, 0), (0, 1)]", "type": "list"}}]}, {"name": "left_turn", "description": "function left-turn", "examples": [{"args": [{"name": "a", "value": "(1, 0)", "type": "tuple"}, {"name": "b", "value": "(0, 3)", "type": "tuple"}, {"name": "c", "value": "(0, 0)", "type": "tuple"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "a", "value": "(0, 0)", "type": "tuple"}, {"name": "b", "value": "(0, 3)", "type": "tuple"}, {"name": "c", "value": "(1, 0)", "type": "tuple"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "a", "value": "(1, 2)", "type": "tuple"}, {"name": "b", "value": "(1, 0)", "type": "tuple"}, {"name": "c", "value": "(0, 3)", "type": "tuple"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "a", "value": "(1, 2)", "type": "tuple"}, {"name": "b", "value": "(0, 3)", "type": "tuple"}, {"name": "c", "value": "(0, 0)", "type": "tuple"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "a", "value": "(0, 0)", "type": "tuple"}, {"name": "b", "value": "(1, 0)", "type": "tuple"}, {"name": "c", "value": "(1, 2)", "type": "tuple"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "a", "value": "(1, 3)", "type": "tuple"}, {"name": "b", "value": "(1, 2)", "type": "tuple"}, {"name": "c", "value": "(0, 3)", "type": "tuple"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "a", "value": "(1, 3)", "type": "tuple"}, {"name": "b", "value": "(0, 3)", "type": "tuple"}, {"name": "c", "value": "(0, 0)", "type": "tuple"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "a", "value": "(1, 0)", "type": "tuple"}, {"name": "b", "value": "(1, 2)", "type": "tuple"}, {"name": "c", "value": "(1, 3)", "type": "tuple"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "a", "value": "(0, 0)", "type": "tuple"}, {"name": "b", "value": "(1, 0)", "type": "tuple"}, {"name": "c", "value": "(1, 3)", "type": "tuple"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "a", "value": "(2, 1)", "type": "tuple"}, {"name": "b", "value": "(1, 3)", "type": "tuple"}, {"name": "c", "value": "(0, 3)", "type": "tuple"}], "return": {"value": "True", "type": "bool"}}]}], "classes": []}, "FR": {"name": "convex_hull", "description": "L'enveloppe convexe par Andrew\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "andrew", "description": "L'enveloppe convexe par Andrew\n\n:param S: liste des points de paires de coordonn\u00e9es\n:n\u00e9cessite: S y a au moins 2 points\n:retourne: liste des points de l'enveloppe convexe\n:complexit\u00e9: O(n log n)`\n"}, {"name": "left_turn", "description": "la fonction de virage \u00e0 gauche"}], "classes": []}}, {"EN": {"name": "kuhn_munkres_n4", "description": "kuhn_munkres_n4\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "improve_labels", "description": "improve labels", "examples": [{"args": [{"name": "G", "value": "[[7, 53, 183, 439, 863], [497, 383, 563, 79, 973], [287, 63, 343, 169, 583], [627, 343, 773, 959, 943], [767, 473, 103, 699, 303]]", "type": "list"}, {"name": "au", "value": "[True, True, False, False, False]", "type": "list"}, {"name": "av", "value": "[False, False, False, False, True]", "type": "list"}, {"name": "lu", "value": "[863, 973, 583, 959, 767]", "type": "list"}, {"name": "lv", "value": "[0, 0, 0, 0, 0]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "G", "value": "[[7, 53, 183, 439, 863], [497, 383, 563, 79, 973], [287, 63, 343, 169, 583], [627, 343, 773, 959, 943], [767, 473, 103, 699, 303]]", "type": "list"}, {"name": "au", "value": "[False, False, True, False, False]", "type": "list"}, {"name": "av", "value": "[False, False, False, False, False]", "type": "list"}, {"name": "lu", "value": "[453, 563, 583, 959, 767]", "type": "list"}, {"name": "lv", "value": "[0, 0, 0, 0, 410]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "G", "value": "[[7, 53, 183, 439, 863], [497, 383, 563, 79, 973], [287, 63, 343, 169, 583], [627, 343, 773, 959, 943], [767, 473, 103, 699, 303]]", "type": "list"}, {"name": "au", "value": "[True, True, True, False, False]", "type": "list"}, {"name": "av", "value": "[False, False, True, False, True]", "type": "list"}, {"name": "lu", "value": "[453, 563, 343, 959, 767]", "type": "list"}, {"name": "lv", "value": "[0, 0, 0, 0, 410]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "G", "value": "[[7, 53, 183, 439, 863], [497, 383, 563, 79, 973], [287, 63, 343, 169, 583], [627, 343, 773, 959, 943], [767, 473, 103, 699, 303]]", "type": "list"}, {"name": "au", "value": "[True, True, True, True, False]", "type": "list"}, {"name": "av", "value": "[False, False, True, True, True]", "type": "list"}, {"name": "lu", "value": "[439, 549, 329, 959, 767]", "type": "list"}, {"name": "lv", "value": "[0, 0, 14, 0, 424]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "G", "value": "[[7, 53, 183, 439, 863], [497, 383, 563, 79, 973], [287, 63, 343, 169, 583], [627, 343, 773, 959, 943], [767, 473, 103, 699, 303]]", "type": "list"}, {"name": "au", "value": "[True, True, True, True, True]", "type": "list"}, {"name": "av", "value": "[True, False, True, True, True]", "type": "list"}, {"name": "lu", "value": "[397, 507, 287, 917, 767]", "type": "list"}, {"name": "lv", "value": "[0, 0, 56, 42, 466]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}]}, {"name": "improve_matching", "description": "improve matching", "examples": [{"args": [{"name": "G", "value": "[[1]]", "type": "list"}, {"name": "u", "value": "0", "type": "int"}, {"name": "mu", "value": "[None]", "type": "list"}, {"name": "mv", "value": "[None]", "type": "list"}, {"name": "au", "value": "[False]", "type": "list"}, {"name": "av", "value": "[False]", "type": "list"}, {"name": "lu", "value": "[1]", "type": "list"}, {"name": "lv", "value": "[0]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "G", "value": "[[1, 1], [1, 1]]", "type": "list"}, {"name": "u", "value": "0", "type": "int"}, {"name": "mu", "value": "[None, None]", "type": "list"}, {"name": "mv", "value": "[None, None]", "type": "list"}, {"name": "au", "value": "[False, False]", "type": "list"}, {"name": "av", "value": "[False, False]", "type": "list"}, {"name": "lu", "value": "[1, 1]", "type": "list"}, {"name": "lv", "value": "[0, 0]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "G", "value": "[[1, 1], [1, 1]]", "type": "list"}, {"name": "u", "value": "0", "type": "int"}, {"name": "mu", "value": "[0, None]", "type": "list"}, {"name": "mv", "value": "[0, None]", "type": "list"}, {"name": "au", "value": "[False, True]", "type": "list"}, {"name": "av", "value": "[True, False]", "type": "list"}, {"name": "lu", "value": "[1, 1]", "type": "list"}, {"name": "lv", "value": "[0, 0]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "G", "value": "[[1, 1], [1, 1]]", "type": "list"}, {"name": "u", "value": "1", "type": "int"}, {"name": "mu", "value": "[0, None]", "type": "list"}, {"name": "mv", "value": "[0, None]", "type": "list"}, {"name": "au", "value": "[False, False]", "type": "list"}, {"name": "av", "value": "[False, False]", "type": "list"}, {"name": "lu", "value": "[1, 1]", "type": "list"}, {"name": "lv", "value": "[0, 0]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "G", "value": "[[1, 2], [1, 1]]", "type": "list"}, {"name": "u", "value": "0", "type": "int"}, {"name": "mu", "value": "[None, None]", "type": "list"}, {"name": "mv", "value": "[None, None]", "type": "list"}, {"name": "au", "value": "[False, False]", "type": "list"}, {"name": "av", "value": "[False, False]", "type": "list"}, {"name": "lu", "value": "[2, 1]", "type": "list"}, {"name": "lv", "value": "[0, 0]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "G", "value": "[[1, 2], [1, 1]]", "type": "list"}, {"name": "u", "value": "1", "type": "int"}, {"name": "mu", "value": "[1, None]", "type": "list"}, {"name": "mv", "value": "[None, 0]", "type": "list"}, {"name": "au", "value": "[False, False]", "type": "list"}, {"name": "av", "value": "[False, False]", "type": "list"}, {"name": "lu", "value": "[2, 1]", "type": "list"}, {"name": "lv", "value": "[0, 0]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "G", "value": "[[1, 1], [2, 1]]", "type": "list"}, {"name": "u", "value": "0", "type": "int"}, {"name": "mu", "value": "[None, None]", "type": "list"}, {"name": "mv", "value": "[None, None]", "type": "list"}, {"name": "au", "value": "[False, False]", "type": "list"}, {"name": "av", "value": "[False, False]", "type": "list"}, {"name": "lu", "value": "[1, 2]", "type": "list"}, {"name": "lv", "value": "[0, 0]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "G", "value": "[[1, 1], [2, 1]]", "type": "list"}, {"name": "u", "value": "0", "type": "int"}, {"name": "mu", "value": "[0, None]", "type": "list"}, {"name": "mv", "value": "[0, None]", "type": "list"}, {"name": "au", "value": "[False, True]", "type": "list"}, {"name": "av", "value": "[True, False]", "type": "list"}, {"name": "lu", "value": "[1, 2]", "type": "list"}, {"name": "lv", "value": "[0, 0]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "G", "value": "[[1, 1], [2, 1]]", "type": "list"}, {"name": "u", "value": "1", "type": "int"}, {"name": "mu", "value": "[0, None]", "type": "list"}, {"name": "mv", "value": "[0, None]", "type": "list"}, {"name": "au", "value": "[False, False]", "type": "list"}, {"name": "av", "value": "[False, False]", "type": "list"}, {"name": "lu", "value": "[1, 2]", "type": "list"}, {"name": "lv", "value": "[0, 0]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "G", "value": "[[2, 1], [1, 1]]", "type": "list"}, {"name": "u", "value": "0", "type": "int"}, {"name": "mu", "value": "[None, None]", "type": "list"}, {"name": "mv", "value": "[None, None]", "type": "list"}, {"name": "au", "value": "[False, False]", "type": "list"}, {"name": "av", "value": "[False, False]", "type": "list"}, {"name": "lu", "value": "[2, 1]", "type": "list"}, {"name": "lv", "value": "[0, 0]", "type": "list"}], "return": {"value": "True", "type": "bool"}}]}, {"name": "kuhn_munkres", "description": "Maximum profit perfect matching\n\n    for minimum cost perfect matching just inverse the weights\n\n    :param G: squared weight matrix of a complete bipartite graph\n    :complexity: :math:`O(n^4)`\n    ", "examples": [{"args": [{"name": "G", "value": "[[1]]", "type": "list"}], "return": {"value": "([0], 1)", "type": "tuple"}}, {"args": [{"name": "G", "value": "[[1, 1], [1, 1]]", "type": "list"}], "return": {"value": "([1, 0], 2)", "type": "tuple"}}, {"args": [{"name": "G", "value": "[[1, 2], [1, 1]]", "type": "list"}], "return": {"value": "([1, 0], 3)", "type": "tuple"}}, {"args": [{"name": "G", "value": "[[1, 1], [2, 1]]", "type": "list"}], "return": {"value": "([1, 0], 3)", "type": "tuple"}}, {"args": [{"name": "G", "value": "[[2, 1], [1, 1]]", "type": "list"}], "return": {"value": "([0, 1], 3)", "type": "tuple"}}, {"args": [{"name": "G", "value": "[[1, 1], [1, 2]]", "type": "list"}], "return": {"value": "([0, 1], 3)", "type": "tuple"}}, {"args": [{"name": "G", "value": "[[-1, -2, -3], [-6, -5, -4], [-1, -1, -1]]", "type": "list"}], "return": {"value": "([0, 2, 1], -6)", "type": "tuple"}}, {"args": [{"name": "G", "value": "[[1, 2, 3], [6, 5, 4], [1, 1, 1]]", "type": "list"}], "return": {"value": "([2, 0, 1], 10)", "type": "tuple"}}, {"args": [{"name": "G", "value": "[[7, 53, 183, 439, 863], [497, 383, 563, 79, 973], [287, 63, 343, 169, 583], [627, 343, 773, 959, 943], [767, 473, 103, 699, 303]]", "type": "list"}], "return": {"value": "([4, 1, 2, 3, 0], 3315)", "type": "tuple"}}]}], "classes": []}, "FR": {"name": "kuhn_munkres_n4", "description": "kuhn_munkres_n4\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "improve_labels", "description": "am\u00e9liorer les \u00e9tiquettes"}, {"name": "improve_matching", "description": "am\u00e9liorer l'ad\u00e9quation entre l'"}, {"name": "kuhn_munkres", "description": "Le Maximum de profit parfait\n\npour un minimum de co\u00fbt de mise en correspondance parfaite juste \u00e0 l'inverse, le poids\n\n:param G: carr\u00e9 poids de la matrice d'un graphe biparti\n:complexit\u00e9: :math:`O(n^4)`\n"}], "classes": []}}, {"EN": {"name": "our_queue", "description": "A FIFO queue\nchristoph d\u00fcrr - jill-j\u00eann vie - 2015-2019\n", "functions": [], "classes": [{"name": "OurQueue", "description": "A FIFO queue\n\n    Complexity:\n        all operators in amortized constant time,\n        except __str__ which is linear\n    ", "methods": [{"name": "__init__", "description": null}, {"name": "__len__", "description": null}, {"name": "__str__", "description": null}, {"name": "pop", "description": null}, {"name": "push", "description": null}]}]}, "FR": {"name": "our_queue", "description": "Une file d'attente FIFO\nchristoph d\u00fcrr - jill-j\u00eann vie - la p\u00e9riode 2015-2019\n", "functions": [], "classes": [{"name": "OurQueue", "description": "Une file d'attente FIFO\n\nComplexit\u00e9:\ntous les op\u00e9rateurs en temps constant amorti,\nsauf __str__, qui est lin\u00e9aire\n", "methods": [{"name": "__init__", "description": null}, {"name": "__len__", "description": null}, {"name": "__str__", "description": null}, {"name": "pop", "description": null}, {"name": "pousser", "description": null}]}]}}, {"EN": {"name": "lowest_common_ancestor", "description": "Lowest common ancestor\njill-jenn vie et christoph durr - 2014-2018\nhttp://leetcode.com/2011/11/longest-palindromic-substring-part-ii.html\n", "functions": [{"name": "log2ceil", "description": " log of n in base 2 rounded up ", "examples": [{"args": [{"name": "n", "value": "4", "type": "int"}], "return": {"value": "2", "type": "int"}}]}, {"name": "log2floor", "description": " log of n in base 2 rounded down ", "examples": [{"args": [{"name": "n", "value": "3", "type": "int"}], "return": {"value": "1", "type": "int"}}]}], "classes": [{"name": "LowestCommonAncestorRMQ", "description": "Lowest common ancestor data structure using a reduction to\n       range minimum query\n    ", "methods": [{"name": "__init__", "description": "builds the structure from a given tree\n\n        :param graph: adjacency matrix of a tree\n        :complexity: O(n log n), with n = len(graph)\n        "}, {"name": "query", "description": ":returns: the lowest common ancestor of u and v\n        :complexity: O(log n)\n        "}]}, {"name": "LowestCommonAncestorShortcuts", "description": "Lowest common ancestor data structure using shortcuts to ancestors\n    ", "methods": [{"name": "__init__", "description": "builds the structure from a given tree\n\n        :param prec: father for every node, with prec[0] = 0\n        :assumes: prec[node] < node\n        :complexity: O(n log n), with n = len(nodes)\n        "}, {"name": "query", "description": ":returns: the lowest common ancestor of u and v\n        :complexity: O(log n)\n        "}]}]}, "FR": {"name": "lowest_common_ancestor", "description": "Plus bas anc\u00eatre commun\njill-jenn vie et christoph durr - 2014-2018\nhttp://leetcode.com/2011/11/longest-palindromic-substring-part-ii.html\n", "functions": [{"name": "log2ceil", "description": " journal de n en base 2 arrondi "}, {"name": "log2floor", "description": " journal de n en base 2 arrondi \u00e0 l'inf\u00e9rieur "}], "classes": [{"name": "LowestCommonAncestorRMQ", "description": "Plus bas anc\u00eatre commun \u00e0 la structure de donn\u00e9es \u00e0 l'aide d'une r\u00e9duction de\nle minimum de la plage de la requ\u00eate\n", "methods": [{"name": "__init__", "description": "construit la structure d'un arbre\n\n:param graphique: matrice de contigu\u00eft\u00e9 d'un arbre\n:complexit\u00e9: O(n log n), avec n = len(graphique)\n"}, {"name": "requ\u00eate", "description": ":renvoie: le plus petit anc\u00eatre commun de u et v\n:complexit\u00e9: O(log n)\n"}]}, {"name": "LowestCommonAncestorShortcuts", "description": "Plus bas anc\u00eatre commun \u00e0 la structure de donn\u00e9es \u00e0 l'aide des raccourcis vers des anc\u00eatres\n", "methods": [{"name": "__init__", "description": "construit la structure d'un arbre\n\n:param prec: p\u00e8re, pour chaque n\u0153ud, avec prec[0] = 0\n:suppose: prec[n\u0153ud] < node\n:complexit\u00e9: O(n log n), avec n = len(n\u0153uds)\n"}, {"name": "requ\u00eate", "description": ":renvoie: le plus petit anc\u00eatre commun de u et v\n:complexit\u00e9: O(log n)\n"}]}]}}, {"EN": {"name": "roman_numbers", "description": "Evaluate an arithmetic expression\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "int2roman", "description": "Code roman number\n\n    :param val: integer between 1 and 9999\n    :returns: the corresponding roman number\n    :complexity: linear (if that makes sense for constant bounded input size)\n    ", "examples": [{"args": [{"name": "val", "value": "1", "type": "int"}], "return": {"value": "'I'", "type": "str"}}, {"args": [{"name": "val", "value": "2", "type": "int"}], "return": {"value": "'II'", "type": "str"}}, {"args": [{"name": "val", "value": "3", "type": "int"}], "return": {"value": "'III'", "type": "str"}}, {"args": [{"name": "val", "value": "4", "type": "int"}], "return": {"value": "'IV'", "type": "str"}}, {"args": [{"name": "val", "value": "5", "type": "int"}], "return": {"value": "'V'", "type": "str"}}, {"args": [{"name": "val", "value": "6", "type": "int"}], "return": {"value": "'VI'", "type": "str"}}, {"args": [{"name": "val", "value": "7", "type": "int"}], "return": {"value": "'VII'", "type": "str"}}, {"args": [{"name": "val", "value": "8", "type": "int"}], "return": {"value": "'VIII'", "type": "str"}}, {"args": [{"name": "val", "value": "9", "type": "int"}], "return": {"value": "'IX'", "type": "str"}}, {"args": [{"name": "val", "value": "10", "type": "int"}], "return": {"value": "'X'", "type": "str"}}]}, {"name": "roman2int", "description": "Decode roman number\n\n    :param s: string representing a roman number between 1 and 9999\n    :returns: the decoded roman number\n    :complexity: linear (if that makes sense for constant bounded input size)\n    ", "examples": [{"args": [{"name": "s", "value": "'I'", "type": "str"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "s", "value": "'II'", "type": "str"}], "return": {"value": "2", "type": "int"}}, {"args": [{"name": "s", "value": "'III'", "type": "str"}], "return": {"value": "3", "type": "int"}}, {"args": [{"name": "s", "value": "'IV'", "type": "str"}], "return": {"value": "4", "type": "int"}}, {"args": [{"name": "s", "value": "'V'", "type": "str"}], "return": {"value": "5", "type": "int"}}, {"args": [{"name": "s", "value": "'VI'", "type": "str"}], "return": {"value": "6", "type": "int"}}, {"args": [{"name": "s", "value": "'VII'", "type": "str"}], "return": {"value": "7", "type": "int"}}, {"args": [{"name": "s", "value": "'VIII'", "type": "str"}], "return": {"value": "8", "type": "int"}}, {"args": [{"name": "s", "value": "'IX'", "type": "str"}], "return": {"value": "9", "type": "int"}}, {"args": [{"name": "s", "value": "'X'", "type": "str"}], "return": {"value": "10", "type": "int"}}]}], "classes": []}, "FR": {"name": "roman_numbers", "description": "\u00c9valuer une expression arithm\u00e9tique\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "int2roman", "description": "Code chiffre romain\n\n:param val: entier compris entre 1 et 9999\n:r\u00e9sultat: le chiffre romain correspondant\n:complexit\u00e9: lin\u00e9aire (si cela fait sens pour constant d\u00e9limit\u00e9e \u00e0 l'entr\u00e9e de la taille)\n"}, {"name": "roman2int", "description": "D\u00e9coder chiffre romain\n\n:param s: cha\u00eene de caract\u00e8res repr\u00e9sentant un chiffre romain entre 1 et 9999\n:retourne: la d\u00e9cod\u00e9 chiffre romain\n:complexit\u00e9: lin\u00e9aire (si cela fait sens pour constant d\u00e9limit\u00e9e \u00e0 l'entr\u00e9e de la taille)\n"}], "classes": []}}, {"EN": {"name": "majority", "description": "Majority\njill-jenn vie et christoph durr - 2014-2019\n", "functions": [{"name": "majority", "description": "Majority\n\n    :param L: list of elements\n    :returns: element that appears most in L,\n             tie breaking with smallest element\n    :complexity: :math:`O(nk)` in average,\n                 where n = len(L) and k = max(w for w in L)\n                 :math:`O(n^2k)` in worst case due to the use of a dictionary\n    ", "examples": [{"args": [{"name": "L", "value": "['d', 'd', 'r', 'r', 'x', 'boo']", "type": "list"}], "return": {"value": "'d'", "type": "str"}}]}], "classes": []}, "FR": {"name": "la majorit\u00e9", "description": "La majorit\u00e9\njill-jenn vie et christoph durr - 2014-2019\n", "functions": [{"name": "la majorit\u00e9", "description": "La majorit\u00e9\n\n:param L: liste d'\u00e9l\u00e9ments\n:retourne: \u00e9l\u00e9ment qui appara\u00eet le plus dans L,\nbris d'\u00e9galit\u00e9 avec le plus petit \u00e9l\u00e9ment\n:complexit\u00e9: :math:`O(nk) en moyenne,\no\u00f9 n = len(L) et k = max(w pour w dans L)\n:math:`O(n^2k)` dans le pire des cas en raison de l'utilisation d'un dictionnaire\n"}], "classes": []}}, {"EN": {"name": "dijkstra", "description": "Shortest paths by Dijkstra\njill-j\u00eann vie et christoph d\u00fcrr - 2015-2018\n", "functions": [{"name": "dijkstra", "description": "single source shortest paths by Dijkstra\n\n       :param graph: directed graph in listlist or listdict format\n       :param weight: in matrix format or same listdict graph\n       :assumes: weights are non-negative\n       :param source: source vertex\n       :type source: int\n       :param target: if given, stops once distance to target found\n       :type target: int\n\n       :returns: distance table, precedence table\n       :complexity: `O(|V| + |E|log|V|)`\n    ", "examples": [{"args": [{"name": "graph", "value": "[{1: 1}, {2: 4}, {5: 3}, {6: 3}, {3: 1}, {4: 5, 8: 2}, {7: 6}, {4: 1}, {2: 2}]", "type": "list"}, {"name": "weight", "value": "[{1: 1}, {2: 4}, {5: 3}, {6: 3}, {3: 1}, {4: 5, 8: 2}, {7: 6}, {4: 1}, {2: 2}]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "8", "type": "int"}], "return": {"value": "([0, 1, 5, inf, 13, 8, inf, inf, 10], [None, 0, 1, None, 5, 2, None, None, 5])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[]]", "type": "list"}, {"name": "weight", "value": "[[None]]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "0", "type": "int"}], "return": {"value": "([0], [None])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[{}]", "type": "list"}, {"name": "weight", "value": "[{}]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "0", "type": "int"}], "return": {"value": "([0], [None])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[1], []]", "type": "list"}, {"name": "weight", "value": "[[None, 3], [None, None]]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "1", "type": "int"}], "return": {"value": "([0, 3], [None, 0])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[{1: 3}, {}]", "type": "list"}, {"name": "weight", "value": "[{1: 3}, {}]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "1", "type": "int"}], "return": {"value": "([0, 3], [None, 0])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[], []]", "type": "list"}, {"name": "weight", "value": "[[None, None], [None, None]]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "1", "type": "int"}], "return": {"value": "([0, inf], [None, None])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[{}, {}]", "type": "list"}, {"name": "weight", "value": "[{}, {}]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "1", "type": "int"}], "return": {"value": "([0, inf], [None, None])", "type": "tuple"}}]}, {"name": "dijkstra_update_heap", "description": "single source shortest paths by Dijkstra\n       with a heap implementing item updates\n\n       :param graph: adjacency list or adjacency dictionary of a directed graph\n       :param weight: matrix or adjacency dictionary\n       :assumes: weights are non-negatif and weights are infinite for non edges\n       :param source: source vertex\n       :type source: int\n       :param target: if given, stops once distance to target found\n       :type target: int\n       :returns: distance table, precedence table\n       :complexity: `O(|V| + |E|log|V|)`\n    ", "examples": [{"args": [{"name": "graph", "value": "[{1: 1}, {2: 4}, {5: 3}, {6: 3}, {3: 1}, {4: 5, 8: 2}, {7: 6}, {4: 1}, {2: 2}]", "type": "list"}, {"name": "weight", "value": "[{1: 1}, {2: 4}, {5: 3}, {6: 3}, {3: 1}, {4: 5, 8: 2}, {7: 6}, {4: 1}, {2: 2}]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "8", "type": "int"}], "return": {"value": "([0, 1, 5, inf, 13, 8, inf, inf, 10], [None, 0, 1, None, 5, 2, None, None, 5])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[]]", "type": "list"}, {"name": "weight", "value": "[[None]]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "0", "type": "int"}], "return": {"value": "([0], [None])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[{}]", "type": "list"}, {"name": "weight", "value": "[{}]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "0", "type": "int"}], "return": {"value": "([0], [None])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[1], []]", "type": "list"}, {"name": "weight", "value": "[[None, 3], [None, None]]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "1", "type": "int"}], "return": {"value": "([0, 3], [None, 0])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[{1: 3}, {}]", "type": "list"}, {"name": "weight", "value": "[{1: 3}, {}]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "1", "type": "int"}], "return": {"value": "([0, 3], [None, 0])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[], []]", "type": "list"}, {"name": "weight", "value": "[[None, None], [None, None]]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "1", "type": "int"}], "return": {"value": "([0, inf], [None, None])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[{}, {}]", "type": "list"}, {"name": "weight", "value": "[{}, {}]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "1", "type": "int"}], "return": {"value": "([0, inf], [None, None])", "type": "tuple"}}]}], "classes": []}, "FR": {"name": "dijkstra", "description": "Plus courts chemins par Dijkstra\njill-j\u00eann vie et christoph d\u00fcrr - 2015-2018\n", "functions": [{"name": "dijkstra", "description": "unique source de plus courts chemins par Dijkstra\n\n:param graphe: graphe orient\u00e9 dans listlist ou listdict format\n:param poids: dans un format de matrice ou m\u00eame listdict graphique\n:suppose: les poids sont non-n\u00e9gatives\n:param source: source: vertex\n:type de source: int\n:param cible: si elle est donn\u00e9e, s'arr\u00eate une fois la distance de la cible a\n:type de cible: int\n\n:retourne: distance de table, table de pr\u00e9c\u00e9dence\n:complexit\u00e9: O(|V| + |E|log|V|)`\n"}, {"name": "dijkstra_update_heap", "description": "unique source de plus courts chemins par Dijkstra\navec un tas de mettre en \u0153uvre les mises \u00e0 jour\n\n:param graphique: liste d'adjacence ou de contigu\u00eft\u00e9 dictionnaire d'un graphe orient\u00e9\n:param poids: matrice ou de contigu\u00eft\u00e9 dictionnaire\n:suppose: les poids sont non-negatif et le poids sont infinies pour non bords\n:param source: source: vertex\n:type de source: int\n:param cible: si elle est donn\u00e9e, s'arr\u00eate une fois la distance de la cible a\n:type de cible: int\n:retourne: distance de table, table de pr\u00e9c\u00e9dence\n:complexit\u00e9: O(|V| + |E|log|V|)`\n"}], "classes": []}}, {"EN": {"name": "ford_fulkerson", "description": "Maximum flow by Ford-Fulkerson\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "_augment", "description": "Find an augmenting path from u to target with value at most val", "examples": [{"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "flow", "value": "[[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]", "type": "list"}, {"name": "val", "value": "1", "type": "int"}, {"name": "u", "value": "5", "type": "int"}, {"name": "target", "value": "5", "type": "int"}, {"name": "visit", "value": "[True, True, False, True, False, False]", "type": "list"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "flow", "value": "[[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]", "type": "list"}, {"name": "val", "value": "1", "type": "int"}, {"name": "u", "value": "3", "type": "int"}, {"name": "target", "value": "5", "type": "int"}, {"name": "visit", "value": "[True, True, False, False, False, False]", "type": "list"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "flow", "value": "[[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]", "type": "list"}, {"name": "val", "value": "9", "type": "int"}, {"name": "u", "value": "1", "type": "int"}, {"name": "target", "value": "5", "type": "int"}, {"name": "visit", "value": "[True, False, False, False, False, False]", "type": "list"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "flow", "value": "[[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]", "type": "list"}, {"name": "val", "value": "inf", "type": "float"}, {"name": "u", "value": "0", "type": "int"}, {"name": "target", "value": "5", "type": "int"}, {"name": "visit", "value": "[False, False, False, False, False, False]", "type": "list"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "flow", "value": "[[0, 1, 0, 0, 0, 0], [-1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0], [0, -1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0], [0, 0, 0, -1, 0, 0]]", "type": "list"}, {"name": "val", "value": "8", "type": "int"}, {"name": "u", "value": "1", "type": "int"}, {"name": "target", "value": "5", "type": "int"}, {"name": "visit", "value": "[True, False, False, False, False, False]", "type": "list"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "flow", "value": "[[0, 1, 0, 0, 0, 0], [-1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0], [0, -1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0], [0, 0, 0, -1, 0, 0]]", "type": "list"}, {"name": "val", "value": "1", "type": "int"}, {"name": "u", "value": "5", "type": "int"}, {"name": "target", "value": "5", "type": "int"}, {"name": "visit", "value": "[True, True, True, False, True, False]", "type": "list"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "flow", "value": "[[0, 1, 0, 0, 0, 0], [-1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0], [0, -1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0], [0, 0, 0, -1, 0, 0]]", "type": "list"}, {"name": "val", "value": "1", "type": "int"}, {"name": "u", "value": "4", "type": "int"}, {"name": "target", "value": "5", "type": "int"}, {"name": "visit", "value": "[True, True, True, False, False, False]", "type": "list"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "flow", "value": "[[0, 1, 0, 0, 0, 0], [-1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0], [0, -1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0], [0, 0, 0, -1, 0, 0]]", "type": "list"}, {"name": "val", "value": "9", "type": "int"}, {"name": "u", "value": "2", "type": "int"}, {"name": "target", "value": "5", "type": "int"}, {"name": "visit", "value": "[True, True, False, False, False, False]", "type": "list"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "flow", "value": "[[0, 1, 0, 0, 0, 0], [-1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0], [0, -1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0], [0, 0, 0, -1, 0, 0]]", "type": "list"}, {"name": "val", "value": "inf", "type": "float"}, {"name": "u", "value": "0", "type": "int"}, {"name": "target", "value": "5", "type": "int"}, {"name": "visit", "value": "[False, False, False, False, False, False]", "type": "list"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "flow", "value": "[[0, 1, 1, 0, 0, 0], [-1, 0, 0, 1, 0, 0], [-1, 0, 0, 0, 1, 0], [0, -1, 0, 0, 0, 1], [0, 0, -1, 0, 0, 1], [0, 0, 0, -1, -1, 0]]", "type": "list"}, {"name": "val", "value": "8", "type": "int"}, {"name": "u", "value": "1", "type": "int"}, {"name": "target", "value": "5", "type": "int"}, {"name": "visit", "value": "[True, False, False, False, False, False]", "type": "list"}], "return": {"value": "0", "type": "int"}}]}, {"name": "ford_fulkerson", "description": "Maximum flow by Ford-Fulkerson\n\n    :param graph: directed graph in listlist or listdict format\n    :param capacity: in matrix format or same listdict graph\n    :param int s: source vertex\n    :param int t: target vertex\n\n    :returns: flow matrix, flow value\n    :complexity: `O(|V|*|E|*max_capacity)`\n    ", "examples": [{"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "s", "value": "0", "type": "int"}, {"name": "t", "value": "5", "type": "int"}], "return": {"value": "([[0, 1, 1, 0, 0, 0], [-1, 0, 0, 1, 0, 0], [-1, 0, 0, 0, 1, 0], [0, -1, 0, 0, 0, 1], [0, 0, -1, 0, 0, 1], [0, 0, 0, -1, -1, 0]], 2)", "type": "tuple"}}]}], "classes": []}, "FR": {"name": "ford_fulkerson", "description": "D\u00e9bit maximal de Ford-Fulkerson\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "_augment", "description": "Trouver une augmentation de chemin de u \u00e0 la cible avec une valeur au plus val"}, {"name": "ford_fulkerson", "description": "D\u00e9bit maximal de Ford-Fulkerson\n\n:param graphe: graphe orient\u00e9 dans listlist ou listdict format\n:param capacit\u00e9: dans un format de matrice ou m\u00eame listdict graphique\n:param int s: source: vertex\n:param int t: cible vertex\n\n:retourne: matrice de flux, le flux de valeur\n:complexit\u00e9: O(|V|*|E|*max_capacity)`\n"}], "classes": []}}, {"EN": {"name": "fast_exponentiation", "description": "Fast Exponentiation\njill-jenn vie et christoph durr and louis abraham - 2014-2018\n", "functions": [{"name": "fast_exponentiation", "description": "Compute (a pow b) % q, alternative shorter implementation\n\n    :param int a b: non negative\n    :param int q: positive\n    :complexity: O(log b)\n    ", "examples": [{"args": [{"name": "a", "value": "1", "type": "int"}, {"name": "b", "value": "23", "type": "int"}, {"name": "q", "value": "1000", "type": "int"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "a", "value": "23", "type": "int"}, {"name": "b", "value": "1", "type": "int"}, {"name": "q", "value": "1000", "type": "int"}], "return": {"value": "23", "type": "int"}}, {"args": [{"name": "a", "value": "23", "type": "int"}, {"name": "b", "value": "2", "type": "int"}, {"name": "q", "value": "1000", "type": "int"}], "return": {"value": "529", "type": "int"}}, {"args": [{"name": "a", "value": "23", "type": "int"}, {"name": "b", "value": "0", "type": "int"}, {"name": "q", "value": "1000", "type": "int"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "a", "value": "7", "type": "int"}, {"name": "b", "value": "23", "type": "int"}, {"name": "q", "value": "1000000000", "type": "int"}], "return": {"value": "80916343", "type": "int"}}, {"args": [{"name": "a", "value": "7", "type": "int"}, {"name": "b", "value": "2323474", "type": "int"}, {"name": "q", "value": "1000000000", "type": "int"}], "return": {"value": "428796849", "type": "int"}}]}, {"name": "fast_exponentiation2", "description": "Compute (a pow b) % q\n\n    :param int a b: non negative\n    :param int q: positive\n    :complexity: O(log b)\n    ", "examples": [{"args": [{"name": "a", "value": "1", "type": "int"}, {"name": "b", "value": "23", "type": "int"}, {"name": "q", "value": "1000", "type": "int"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "a", "value": "23", "type": "int"}, {"name": "b", "value": "1", "type": "int"}, {"name": "q", "value": "1000", "type": "int"}], "return": {"value": "23", "type": "int"}}, {"args": [{"name": "a", "value": "23", "type": "int"}, {"name": "b", "value": "2", "type": "int"}, {"name": "q", "value": "1000", "type": "int"}], "return": {"value": "529", "type": "int"}}, {"args": [{"name": "a", "value": "23", "type": "int"}, {"name": "b", "value": "0", "type": "int"}, {"name": "q", "value": "1000", "type": "int"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "a", "value": "7", "type": "int"}, {"name": "b", "value": "23", "type": "int"}, {"name": "q", "value": "1000000000", "type": "int"}], "return": {"value": "80916343", "type": "int"}}, {"args": [{"name": "a", "value": "7", "type": "int"}, {"name": "b", "value": "2323474", "type": "int"}, {"name": "q", "value": "1000000000", "type": "int"}], "return": {"value": "428796849", "type": "int"}}]}], "classes": []}, "FR": {"name": "fast_exponentiation", "description": "L'Exponentiation Rapide\njill-jenn vie et christoph durr et louis abraham - 2014-2018\n", "functions": [{"name": "fast_exponentiation", "description": "Calculer (un pow-b) % q, alternative plus courte de la mise en \u0153uvre\n\n:param int b: non n\u00e9gatif\n:param int q: positif\n:complexit\u00e9: O(log b)\n"}, {"name": "fast_exponentiation2", "description": "Calculer (un pow-b) % q\n\n:param int b: non n\u00e9gatif\n:param int q: positif\n:complexit\u00e9: O(log b)\n"}], "classes": []}}, {"EN": {"name": "intervals_union", "description": "Union of intervals\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "intervals_union", "description": "Union of intervals\n\n    :param S: list of pairs (low, high) defining intervals [low, high)\n    :returns: ordered list of disjoint intervals with the same union as S\n    :complexity: O(n log n)\n    ", "examples": [{"args": [{"name": "S", "value": "[(2, 3), (4, 6), (1, 5), (6, 7), (8, 10)]", "type": "list"}], "return": {"value": "[(1, 7), (8, 10)]", "type": "list"}}, {"args": [{"name": "S", "value": "[]", "type": "list"}], "return": {"value": "[]", "type": "list"}}, {"args": [{"name": "S", "value": "[(0, 1)]", "type": "list"}], "return": {"value": "[(0, 1)]", "type": "list"}}, {"args": [{"name": "S", "value": "[(1, 2), (0, 1)]", "type": "list"}], "return": {"value": "[(0, 2)]", "type": "list"}}, {"args": [{"name": "S", "value": "[(2, 3), (0, 1)]", "type": "list"}], "return": {"value": "[(0, 1), (2, 3)]", "type": "list"}}]}], "classes": []}, "FR": {"name": "intervals_union", "description": "Union d'intervalles\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "intervals_union", "description": "Union d'intervalles\n\n:param S: liste de paires (bas, haut) d\u00e9finition des intervalles [low, high)\n:retourne: liste ordonn\u00e9e des intervalles disjoints avec la m\u00eame union que S\n:complexit\u00e9: O(n log n)\n"}], "classes": []}}, {"EN": {"name": "shortest_cycle", "description": "christoph durr, finn voelkel and louis abraham - 2016-2019\n\nFind shortest simple cycle\nO(V*E)\nfootnote (1) here you can add parity check of cycle_len\nif only even cycles are requested\n", "functions": [{"name": "bfs", "description": "make a pruned BFS search of the graph starting at root.\n    returns the BFS tree, and possibly a traversal edge (u,v)\n    that with the tree forms a cycle of some length.\n\n    :param graph: undirected graph in listlist or listdict format\n    :param root:  vertex where BFS exploration starts\n    :param prune_level: exploration is done only up to\n    the prune_level (included)\n    :complexity: O(V + E)\n    ", "examples": [{"args": [{"name": "graph", "value": "[[1, 2], [0, 2], [0, 1, 3], [2]]", "type": "list"}, {"name": "root", "value": "0", "type": "int"}, {"name": "prune_level", "value": "nan", "type": "float"}], "return": {"value": "([0, 0, 0, None], 3, 1, 2)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[1, 2], [0, 2], [0, 1, 3], [2]]", "type": "list"}, {"name": "root", "value": "1", "type": "int"}, {"name": "prune_level", "value": "1", "type": "int"}], "return": {"value": "([1, 1, 1, None], 3, 0, 2)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[1, 2], [0, 2], [0, 1, 3], [2]]", "type": "list"}, {"name": "root", "value": "2", "type": "int"}, {"name": "prune_level", "value": "1", "type": "int"}], "return": {"value": "([2, 2, 2, 2], 3, 0, 1)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[1, 2], [0, 2], [0, 1, 3], [2]]", "type": "list"}, {"name": "root", "value": "3", "type": "int"}, {"name": "prune_level", "value": "1", "type": "int"}], "return": {"value": "([2, 2, 3, 3], inf, None, None)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[2], [2], [0, 1, 3], [2]]", "type": "list"}, {"name": "root", "value": "0", "type": "int"}, {"name": "prune_level", "value": "nan", "type": "float"}], "return": {"value": "([0, 2, 0, 2], inf, None, None)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[2], [2], [0, 1, 3], [2]]", "type": "list"}, {"name": "root", "value": "1", "type": "int"}, {"name": "prune_level", "value": "nan", "type": "float"}], "return": {"value": "([2, 1, 1, 2], inf, None, None)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[2], [2], [0, 1, 3], [2]]", "type": "list"}, {"name": "root", "value": "2", "type": "int"}, {"name": "prune_level", "value": "nan", "type": "float"}], "return": {"value": "([2, 2, 2, 2], inf, None, None)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[2], [2], [0, 1, 3], [2]]", "type": "list"}, {"name": "root", "value": "3", "type": "int"}, {"name": "prune_level", "value": "nan", "type": "float"}], "return": {"value": "([2, 2, 3, 3], inf, None, None)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[9], [5], [4], [4], [5, 3, 2], [4, 1, 6], [5], [], [], [0]]", "type": "list"}, {"name": "root", "value": "0", "type": "int"}, {"name": "prune_level", "value": "nan", "type": "float"}], "return": {"value": "([0, None, None, None, None, None, None, None, None, 0], inf, None, None)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[9], [5], [4], [4], [5, 3, 2], [4, 1, 6], [5], [], [], [0]]", "type": "list"}, {"name": "root", "value": "1", "type": "int"}, {"name": "prune_level", "value": "nan", "type": "float"}], "return": {"value": "([None, 1, 4, 4, 5, 1, 5, None, None, None], inf, None, None)", "type": "tuple"}}]}, {"name": "path", "description": "returns the path in the tree from v to the root\n    Complexity: O(V)\n    ", "examples": [{"args": [{"name": "tree", "value": "[0, 0, 0, None]", "type": "list"}, {"name": "v", "value": "1", "type": "int"}], "return": {"value": "[1, 0]", "type": "list"}}, {"args": [{"name": "tree", "value": "[0, 0, 0, None]", "type": "list"}, {"name": "v", "value": "2", "type": "int"}], "return": {"value": "[2, 0]", "type": "list"}}, {"args": [{"name": "tree", "value": "[None, 1, None, None, 1, 1, None, None, 1, None]", "type": "list"}, {"name": "v", "value": "4", "type": "int"}], "return": {"value": "[4, 1]", "type": "list"}}, {"args": [{"name": "tree", "value": "[None, 1, None, None, 1, 1, None, None, 1, None]", "type": "list"}, {"name": "v", "value": "8", "type": "int"}], "return": {"value": "[8, 1]", "type": "list"}}, {"args": [{"name": "tree", "value": "[0, 0, None, 0, None, None, None, None, None, None]", "type": "list"}, {"name": "v", "value": "1", "type": "int"}], "return": {"value": "[1, 0]", "type": "list"}}, {"args": [{"name": "tree", "value": "[0, 0, None, 0, None, None, None, None, None, None]", "type": "list"}, {"name": "v", "value": "3", "type": "int"}], "return": {"value": "[3, 0]", "type": "list"}}, {"args": [{"name": "tree", "value": "[0, 0, None, 0, None, None, 0, None, 0, None]", "type": "list"}, {"name": "v", "value": "6", "type": "int"}], "return": {"value": "[6, 0]", "type": "list"}}, {"args": [{"name": "tree", "value": "[0, 0, None, 0, None, None, 0, None, 0, None]", "type": "list"}, {"name": "v", "value": "1", "type": "int"}], "return": {"value": "[1, 0]", "type": "list"}}, {"args": [{"name": "tree", "value": "[0, 0, None, 0, None, 0, None, None, None, None]", "type": "list"}, {"name": "v", "value": "3", "type": "int"}], "return": {"value": "[3, 0]", "type": "list"}}, {"args": [{"name": "tree", "value": "[0, 0, None, 0, None, 0, None, None, None, None]", "type": "list"}, {"name": "v", "value": "5", "type": "int"}], "return": {"value": "[5, 0]", "type": "list"}}]}, {"name": "powergraph", "description": "Compute the k-th\n       `powergraph <https://en.wikipedia.org/wiki/Graph_power>`_\n       which has an edge u,v for every vertex pair\n       of distance at most k in the given graph.\n\n    :param graph: undirected graph in listlist or listdict format\n    :param k: non-negative integer.\n    :complexity: O(V^3)\n    ", "examples": [{"args": [{"name": "graph", "value": "[[0], [1]]", "type": "list"}, {"name": "k", "value": "1", "type": "int"}], "return": {"value": "[[0], [1]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[0], [1]]", "type": "list"}, {"name": "k", "value": "2", "type": "int"}], "return": {"value": "[[0], [1]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[0], [1]]", "type": "list"}, {"name": "k", "value": "3", "type": "int"}], "return": {"value": "[[0], [1]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[0, 1, 3], [0, 1, 2, 3], [1, 2, 4], [0, 1, 3], [2, 4]]", "type": "list"}, {"name": "k", "value": "0", "type": "int"}], "return": {"value": "[[0], [1], [2], [3], [4]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[0, 1, 3], [0, 1, 2, 3], [1, 2, 4], [0, 1, 3], [2, 4]]", "type": "list"}, {"name": "k", "value": "1", "type": "int"}], "return": {"value": "[[0, 1, 3], [0, 1, 2, 3], [1, 2, 4], [0, 1, 3], [2, 4]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[0, 1, 3], [0, 1, 2, 3], [1, 2, 4], [0, 1, 3], [2, 4]]", "type": "list"}, {"name": "k", "value": "2", "type": "int"}], "return": {"value": "[[0, 1, 2, 3], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3], [1, 2, 4]]", "type": "list"}}]}, {"name": "readint", "description": null}, {"name": "readints", "description": null}, {"name": "readstr", "description": null}, {"name": "shortest_cycle", "description": " Finding a shortest cycle in an undirected unweighted graph\n\n    :param graph: undirected graph in listlist or listdict format\n    :returns: None or a list C describing a shortest cycle\n    :complexity: `O(|V|*|E|)`\n    ", "examples": [{"args": [{"name": "graph", "value": "[[1, 2], [0, 2], [0, 1, 3], [2]]", "type": "list"}], "return": {"value": "[1, 2, 0]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[2], [2], [0, 1, 3], [2]]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[9], [5], [4], [4], [5, 3, 2], [4, 1, 6], [5], [], [], [0]]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[6], [5, 4, 8], [], [], [1, 8], [1], [0], [], [1, 4], []]", "type": "list"}], "return": {"value": "[4, 8, 1]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[2, 1], [0, 6], [0], [], [7], [6, 7], [5, 1], [5, 4], [], []]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[9, 2], [4], [0, 8], [4], [8, 3, 1], [], [], [], [4, 2], [0]]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[3, 2, 1], [8, 0], [0], [0], [5], [4], [], [], [1], []]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[1, 5], [0, 2], [1], [9], [], [0], [], [9], [], [3, 7]]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[1, 3], [0, 3], [], [1, 0], [5, 9], [6, 4], [5], [], [], [4]]", "type": "list"}], "return": {"value": "[1, 3, 0]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1, 2, 6, 4], [0], [0], [8], [0], [], [0], [], [3], []]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}]}], "classes": []}, "FR": {"name": "shortest_cycle", "description": "christoph durr, finn voelkel et louis abraham - 2016-2019\n\nTrouver le plus court cycle simple\nO(V*E)\nnote de bas de page (1) ici, vous pouvez ajouter un contr\u00f4le de parit\u00e9 de cycle_len\nsi seulement, m\u00eame les cycles sont demand\u00e9s\n", "functions": [{"name": "bfs", "description": "faire un taill\u00e9s BFS recherche du graphe de d\u00e9part \u00e0 la racine.\nrenvoie la SECTION de l'arbre, et, \u00e9ventuellement, une travers\u00e9e de l'ar\u00eate (u,v)\nqu'avec l'arbre forme un cycle d'une certaine longueur.\n\n:param graphe: graphe non-dirig\u00e9 dans listlist ou listdict format\n:param racine: sommet o\u00f9 BFS l'exploration commence\n:param prune_level: l'exploration est le fait que jusqu'\u00e0\nle prune_level (inclus)\n:complexit\u00e9: O(V + E)\n"}, {"name": "chemin", "description": "retourne le chemin d'acc\u00e8s dans l'arborescence de v \u00e0 la racine\nComplexit\u00e9: O(V)\n"}, {"name": "powergraph", "description": "Calculer la k-i\u00e8me\n`powergraph <https://en.wikipedia.org/wiki/Graph_power>`_\nqui a un bord u,v pour chaque vertex paire\nde distance au plus k dans le graphe.\n\n:param graphe: graphe non-dirig\u00e9 dans listlist ou listdict format\n:param k: entier non n\u00e9gatif.\n:complexit\u00e9: O(V^3)\n"}, {"name": "readint", "description": null}, {"name": "readints", "description": null}, {"name": "readstr", "description": null}, {"name": "shortest_cycle", "description": " Trouver un cycle le plus court dans un non orient\u00e9 non pond\u00e9r\u00e9 graphique\n\n:param graphe: graphe non-dirig\u00e9 dans listlist ou listdict format\n:r\u00e9sultat: Aucune ou une liste C d\u00e9crivant un cycle le plus court\n:complexit\u00e9: O(|V|*|E|)`\n"}], "classes": []}}, {"EN": {"name": "interval_cover", "description": "Minimum interval cover\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2018\n", "functions": [{"name": "_readarray", "description": null}, {"name": "_solve", "description": null}, {"name": "interval_cover", "description": "Minimum interval cover\n\n    :param I: list of closed intervals\n    :returns: minimum list of points covering all intervals\n    :complexity: O(n log n)\n    ", "examples": [{"args": [{"name": "I", "value": "[(0, 1)]", "type": "list"}], "return": {"value": "[1]", "type": "list"}}, {"args": [{"name": "I", "value": "[(0, 3), (1, 2)]", "type": "list"}], "return": {"value": "[2]", "type": "list"}}, {"args": [{"name": "I", "value": "[(0, 2), (1, 3)]", "type": "list"}], "return": {"value": "[2]", "type": "list"}}, {"args": [{"name": "I", "value": "[(0, 2), (2, 3)]", "type": "list"}], "return": {"value": "[2]", "type": "list"}}, {"args": [{"name": "I", "value": "[(0, 2), (3, 4)]", "type": "list"}], "return": {"value": "[2, 4]", "type": "list"}}, {"args": [{"name": "I", "value": "[(0, 4), (1, 3), (2, 6), (5, 8), (7, 9), (9, 10)]", "type": "list"}], "return": {"value": "[3, 8, 10]", "type": "list"}}]}], "classes": []}, "FR": {"name": "interval_cover", "description": "Intervalle Minimum de couverture\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2018\n", "functions": [{"name": "_readarray", "description": null}, {"name": "_solve", "description": null}, {"name": "interval_cover", "description": "Intervalle Minimum de couverture\n\n:param I: liste des intervalles ferm\u00e9s\n:retourne: liste minimale de points couvrant tous les intervalles\n:complexit\u00e9: O(n log n)\n"}], "classes": []}}, {"EN": {"name": "graph01", "description": "Shortest path in a 0,1 weighted graph\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "dist01", "description": "Shortest path in a 0,1 weighted graph\n\n    :param graph: directed graph in listlist or listdict format\n    :param weight: matrix or adjacency dictionary\n    :param int source: vertex\n    :param target: exploration stops once distance to target is found\n    :returns: distance table, predecessor table\n    :complexity: `O(|V|+|E|)`\n    ", "examples": [{"args": [{"name": "graph", "value": "[{1: 0, 3: 0}, {0: 0, 1: 0, 2: 1}, {1: 1, 5: 1}, {0: 0, 4: 1, 6: 0}, {3: 1, 5: 1, 7: 0}, {2: 1, 4: 1, 8: 0}, {3: 0, 7: 0}, {4: 0, 6: 0}, {5: 0}]", "type": "list"}, {"name": "weight", "value": "[{1: 0, 3: 0}, {0: 0, 1: 0, 2: 1}, {1: 1, 5: 1}, {0: 0, 4: 1, 6: 0}, {3: 1, 5: 1, 7: 0}, {2: 1, 4: 1, 8: 0}, {3: 0, 7: 0}, {4: 0, 6: 0}, {5: 0}]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "8", "type": "int"}], "return": {"value": "([0, 0, 1, 0, 0, 1, 0, 0, 1], [None, 0, 1, 0, 7, 4, 3, 6, 5])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[]]", "type": "list"}, {"name": "weight", "value": "[[None]]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "0", "type": "int"}], "return": {"value": "([0], [None])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[{}]", "type": "list"}, {"name": "weight", "value": "[{}]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "0", "type": "int"}], "return": {"value": "([0], [None])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[1], []]", "type": "list"}, {"name": "weight", "value": "[[None, 1], [None, None]]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "1", "type": "int"}], "return": {"value": "([0, 1], [None, 0])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[{1: 1}, {}]", "type": "list"}, {"name": "weight", "value": "[{1: 1}, {}]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "1", "type": "int"}], "return": {"value": "([0, 1], [None, 0])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[], []]", "type": "list"}, {"name": "weight", "value": "[[None, None], [None, None]]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "1", "type": "int"}], "return": {"value": "([0, inf], [None, None])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[{}, {}]", "type": "list"}, {"name": "weight", "value": "[{}, {}]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "1", "type": "int"}], "return": {"value": "([0, inf], [None, None])", "type": "tuple"}}]}], "classes": []}, "FR": {"name": "graph01", "description": "Plus court chemin dans un 0,1 pond\u00e9r\u00e9e graphique\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "dist01", "description": "Plus court chemin dans un 0,1 pond\u00e9r\u00e9e graphique\n\n:param graphe: graphe orient\u00e9 dans listlist ou listdict format\n:param poids: matrice ou de contigu\u00eft\u00e9 dictionnaire\n:param int source: sommet\n:param cible: l'exploration s'arr\u00eate une fois la distance de la cible est trouv\u00e9e\n:retourne: distance de la table, pr\u00e9d\u00e9cesseur de table\n:complexit\u00e9: O(|V|+|E|)`\n"}], "classes": []}}, {"EN": {"name": "primes", "description": "Prime numbers by Eratosthene\nnombre premiers <n\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "eratosthene", "description": "Prime numbers by sieve of Eratosthene\n\n    :param n: positive integer\n    :assumes: n > 2\n    :returns: list of prime numbers <n\n    :complexity: O(n loglog n)\n    ", "examples": [{"args": [{"name": "n", "value": "98", "type": "int"}], "return": {"value": "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]", "type": "list"}}, {"args": [{"name": "n", "value": "3", "type": "int"}], "return": {"value": "[2]", "type": "list"}}, {"args": [{"name": "n", "value": "4", "type": "int"}], "return": {"value": "[2, 3]", "type": "list"}}, {"args": [{"name": "n", "value": "5", "type": "int"}], "return": {"value": "[2, 3]", "type": "list"}}, {"args": [{"name": "n", "value": "6", "type": "int"}], "return": {"value": "[2, 3, 5]", "type": "list"}}, {"args": [{"name": "n", "value": "7", "type": "int"}], "return": {"value": "[2, 3, 5]", "type": "list"}}, {"args": [{"name": "n", "value": "8", "type": "int"}], "return": {"value": "[2, 3, 5, 7]", "type": "list"}}, {"args": [{"name": "n", "value": "9", "type": "int"}], "return": {"value": "[2, 3, 5, 7]", "type": "list"}}, {"args": [{"name": "n", "value": "10", "type": "int"}], "return": {"value": "[2, 3, 5, 7]", "type": "list"}}, {"args": [{"name": "n", "value": "11", "type": "int"}], "return": {"value": "[2, 3, 5, 7]", "type": "list"}}]}, {"name": "gries_misra", "description": "Prime numbers by the sieve of Gries-Misra\n    Computes both the list of all prime numbers less than n,\n    and a table mapping every integer 2 \u2264 x < n to its smallest prime factor\n\n    :param n: positive integer\n    :returns: list of prime numbers, and list of prime factors\n    :complexity: O(n)\n    ", "examples": [{"args": [{"name": "n", "value": "3", "type": "int"}], "return": {"value": "([2], [0, 0, 2])", "type": "tuple"}}, {"args": [{"name": "n", "value": "4", "type": "int"}], "return": {"value": "([2, 3], [0, 0, 2, 3])", "type": "tuple"}}, {"args": [{"name": "n", "value": "5", "type": "int"}], "return": {"value": "([2, 3], [0, 0, 2, 3, 2])", "type": "tuple"}}, {"args": [{"name": "n", "value": "6", "type": "int"}], "return": {"value": "([2, 3, 5], [0, 0, 2, 3, 2, 5])", "type": "tuple"}}, {"args": [{"name": "n", "value": "7", "type": "int"}], "return": {"value": "([2, 3, 5], [0, 0, 2, 3, 2, 5, 2])", "type": "tuple"}}, {"args": [{"name": "n", "value": "8", "type": "int"}], "return": {"value": "([2, 3, 5, 7], [0, 0, 2, 3, 2, 5, 2, 7])", "type": "tuple"}}, {"args": [{"name": "n", "value": "9", "type": "int"}], "return": {"value": "([2, 3, 5, 7], [0, 0, 2, 3, 2, 5, 2, 7, 2])", "type": "tuple"}}, {"args": [{"name": "n", "value": "10", "type": "int"}], "return": {"value": "([2, 3, 5, 7], [0, 0, 2, 3, 2, 5, 2, 7, 2, 3])", "type": "tuple"}}, {"args": [{"name": "n", "value": "11", "type": "int"}], "return": {"value": "([2, 3, 5, 7], [0, 0, 2, 3, 2, 5, 2, 7, 2, 3, 2])", "type": "tuple"}}, {"args": [{"name": "n", "value": "12", "type": "int"}], "return": {"value": "([2, 3, 5, 7, 11], [0, 0, 2, 3, 2, 5, 2, 7, 2, 3, 2, 11])", "type": "tuple"}}]}], "classes": []}, "FR": {"name": "les nombres premiers", "description": "Nombres premiers par Eratosthene\nnombre des premiers ministres de l' <n\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "eratosthene", "description": "Le premier nombre par le crible d'Eratosthene\n\n:param n: entier positif\n:suppose: n > 2\n:renvoie la liste des nombres premiers <n\n:complexit\u00e9: O(n loglog n)\n"}, {"name": "gries_misra", "description": "Le premier nombre par le tamis de Gries-Misra\nCalcule \u00e0 la fois la liste de tous les nombres premiers inf\u00e9rieurs \u00e0 n,\net une table de mappage de chaque nombre entier 2 \u2264 x < n \u00e0 son plus petit facteur premier\n\n:param n: entier positif\n:renvoie la liste des nombres premiers, et la liste des facteurs premiers\n:complexit\u00e9: O(n)\n"}], "classes": []}}, {"EN": {"name": "binary_search", "description": "Binary search\njill-j\u00eann vie, christoph d\u00fcrr et louis abraham - 2014-2019\n", "functions": [{"name": "_readarray", "description": null}, {"name": "_readint", "description": null}, {"name": "continuous_binary_search", "description": "Binary search for a function\n\n    :param f: boolean monotone function with f(hi) = True\n    :param int lo:\n    :param int hi: with hi >= lo\n    :param float gap:\n    :returns: first value x in [lo,hi] such that f(x),\n             x is computed up to some precision\n    :complexity: `O(log((hi-lo)/gap))`\n    ", "examples": [{"args": [{"name": "f", "value": "<function TestTryalgo.test_binary_search.<locals>.f at 0x7efdb0671598>", "type": "function"}, {"name": "lo", "value": "0", "type": "int"}, {"name": "hi", "value": "524288", "type": "int"}, {"name": "gap", "value": "0.0001", "type": "float"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "f", "value": "<function TestTryalgo.test_binary_search.<locals>.f at 0x7efdb0671400>", "type": "function"}, {"name": "lo", "value": "0", "type": "int"}, {"name": "hi", "value": "524288", "type": "int"}, {"name": "gap", "value": "0.0001", "type": "float"}], "return": {"value": "0.99993896484375", "type": "float"}}, {"args": [{"name": "f", "value": "<function TestTryalgo.test_binary_search.<locals>.f at 0x7efdb0671598>", "type": "function"}, {"name": "lo", "value": "0", "type": "int"}, {"name": "hi", "value": "524288", "type": "int"}, {"name": "gap", "value": "0.0001", "type": "float"}], "return": {"value": "262142.99993896484", "type": "float"}}, {"args": [{"name": "f", "value": "<function TestTryalgo.test_binary_search.<locals>.f at 0x7efdb0671400>", "type": "function"}, {"name": "lo", "value": "0", "type": "int"}, {"name": "hi", "value": "524288", "type": "int"}, {"name": "gap", "value": "0.0001", "type": "float"}], "return": {"value": "262143.99993896484", "type": "float"}}, {"args": [{"name": "f", "value": "<function TestTryalgo.test_binary_search.<locals>.f at 0x7efdb0671598>", "type": "function"}, {"name": "lo", "value": "0", "type": "int"}, {"name": "hi", "value": "524288", "type": "int"}, {"name": "gap", "value": "0.0001", "type": "float"}], "return": {"value": "262144.99993896484", "type": "float"}}, {"args": [{"name": "f", "value": "<function TestTryalgo.test_binary_search.<locals>.f at 0x7efdb0671400>", "type": "function"}, {"name": "lo", "value": "0", "type": "int"}, {"name": "hi", "value": "524288", "type": "int"}, {"name": "gap", "value": "0.0001", "type": "float"}], "return": {"value": "524286.99993896484", "type": "float"}}]}, {"name": "discrete_binary_search", "description": "Binary search in a table\n\n    :param tab: boolean monotone table with tab[hi] = True\n    :param int lo:\n    :param int hi: with hi >= lo\n    :returns: first index i in [lo,hi] such that tab[i]\n    :complexity: `O(log(hi-lo))`\n    ", "examples": []}, {"name": "optimized_binary_search", "description": "Binary search in a table using bit operations\n\n    :param tab: boolean monotone table\n       of size :math:`2^\\textrm{logsize}`\n       with tab[hi] = True\n    :param int logsize:\n    :returns: first i such that tab[i]\n    :complexity: O(logsize)\n    ", "examples": []}, {"name": "optimized_binary_search_lower", "description": "Binary search in a table using bit operations\n\n    :param tab: boolean monotone table\n       of size :math:`2^\\textrm{logsize}`\n       with tab[0] = False\n    :param int logsize:\n    :returns: last i such that not tab[i]\n    :complexity: O(logsize)\n    "}, {"name": "ternary_search", "description": "Ternary maximum search for a bitonic function\n\n    :param f: boolean bitonic function (increasing then decreasing,\n    not necessarily strictly)\n    :param int lo:\n    :param int hi: with hi >= lo\n    :param float gap:\n    :returns: value x in [lo,hi] maximizing f(x),\n             x is computed up to some precision\n    :complexity: `O(log((hi-lo)/gap))`\n    ", "examples": [{"args": [{"name": "f", "value": "<function TestTryalgo.test_ternary_search.<locals>.<lambda> at 0x7efdaff62ea0>", "type": "function"}, {"name": "lo", "value": "0", "type": "int"}, {"name": "hi", "value": "4", "type": "int"}, {"name": "gap", "value": "1e-10", "type": "float"}], "return": {"value": "1.9999999652823495", "type": "float"}}, {"args": [{"name": "f", "value": "<function TestTryalgo.test_ternary_search.<locals>.<lambda> at 0x7efdaff62ea0>", "type": "function"}, {"name": "lo", "value": "0", "type": "int"}, {"name": "hi", "value": "4", "type": "int"}, {"name": "gap", "value": "1e-10", "type": "float"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "f", "value": "<function TestTryalgo.test_ternary_search.<locals>.<lambda> at 0x7efdaff62ea0>", "type": "function"}, {"name": "lo", "value": "0", "type": "int"}, {"name": "hi", "value": "4", "type": "int"}, {"name": "gap", "value": "1e-10", "type": "float"}], "return": {"value": "3.999999999927474", "type": "float"}}]}], "classes": []}, "FR": {"name": "binary_search", "description": "Recherche binaire\njill-j\u00eann vie, christoph d\u00fcrr et louis abraham - 2014-2019\n", "functions": [{"name": "_readarray", "description": null}, {"name": "_readint", "description": null}, {"name": "continuous_binary_search", "description": "Recherche binaire pour une fonction\n\n:param f: boolean la monotonie de la fonction f(hi) = Vrai\n:param int lo:\n:param int hi: hi >= lo\n:param float \u00e9cart:\n:renvoie: la premi\u00e8re valeur de x dans [lo,hi] tel que f(x),\nx est calcul\u00e9e jusqu'\u00e0 un certain degr\u00e9 de pr\u00e9cision\n:complexit\u00e9: O(log((hi-lo)/gap))`\n"}, {"name": "discrete_binary_search", "description": "Recherche binaire dans un tableau\n\n:param onglet: boolean monotone de la table avec l'onglet[hi] = True\n:param int lo:\n:param int hi: hi >= lo\n:retourne: premier indice i dans [lo,hi] tel que tab[i]\n:complexit\u00e9: O(log(hi-lo))`\n"}, {"name": "optimized_binary_search", "description": "Recherche binaire dans un tableau en utilisant les op\u00e9rations sur les bits\n\n:param onglet: boolean monotone table\nde taille :math:`2^\\textrm{logsize}`\navec l'onglet[hi] = True\n:param int taille de log:\n:r\u00e9sultat: j'ai d'abord tel que tab[i]\n:complexit\u00e9: O(taille de log)\n"}, {"name": "optimized_binary_search_lower", "description": "Recherche binaire dans un tableau en utilisant les op\u00e9rations sur les bits\n\n:param onglet: boolean monotone table\nde taille :math:`2^\\textrm{logsize}`\navec tab[0] = False\n:param int taille de log:\n:retourne: le dernier que j'ai qui ne tab[i]\n:complexit\u00e9: O(taille de log)\n"}, {"name": "ternary_search", "description": "Ternaire de recherche maximale pour un bitonic fonction\n\n:param f: boolean bitonic fonction (croissante puis d\u00e9croissante,\npas n\u00e9cessairement strictement)\n:param int lo:\n:param int hi: hi >= lo\n:param float \u00e9cart:\n:retourne: une valeur x dans [lo,hi] maximiser f(x),\nx est calcul\u00e9e jusqu'\u00e0 un certain degr\u00e9 de pr\u00e9cision\n:complexit\u00e9: O(log((hi-lo)/gap))`\n"}], "classes": []}}, {"EN": {"name": "knuth_morris_pratt", "description": "Find the length of maximal borders by Knuth-Morris-Pratt\n\njill-j\u00eann vie, christoph d\u00fcrr et louis abraham - 2014-2019\ninspired from a practical lesson (TP) from Yves Lemaire\n", "functions": [{"name": "knuth_morris_pratt", "description": "Find a substring by Knuth-Morris-Pratt\n\n    :param s: the haystack string\n    :param t: the needle string\n    :returns: index i such that s[i: i + len(t)] == t, or -1\n    :complexity: O(len(s) + len(t))\n    ", "examples": [{"args": [{"name": "s", "value": "'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab'", "type": "str"}, {"name": "t", "value": "'aaaaaaaaaab'", "type": "str"}], "return": {"value": "90", "type": "int"}}, {"args": [{"name": "s", "value": "'8765260054852999142686125792448365444121224281234370048622563045346950735829704815617439244102248679'", "type": "str"}, {"name": "t", "value": "'8704486163'", "type": "str"}], "return": {"value": "-1", "type": "int"}}, {"args": [{"name": "s", "value": "'ab'", "type": "str"}, {"name": "t", "value": "'a'", "type": "str"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "s", "value": "'ab'", "type": "str"}, {"name": "t", "value": "'b'", "type": "str"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "s", "value": "'ab'", "type": "str"}, {"name": "t", "value": "'c'", "type": "str"}], "return": {"value": "-1", "type": "int"}}, {"args": [{"name": "s", "value": "''", "type": "str"}, {"name": "t", "value": "'c'", "type": "str"}], "return": {"value": "-1", "type": "int"}}]}, {"name": "maximum_border_length", "description": "Maximum string borders by Knuth-Morris-Pratt\n\n    :param w: string\n    :returns: table f such that f[i] is the longest border length of w[:i + 1]\n    :complexity: linear\n    ", "examples": [{"args": [{"name": "w", "value": "'aaaaaaaaaab\\x00aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab'", "type": "str"}], "return": {"value": "[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11]", "type": "list"}}, {"args": [{"name": "w", "value": "'8704486163\\x008765260054852999142686125792448365444121224281234370048622563045346950735829704815617439244102248679'", "type": "str"}], "return": {"value": "[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]", "type": "list"}}, {"args": [{"name": "w", "value": "'a\\x00ab'", "type": "str"}], "return": {"value": "[0, 0, 1, 0]", "type": "list"}}, {"args": [{"name": "w", "value": "'b\\x00ab'", "type": "str"}], "return": {"value": "[0, 0, 0, 1]", "type": "list"}}, {"args": [{"name": "w", "value": "'c\\x00ab'", "type": "str"}], "return": {"value": "[0, 0, 0, 0]", "type": "list"}}, {"args": [{"name": "w", "value": "'c\\x00'", "type": "str"}], "return": {"value": "[0, 0]", "type": "list"}}, {"args": [{"name": "w", "value": "'aba#abababaababb'", "type": "str"}], "return": {"value": "[0, 0, 1, 0, 1, 2, 3, 2, 3, 2, 3, 1, 2, 3, 2, 0]", "type": "list"}}, {"args": [{"name": "w", "value": "'ababab'", "type": "str"}], "return": {"value": "[0, 0, 1, 2, 3, 4]", "type": "list"}}, {"args": [{"name": "w", "value": "'abaab'", "type": "str"}], "return": {"value": "[0, 0, 1, 1, 2]", "type": "list"}}]}, {"name": "powerstring_by_border", "description": "Power string by Knuth-Morris-Pratt\n\n    :param x: string\n    :returns: largest k such that there is a string y with x = y^k\n    :complexity: O(len(x))\n    ", "examples": [{"args": [{"name": "u", "value": "'ababab'", "type": "str"}], "return": {"value": "3", "type": "int"}}, {"args": [{"name": "u", "value": "'abaab'", "type": "str"}], "return": {"value": "1", "type": "int"}}]}, {"name": "powerstring_by_find", "description": "Power string using the python find method\n\n    :param x: string\n    :returns: largest k such that there is a string y with x = y^k\n    :complexity: O(len(x))\n    "}], "classes": []}, "FR": {"name": "knuth_morris_pratt", "description": "Trouver la longueur maximale de fronti\u00e8res par Knuth-Morris-Pratt\n\njill-j\u00eann vie, christoph d\u00fcrr et louis abraham - 2014-2019\ninspir\u00e9 d'une le\u00e7on pratique (TP) d'Yves Lemaire\n", "functions": [{"name": "knuth_morris_pratt", "description": "Rechercher une sous-cha\u00eene par Knuth-Morris-Pratt\n\n:param s: la botte de foin de la cha\u00eene\n:param t: l'aiguille de la cha\u00eene\n:retourne: indice i tel que s[i: i + len(t)] == t, ou -1\n:complexit\u00e9: O(len(s) + len(t))\n"}, {"name": "maximum_border_length", "description": "Maximale de la cha\u00eene fronti\u00e8res par Knuth-Morris-Pratt\n\n:param w: string\n:retourne: tableau f tel que f[i] est la plus longue fronti\u00e8re de la longueur de w[:i + 1]\n:complexit\u00e9: lin\u00e9aire\n"}, {"name": "powerstring_by_border", "description": "La puissance de la cha\u00eene par Knuth-Morris-Pratt\n\n:param x: string\n:renvoie: le plus grand k tel qu'il existe une cha\u00eene de y avec x = y^k\n:complexit\u00e9: O(len(x))\n"}, {"name": "powerstring_by_find", "description": "Puissance de cha\u00eene \u00e0 l'aide de python m\u00e9thode find\n\n:param x: string\n:renvoie: le plus grand k tel qu'il existe une cha\u00eene de y avec x = y^k\n:complexit\u00e9: O(len(x))\n"}], "classes": []}}, {"EN": {"name": "dinic", "description": "Maximum flow by Dinic\njill-j\u00eann vie et christoph d\u00fcrr - 2015-2018\n", "functions": [{"name": "_dinic_step", "description": " tenter de pousser le plus de flot de u \u00e0 target, sans d\u00e9passer limit\n    ", "examples": [{"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "level", "value": "[0, 1, 1, 2, 2, 3]", "type": "list"}, {"name": "flow", "value": "[[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]", "type": "list"}, {"name": "u", "value": "5", "type": "int"}, {"name": "target", "value": "5", "type": "int"}, {"name": "limit", "value": "1", "type": "int"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "level", "value": "[0, 1, 1, 2, 2, 3]", "type": "list"}, {"name": "flow", "value": "[[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]", "type": "list"}, {"name": "u", "value": "3", "type": "int"}, {"name": "target", "value": "5", "type": "int"}, {"name": "limit", "value": "1", "type": "int"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "level", "value": "[0, 1, 1, 2, 2, 3]", "type": "list"}, {"name": "flow", "value": "[[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]", "type": "list"}, {"name": "u", "value": "1", "type": "int"}, {"name": "target", "value": "5", "type": "int"}, {"name": "limit", "value": "9", "type": "int"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "level", "value": "[0, 1, 1, 2, 2, 3]", "type": "list"}, {"name": "flow", "value": "[[0, 1, 0, 0, 0, 0], [-1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0], [0, -1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0], [0, 0, 0, -1, 0, 0]]", "type": "list"}, {"name": "u", "value": "5", "type": "int"}, {"name": "target", "value": "5", "type": "int"}, {"name": "limit", "value": "1", "type": "int"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "level", "value": "[0, 1, 1, 2, 2, 3]", "type": "list"}, {"name": "flow", "value": "[[0, 1, 0, 0, 0, 0], [-1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0], [0, -1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0], [0, 0, 0, -1, 0, 0]]", "type": "list"}, {"name": "u", "value": "4", "type": "int"}, {"name": "target", "value": "5", "type": "int"}, {"name": "limit", "value": "1", "type": "int"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "level", "value": "[0, 1, 1, 2, 2, 3]", "type": "list"}, {"name": "flow", "value": "[[0, 1, 0, 0, 0, 0], [-1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0], [0, -1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0], [0, 0, 0, -1, 0, 0]]", "type": "list"}, {"name": "u", "value": "2", "type": "int"}, {"name": "target", "value": "5", "type": "int"}, {"name": "limit", "value": "9", "type": "int"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "level", "value": "[0, 1, 1, 2, 2, 3]", "type": "list"}, {"name": "flow", "value": "[[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]", "type": "list"}, {"name": "u", "value": "0", "type": "int"}, {"name": "target", "value": "5", "type": "int"}, {"name": "limit", "value": "18", "type": "int"}], "return": {"value": "2", "type": "int"}}]}, {"name": "dinic", "description": "Maximum flow by Dinic\n\n    :param graph: directed graph in listlist or listdict format\n    :param capacity: in matrix format or same listdict graph\n    :param int source: vertex\n    :param int target: vertex\n    :returns: skew symmetric flow matrix, flow value\n    :complexity: :math:`O(|V|^2 |E|)`\n    ", "examples": [{"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1}, {4: 1}, {5: 9}, {5: 9}, {}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1}, {4: 1}, {5: 9}, {5: 9}, {}]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "5", "type": "int"}], "return": {"value": "([[0, 1, 1, 0, 0, 0], [-1, 0, 0, 1, 0, 0], [-1, 0, 0, 0, 1, 0], [0, -1, 0, 0, 0, 1], [0, 0, -1, 0, 0, 1], [0, 0, 0, -1, -1, 0]], 2)", "type": "tuple"}}]}], "classes": []}, "FR": {"name": "dinic", "description": "D\u00e9bit maximal par Dinic\njill-j\u00eann vie et christoph d\u00fcrr - 2015-2018\n", "functions": [{"name": "_dinic_step", "description": " tentrer de pousser le plus de flot de u \u00e0 la cible, sans d\u00e9passer la limite de\n"}, {"name": "dinic", "description": "D\u00e9bit maximal par Dinic\n\n:param graphe: graphe orient\u00e9 dans listlist ou listdict format\n:param capacit\u00e9: dans un format de matrice ou m\u00eame listdict graphique\n:param int source: sommet\n:param int cible: sommet\n:retourne: inclinaison sym\u00e9trique de la matrice de flux, le flux de valeur\n:complexit\u00e9: :math:`O(|V|^2 |E|)`\n"}], "classes": []}}, {"EN": {"name": "predictive_text", "description": "Predictive text for mobile phones\njill-jenn vie et christoph durr and louis abraham - 2014-2019\n", "functions": [{"name": "code_word", "description": ":returns: the digit correspondence for given word", "examples": [{"args": [{"name": "word", "value": "'a'", "type": "str"}], "return": {"value": "'2'", "type": "str"}}, {"args": [{"name": "word", "value": "'an'", "type": "str"}], "return": {"value": "'26'", "type": "str"}}, {"args": [{"name": "word", "value": "'ano'", "type": "str"}], "return": {"value": "'266'", "type": "str"}}, {"args": [{"name": "word", "value": "'anot'", "type": "str"}], "return": {"value": "'2668'", "type": "str"}}, {"args": [{"name": "word", "value": "'anoth'", "type": "str"}], "return": {"value": "'26684'", "type": "str"}}, {"args": [{"name": "word", "value": "'anothe'", "type": "str"}], "return": {"value": "'266843'", "type": "str"}}, {"args": [{"name": "word", "value": "'another'", "type": "str"}], "return": {"value": "'2668437'", "type": "str"}}, {"args": [{"name": "word", "value": "'c'", "type": "str"}], "return": {"value": "'2'", "type": "str"}}, {"args": [{"name": "word", "value": "'co'", "type": "str"}], "return": {"value": "'26'", "type": "str"}}, {"args": [{"name": "word", "value": "'con'", "type": "str"}], "return": {"value": "'266'", "type": "str"}}]}, {"name": "letter_to_digit", "description": ":returns: the digit correspondence for letter x", "examples": [{"args": [{"name": "x", "value": "'a'", "type": "str"}], "return": {"value": "'2'", "type": "str"}}, {"args": [{"name": "x", "value": "'n'", "type": "str"}], "return": {"value": "'6'", "type": "str"}}, {"args": [{"name": "x", "value": "'o'", "type": "str"}], "return": {"value": "'6'", "type": "str"}}, {"args": [{"name": "x", "value": "'t'", "type": "str"}], "return": {"value": "'8'", "type": "str"}}, {"args": [{"name": "x", "value": "'h'", "type": "str"}], "return": {"value": "'4'", "type": "str"}}, {"args": [{"name": "x", "value": "'e'", "type": "str"}], "return": {"value": "'3'", "type": "str"}}, {"args": [{"name": "x", "value": "'r'", "type": "str"}], "return": {"value": "'7'", "type": "str"}}, {"args": [{"name": "x", "value": "'c'", "type": "str"}], "return": {"value": "'2'", "type": "str"}}, {"args": [{"name": "x", "value": "'s'", "type": "str"}], "return": {"value": "'7'", "type": "str"}}, {"args": [{"name": "x", "value": "'f'", "type": "str"}], "return": {"value": "'3'", "type": "str"}}]}, {"name": "predictive_text", "description": "Predictive text for mobile phones\n\n    :param dic: associates weights to words from [a-z]*\n    :returns: a dictionary associating to words from [2-9]*\n             a corresponding word from the dictionary with highest weight\n    :complexity: linear in total word length\n    ", "examples": [{"args": [{"name": "dic", "value": "[('another', 5), ('contest', 6), ('follow', 3), ('give', 13), ('integer', 6), ('new', 14), ('program', 4)]", "type": "list"}], "return": {"value": "{'2': 'c', '26': 'co', '266': 'con', '2668': 'cont', '26684': 'anoth', '266843': 'anothe', '2668437': 'another', '26683': 'conte', '266837': 'contes', '2668378': 'contest', '3': 'f', '36': 'fo', '365': 'fol', '3655': 'foll', '36556': 'follo', '365569': 'follow', '4': 'g', '44': 'gi', '448': 'giv', '4483': 'give', '46': 'in', '468': 'int', '4683': 'inte', '46834': 'integ', '468343': 'intege', '4683437': 'integer', '6': 'n', '63': 'ne', '639': 'new', '7': 'p', '77': 'pr', '776': 'pro', '7764': 'prog', '77647': 'progr', '776472': 'progra', '7764726': 'program'}", "type": "dict"}}]}, {"name": "propose", "description": "wrapper to access a dictionary even for non-present keys", "examples": []}], "classes": []}, "FR": {"name": "predictive_text", "description": "La saisie de texte pr\u00e9dictive pour les t\u00e9l\u00e9phones mobiles\njill-jenn vie et christoph durr et louis abraham - 2014-2019\n", "functions": [{"name": "code_word", "description": ":r\u00e9sultat: le chiffre de la correspondance mot donn\u00e9"}, {"name": "letter_to_digit", "description": ":r\u00e9sultat: le chiffre de la correspondance pour la lettre x"}, {"name": "predictive_text", "description": "La saisie de texte pr\u00e9dictive pour les t\u00e9l\u00e9phones mobiles\n\n:param dic: les associ\u00e9s poids aux mots de [a-z]*\n:retourne: un dictionnaire associant \u00e0 des mots \u00e0 partir de [2-9]*\nun mot correspondant dans le dictionnaire avec plus de poids\n:complexit\u00e9: lin\u00e9aire total de la longueur des mots\n"}, {"name": "proposer", "description": "wrapper pour acc\u00e9der \u00e0 un dictionnaire, m\u00eame pour les non-pr\u00e9sent cl\u00e9s"}], "classes": []}}, {"EN": {"name": "closest_values", "description": "Closest values\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "closest_values", "description": "Closest values\n\n    :param L: list of values\n    :returns: two values from L with minimal distance\n    :modifies: the order of L\n    :complexity: O(n log n), for n=len(L)\n    ", "examples": [{"args": [{"name": "L", "value": "[0, 2]", "type": "list"}], "return": {"value": "(0, 2)", "type": "tuple"}}]}], "classes": []}, "FR": {"name": "closest_values", "description": "Plus proche des valeurs\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "closest_values", "description": "Plus proche des valeurs\n\n:param L: liste de valeurs\n:r\u00e9sultat: deux valeurs de L avec la distance minimale\n:modifie: de l'ordre de L\n:complexit\u00e9: O(n log n), pour n=len(L)\n"}], "classes": []}}, {"EN": {"name": "eulerian_tour", "description": "Eulerian cycle\njill-jenn vie et christoph durr - 2015-2018\n", "functions": [{"name": "eulerian_tour_directed", "description": "Eulerian tour on a directed graph\n\n       :param graph: directed graph in listlist format, cannot be listdict\n       :assumes: graph is eulerian\n       :returns: eulerian cycle as a vertex list\n       :complexity: `O(|V|+|E|)`\n    ", "examples": [{"args": [{"name": "graph", "value": "[[1, 2], [0, 2, 3, 4], [0, 1, 3, 4], [1, 2], [1, 2]]", "type": "list"}], "return": {"value": "[0, 1, 2, 3, 2, 4, 2, 1, 3, 1, 4, 1, 0, 2, 0]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1, 2], [0, 2, 3, 4], [0, 1, 3, 4], [1, 2, 4], [1, 2, 3]]", "type": "list"}], "return": {"value": "[0, 1, 2, 3, 4, 3, 2, 4, 2, 1, 3, 1, 4, 1, 0, 2, 0]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1, 3, 4], [0, 2], [1], [0, 4], [0, 3]]", "type": "list"}], "return": {"value": "[0, 1, 2, 1, 0, 3, 4, 3, 0, 4, 0]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1, 2], [0, 2, 3, 4], [0, 1], [1, 4], [1, 3, 5, 6], [4, 6], [4, 5]]", "type": "list"}], "return": {"value": "[0, 1, 2, 1, 3, 4, 5, 6, 5, 4, 6, 4, 3, 1, 4, 1, 0, 2, 0]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1], [0]]", "type": "list"}], "return": {"value": "[0, 1, 0]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1, 2], [0, 3], [0, 3], [1, 2, 4], [3]]", "type": "list"}], "return": {"value": "[0, 1, 3, 2, 3, 4, 3, 1, 0, 2, 0]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1, 2], [0, 2], [0, 1]]", "type": "list"}], "return": {"value": "[0, 1, 2, 1, 0, 2, 0]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1, 2], [0, 2], [3], [1]]", "type": "list"}], "return": {"value": "[0, 1, 0, 2, 3, 1, 2]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1], [2], [3], [4, 5], [3, 6], [4], [0]]", "type": "list"}], "return": {"value": "[0, 1, 2, 3, 4, 3, 5, 4, 6, 0]", "type": "list"}}]}, {"name": "eulerian_tour_undirected", "description": "Eulerian tour on an undirected graph\n\n       :param graph: directed graph in listlist format, cannot be listdict\n       :assumes: graph is eulerian\n       :returns: eulerian cycle as a vertex list\n       :complexity: `O(|V|+|E|)`\n    "}, {"name": "is_eulerian_tour", "description": "Eulerian tour on an undirected graph\n\n       :param graph: directed graph in listlist format, cannot be listdict\n       :param tour: vertex list\n       :returns: test if tour is eulerian\n       :complexity: `O(|V|*|E|)` under the assumption that\n       set membership is in constant time\n    ", "examples": [{"args": [{"name": "graph", "value": "[[1, 2], [0, 2, 3, 4], [0, 1, 3, 4], [1, 2], [1, 2]]", "type": "list"}, {"name": "tour", "value": "[0, 1, 2, 3, 2, 4, 2, 1, 3, 1, 4, 1, 0, 2, 0]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "graph", "value": "[[1, 2], [0, 2, 3, 4], [0, 1, 3, 4], [1, 2, 4], [1, 2, 3]]", "type": "list"}, {"name": "tour", "value": "[0, 1, 2, 3, 4, 3, 2, 4, 2, 1, 3, 1, 4, 1, 0, 2, 0]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "graph", "value": "[[1, 3, 4], [0, 2], [1], [0, 4], [0, 3]]", "type": "list"}, {"name": "tour", "value": "[0, 1, 2, 1, 0, 3, 4, 3, 0, 4, 0]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "graph", "value": "[[1, 2], [0, 2, 3, 4], [0, 1], [1, 4], [1, 3, 5, 6], [4, 6], [4, 5]]", "type": "list"}, {"name": "tour", "value": "[0, 1, 2, 1, 3, 4, 5, 6, 5, 4, 6, 4, 3, 1, 4, 1, 0, 2, 0]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "graph", "value": "[[1], [0]]", "type": "list"}, {"name": "tour", "value": "[0, 1, 0]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "graph", "value": "[[1, 2], [0, 3], [0, 3], [1, 2, 4], [3]]", "type": "list"}, {"name": "tour", "value": "[0, 1, 3, 2, 3, 4, 3, 1, 0, 2, 0]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "graph", "value": "[[1, 2], [0, 2], [0, 1]]", "type": "list"}, {"name": "tour", "value": "[0, 1, 2, 1, 0, 2, 0]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "graph", "value": "[[1, 2], [0, 2], [3], [1]]", "type": "list"}, {"name": "tour", "value": "[0, 1, 0, 2, 3, 1, 2]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "graph", "value": "[[1], [2], [3], [4, 5], [3, 6], [4], [0]]", "type": "list"}, {"name": "tour", "value": "[0, 1, 2, 3, 4, 3, 5, 4, 6, 0]", "type": "list"}], "return": {"value": "True", "type": "bool"}}]}, {"name": "random_eulerien_graph", "description": "Generates some random eulerian graph\n\n       :param int n: number of vertices\n       :returns: undirected graph in listlist representation\n       :complexity: linear\n    ", "examples": [{"args": [{"name": "n", "value": "50", "type": "int"}], "return": {"value": "[[4, 9, 17, 21, 37, 46, 25, 29, 19, 11, 23, 34, 41, 39, 6, 26, 33, 12, 38, 16, 35, 36, 45, 10, 27, 47, 48, 13, 42, 20, 40, 8, 24, 1, 2, 43, 5, 32, 28, 18, 49, 7, 31, 3, 30, 15], [0, 11, 39, 14, 3, 21, 8, 12, 38, 26, 17, 20, 44, 49, 6, 24, 13, 35, 5, 4, 36, 19, 28, 43, 42, 32, 41, 9, 16, 22, 48, 40, 18, 27, 2, 23, 47, 30], [0, 1, 21, 17, 14, 16, 6, 4, 41, 9, 30, 13, 3, 15, 22, 46, 43, 48, 19, 31, 38, 12, 7, 36, 24, 35, 29, 32], [0, 1, 2, 48, 44, 34, 47, 46, 36, 24, 7, 28, 21, 41, 32, 25, 43, 30, 18, 37, 11, 5, 40, 31, 35, 19, 33, 23, 10, 16, 6, 4, 49, 20], [0, 1, 2, 3, 41, 40, 22, 29, 14, 21, 34, 6, 48, 19, 37, 5, 43, 27, 12, 44], [0, 1, 3, 4, 11, 22, 13, 34, 31, 18, 24, 7, 45, 48, 14, 17, 16, 43, 21, 26, 23, 20, 8, 32, 28, 33, 39, 44, 12, 46, 47, 10, 30, 35], [0, 1, 2, 3, 4, 32, 43, 42, 13, 29, 46, 37, 19, 16, 28, 7, 24, 47, 31, 44, 30, 18, 40, 23, 36, 15, 49, 27, 14, 33, 39, 21, 8, 35, 12, 25, 10, 26, 38, 17], [0, 2, 3, 5, 6, 35, 10, 17, 20, 49, 29, 14, 23, 42, 39, 13, 45, 11, 46, 26, 30, 21, 40, 28, 16, 22], [0, 1, 5, 6, 11, 36], [0, 1, 2, 40, 24, 44, 38, 33, 34, 39, 27, 25, 26, 17, 41, 16, 15, 49, 14, 12, 21, 20, 42, 13, 29, 35, 18, 32], [0, 3, 5, 6, 7, 12, 35, 36, 47, 16, 14, 19, 28, 48, 32, 21, 20, 11, 45, 15, 31, 26, 22, 29, 30, 24, 39, 27, 40, 34], [0, 1, 3, 5, 7, 8, 10, 21], [0, 1, 2, 4, 5, 6, 9, 10, 43, 47, 15, 41, 30, 31, 32, 28, 34, 44, 42, 33, 40, 17, 21, 37, 25, 20, 49, 46], [0, 1, 2, 5, 6, 7, 9, 49, 27, 48, 24, 47, 33, 21, 36, 17, 32, 39, 22, 16, 14, 34, 25, 37, 35, 44, 46, 15, 28, 30, 23, 29, 19, 26, 45, 40], [1, 2, 4, 5, 6, 7, 9, 10, 13, 34, 23, 20, 36, 16, 48, 26, 31, 46, 45, 30, 29, 37, 24, 15, 21, 19, 43, 17, 44, 28], [0, 2, 6, 9, 10, 12, 13, 14, 19, 48, 30, 40, 46, 39, 32, 16], [0, 1, 2, 3, 5, 6, 7, 9, 10, 13, 14, 15, 46, 26, 36, 22, 17, 45, 27, 31, 32, 42, 21, 35, 44, 43, 29, 41, 34, 24], [0, 1, 2, 5, 6, 7, 9, 12, 13, 14, 16, 36, 33, 32, 26, 41, 45, 42, 27, 46, 21, 43, 30, 23, 40, 28, 31, 49, 38, 34, 44, 47, 24, 35, 18, 19, 20, 29, 22, 37, 48, 39], [0, 1, 3, 5, 6, 9, 17, 37, 40, 33, 20, 23, 39, 27, 46, 41, 44, 43, 31, 19, 38, 47, 34, 24, 28, 32], [0, 1, 2, 3, 4, 6, 10, 13, 14, 15, 17, 18, 44, 43, 38, 27, 28, 41, 25, 39, 22, 34, 32, 37, 40, 24, 45, 26, 48, 21], [0, 1, 3, 5, 7, 9, 10, 12, 14, 17, 18, 39, 42, 44, 34, 24, 22, 41, 29, 26, 36, 27, 25, 48, 45, 35, 47, 46, 30, 38, 43, 23, 21, 31, 37, 33, 40, 49], [0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 16, 17, 19, 20, 37, 25], [1, 2, 4, 5, 7, 10, 13, 16, 17, 19, 20, 41, 46, 23, 38, 29, 35, 43, 28, 44, 37, 42, 49, 31, 26, 45, 24, 40, 48, 33, 30, 39, 34, 36, 47, 27, 32, 25], [0, 1, 3, 5, 6, 7, 13, 14, 17, 18, 20, 22, 28, 38, 27, 26, 32, 40, 24, 49, 48, 34, 30, 33, 29, 36, 41, 25, 43, 42, 37, 46, 39, 47], [0, 1, 2, 3, 5, 6, 9, 10, 13, 14, 16, 17, 18, 19, 20, 22, 23, 26, 33, 49, 47, 41, 28, 39, 45, 36, 25, 37, 29, 35, 46, 42], [0, 3, 6, 9, 12, 13, 19, 20, 21, 22, 23, 24, 26, 47, 31, 42, 44, 33, 36, 48, 38, 49, 43, 40, 29, 30, 39, 37, 46, 41, 28, 27, 32, 45, 35, 34], [0, 1, 5, 6, 7, 9, 10, 13, 14, 16, 17, 19, 20, 22, 23, 24, 25, 32, 30, 34, 48, 29, 40, 47, 28, 38, 44, 27, 49, 33], [0, 1, 4, 6, 9, 10, 13, 16, 17, 18, 19, 20, 22, 23, 25, 26, 31, 28, 29, 37, 45, 46, 35, 32, 38, 41], [0, 1, 3, 5, 6, 7, 10, 12, 13, 14, 17, 18, 19, 22, 23, 24, 25, 26, 27, 47, 38, 29, 30, 35, 34, 31], [0, 2, 4, 6, 7, 9, 10, 13, 14, 16, 17, 20, 22, 23, 24, 25, 26, 27, 28, 32, 37, 47, 49, 33], [0, 1, 2, 3, 5, 6, 7, 10, 12, 13, 14, 15, 17, 20, 22, 23, 25, 26, 28, 45, 41, 39, 43, 42, 31, 34, 40, 49], [0, 2, 3, 5, 6, 10, 12, 14, 16, 17, 18, 20, 22, 25, 27, 28, 30, 40], [0, 1, 2, 3, 5, 6, 9, 10, 12, 13, 15, 16, 17, 18, 19, 22, 23, 25, 26, 27, 29, 41, 37, 38, 44, 33, 47, 49, 46, 48, 45, 40, 36, 39, 42, 43, 34, 35], [0, 3, 5, 6, 9, 12, 13, 17, 18, 20, 22, 23, 24, 25, 26, 29, 32, 37, 34, 45, 39, 48, 49, 46, 41, 35, 42, 36, 47, 38, 40, 43], [0, 3, 4, 5, 9, 10, 12, 13, 14, 16, 17, 18, 19, 20, 22, 23, 25, 26, 28, 30, 32, 33, 48, 38, 39, 40, 42, 41], [0, 1, 2, 3, 5, 6, 7, 9, 10, 13, 16, 17, 20, 22, 24, 25, 27, 28, 32, 33, 48, 44, 49, 45, 41, 47, 42, 39, 37, 46], [0, 1, 2, 3, 6, 8, 10, 13, 14, 16, 17, 20, 22, 23, 24, 25, 32, 33, 40, 45, 48, 37], [0, 3, 4, 6, 12, 13, 14, 17, 18, 19, 20, 21, 22, 23, 24, 25, 27, 29, 32, 33, 35, 36, 46, 49, 38, 47, 44, 39], [0, 1, 2, 6, 9, 17, 18, 19, 20, 22, 23, 25, 26, 27, 28, 32, 33, 34, 37, 41, 42, 47], [0, 1, 5, 6, 7, 9, 10, 13, 15, 17, 18, 19, 20, 22, 23, 24, 25, 30, 32, 33, 34, 35, 37, 47, 42, 44, 40, 49, 43, 45, 46, 48], [0, 1, 3, 4, 6, 7, 9, 10, 12, 13, 15, 17, 18, 19, 20, 22, 23, 25, 26, 30, 31, 32, 33, 34, 36, 39, 47, 46, 49, 44], [0, 1, 2, 3, 4, 9, 12, 16, 17, 18, 19, 20, 22, 23, 24, 25, 27, 30, 32, 33, 34, 35, 38, 45, 43, 49, 47, 42, 44, 46], [0, 1, 6, 7, 9, 12, 16, 17, 20, 22, 23, 24, 25, 30, 32, 33, 34, 35, 38, 39, 41, 49, 45, 44], [0, 1, 2, 3, 4, 5, 6, 12, 14, 16, 17, 18, 19, 20, 22, 23, 25, 30, 32, 33, 39, 41, 49, 48, 46, 44, 47, 45], [1, 3, 4, 5, 6, 9, 12, 13, 14, 16, 17, 18, 19, 20, 22, 25, 26, 32, 35, 37, 39, 40, 41, 42, 43, 49, 46, 48], [0, 5, 7, 10, 13, 14, 16, 17, 19, 20, 22, 24, 25, 27, 30, 32, 33, 35, 36, 39, 41, 42, 43, 46, 49, 47], [0, 2, 3, 5, 6, 7, 12, 13, 14, 15, 16, 17, 18, 20, 22, 23, 24, 25, 27, 32, 33, 35, 37, 39, 40, 41, 43, 44, 45, 49], [0, 1, 3, 5, 6, 10, 12, 13, 17, 18, 20, 22, 23, 24, 25, 26, 28, 29, 32, 33, 35, 37, 38, 39, 40, 41, 43, 45], [0, 1, 2, 3, 4, 5, 10, 13, 14, 15, 17, 19, 20, 22, 23, 25, 26, 32, 33, 34, 35, 36, 39, 43, 44, 49], [0, 1, 3, 6, 7, 9, 12, 13, 17, 20, 22, 23, 24, 25, 26, 29, 30, 32, 33, 35, 37, 39, 40, 41, 42, 43, 44, 45, 46, 48]]", "type": "list"}}]}, {"name": "write_cycle", "description": "Write an eulerian tour in DOT format\n\n       :param filename: the file to be written in DOT format\n       :param graph: graph in listlist format, cannot be listdict\n       :param bool directed: describes the graph\n       :param cycle: tour as a vertex list\n       :returns: nothing\n       :complexity: `O(|V|^2 + |E|)`\n    "}], "classes": []}, "FR": {"name": "eulerian_tour", "description": "Cycle eul\u00e9rien\njill-jenn vie et christoph durr - 2015-2018\n", "functions": [{"name": "eulerian_tour_directed", "description": "Eul\u00e9rien tour sur un graphe orient\u00e9\n\n:param graphe: graphe orient\u00e9 dans listlist format, ne peut pas \u00eatre listdict\n:suppose: graphe est eul\u00e9rien\n:retourne: cycle eul\u00e9rien comme un sommet de la liste\n:complexit\u00e9: O(|V|+|E|)`\n"}, {"name": "eulerian_tour_undirected", "description": "Eul\u00e9rien tour sur un graphe non-dirig\u00e9\n\n:param graphe: graphe orient\u00e9 dans listlist format, ne peut pas \u00eatre listdict\n:suppose: graphe est eul\u00e9rien\n:retourne: cycle eul\u00e9rien comme un sommet de la liste\n:complexit\u00e9: O(|V|+|E|)`\n"}, {"name": "is_eulerian_tour", "description": "Eul\u00e9rien tour sur un graphe non-dirig\u00e9\n\n:param graphe: graphe orient\u00e9 dans listlist format, ne peut pas \u00eatre listdict\n:param tour: sommet de la liste\n:retourne: tester si la tour est eul\u00e9rien\n:complexit\u00e9: O(|V|*|E|)\", sous l'hypoth\u00e8se que\nl'appartenance est en temps constant\n"}, {"name": "random_eulerien_graph", "description": "G\u00e9n\u00e8re un hasard graphe eul\u00e9rien\n\n:param int n: nombre de sommets\n:retourne: graphes non orient\u00e9s dans listlist repr\u00e9sentation\n:complexit\u00e9: lin\u00e9aire\n"}, {"name": "write_cycle", "description": "\u00c9crire un eul\u00e9rien tour DOT format\n\n:param filename: le fichier sera \u00e9crit en DOT format\n:param graphique: graphique en listlist format, ne peut pas \u00eatre listdict\n:param bool dirig\u00e9: d\u00e9crit le graphe\n:param cycle: tour comme un sommet de la liste\n:retourne: rien du tout\n:complexit\u00e9: O(|V|^2 + |E|)`\n"}], "classes": []}}, {"EN": {"name": "strongly_connected_components", "description": "Strongly connected components\ncomposantes fortement connexes\njill-j\u00eann vie et christoph d\u00fcrr - 2015-2018\n", "functions": [{"name": "kosaraju", "description": "Strongly connected components by Kosaraju\n\n    :param graph: directed graph in listlist format, cannot be listdict\n    :returns: list of lists for each component\n    :complexity: linear\n    ", "examples": [{"args": [{"name": "graph", "value": "[[]]", "type": "list"}], "return": {"value": "[[0]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[0]]", "type": "list"}], "return": {"value": "[[0]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1], [2], [0]]", "type": "list"}], "return": {"value": "[[0, 2, 1]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1], [2], []]", "type": "list"}], "return": {"value": "[[2], [1], [0]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[], [0], [1]]", "type": "list"}], "return": {"value": "[[0], [1], [2]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1], [2], [0, 3], [4], [5], [3]]", "type": "list"}], "return": {"value": "[[3, 5, 4], [0, 2, 1]]", "type": "list"}}, {"args": [{"name": "graph", "value": "{0: [1], 1: [2, 3], 2: [4, 5], 3: [4, 5], 4: [6], 5: [], 6: []}", "type": "dict"}], "return": {"value": "[[6], [4], [5], [2], [3], [1], [0]]", "type": "list"}}, {"args": [{"name": "graph", "value": "{0: [1], 1: [2, 3, 4], 2: [0, 3], 3: [4], 4: [3]}", "type": "dict"}], "return": {"value": "[[3, 4], [0, 2, 1]]", "type": "list"}}]}, {"name": "kosaraju_dfs", "description": "\n    kosaraju depth-first-search over graph\n    ", "examples": [{"args": [{"name": "graph", "value": "[[]]", "type": "list"}, {"name": "nodes", "value": "range(0, 1)", "type": "range"}, {"name": "order", "value": "[]", "type": "list"}, {"name": "sccp", "value": "[]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[]]", "type": "list"}, {"name": "nodes", "value": "[0]", "type": "list"}, {"name": "order", "value": "[]", "type": "list"}, {"name": "sccp", "value": "[]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[0]]", "type": "list"}, {"name": "nodes", "value": "range(0, 1)", "type": "range"}, {"name": "order", "value": "[]", "type": "list"}, {"name": "sccp", "value": "[]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[0]]", "type": "list"}, {"name": "nodes", "value": "[0]", "type": "list"}, {"name": "order", "value": "[]", "type": "list"}, {"name": "sccp", "value": "[]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[1], [2], [0]]", "type": "list"}, {"name": "nodes", "value": "range(0, 3)", "type": "range"}, {"name": "order", "value": "[]", "type": "list"}, {"name": "sccp", "value": "[]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[2], [0], [1]]", "type": "list"}, {"name": "nodes", "value": "[0, 1, 2]", "type": "list"}, {"name": "order", "value": "[]", "type": "list"}, {"name": "sccp", "value": "[]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[1], [2], []]", "type": "list"}, {"name": "nodes", "value": "range(0, 3)", "type": "range"}, {"name": "order", "value": "[]", "type": "list"}, {"name": "sccp", "value": "[]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[], [0], [1]]", "type": "list"}, {"name": "nodes", "value": "[0, 1, 2]", "type": "list"}, {"name": "order", "value": "[]", "type": "list"}, {"name": "sccp", "value": "[]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[], [0], [1]]", "type": "list"}, {"name": "nodes", "value": "range(0, 3)", "type": "range"}, {"name": "order", "value": "[]", "type": "list"}, {"name": "sccp", "value": "[]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[[1], [2], []]", "type": "list"}, {"name": "nodes", "value": "[2, 1, 0]", "type": "list"}, {"name": "order", "value": "[]", "type": "list"}, {"name": "sccp", "value": "[]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}]}, {"name": "reverse", "description": "replace all arcs (u, v) by arcs (v, u) in a graph", "examples": [{"args": [{"name": "graph", "value": "[[]]", "type": "list"}], "return": {"value": "[[]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[0]]", "type": "list"}], "return": {"value": "[[0]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1], [2], [0]]", "type": "list"}], "return": {"value": "[[2], [0], [1]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1], [2], []]", "type": "list"}], "return": {"value": "[[], [0], [1]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[], [0], [1]]", "type": "list"}], "return": {"value": "[[1], [2], []]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1], [2], [0, 3], [4], [5], [3]]", "type": "list"}], "return": {"value": "[[2], [0], [1], [2, 5], [3], [4]]", "type": "list"}}, {"args": [{"name": "graph", "value": "{0: [1], 1: [2, 3], 2: [4, 5], 3: [4, 5], 4: [6], 5: [], 6: []}", "type": "dict"}], "return": {"value": "[[], [0], [1], [1], [2, 3], [2, 3], [4]]", "type": "list"}}, {"args": [{"name": "graph", "value": "{0: [1], 1: [2, 3, 4], 2: [0, 3], 3: [4], 4: [3]}", "type": "dict"}], "return": {"value": "[[2], [0], [1], [1, 2, 4], [1, 3]]", "type": "list"}}]}, {"name": "tarjan", "description": "Strongly connected components by Tarjan, iterative implementation\n\n    :param graph: directed graph in listlist format, cannot be listdict\n    :returns: list of lists for each component\n    :complexity: linear\n    ", "examples": [{"args": [{"name": "graph", "value": "[[]]", "type": "list"}], "return": {"value": "[[0]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[0]]", "type": "list"}], "return": {"value": "[[0]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1], [2], [0]]", "type": "list"}], "return": {"value": "[[2, 1, 0]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1], [2], []]", "type": "list"}], "return": {"value": "[[2], [1], [0]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[], [0], [1]]", "type": "list"}], "return": {"value": "[[0], [1], [2]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1], [2], [0, 3], [4], [5], [3]]", "type": "list"}], "return": {"value": "[[5, 4, 3], [2, 1, 0]]", "type": "list"}}, {"args": [{"name": "graph", "value": "{0: [1], 1: [2, 3], 2: [4, 5], 3: [4, 5], 4: [6], 5: [], 6: []}", "type": "dict"}], "return": {"value": "[[6], [4], [5], [2], [3], [1], [0]]", "type": "list"}}, {"args": [{"name": "graph", "value": "{0: [1], 1: [2, 3, 4], 2: [0, 3], 3: [4], 4: [3]}", "type": "dict"}], "return": {"value": "[[4, 3], [2, 1, 0]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[], [], [], [2, 2]]", "type": "list"}], "return": {"value": "[[0], [1], [2], [3]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[0], [1]]", "type": "list"}], "return": {"value": "[[0], [1]]", "type": "list"}}]}, {"name": "tarjan_recursif", "description": "Strongly connected components by Tarjan, recursive implementation\n\n    :param graph: directed graph in listlist format, cannot be listdict\n    :returns: list of lists for each component\n    :complexity: linear\n    ", "examples": [{"args": [{"name": "graph", "value": "[[]]", "type": "list"}], "return": {"value": "[[0]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[0]]", "type": "list"}], "return": {"value": "[[0]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1], [2], [0]]", "type": "list"}], "return": {"value": "[[2, 1, 0]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1], [2], []]", "type": "list"}], "return": {"value": "[[2], [1], [0]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[], [0], [1]]", "type": "list"}], "return": {"value": "[[0], [1], [2]]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1], [2], [0, 3], [4], [5], [3]]", "type": "list"}], "return": {"value": "[[5, 4, 3], [2, 1, 0]]", "type": "list"}}, {"args": [{"name": "graph", "value": "{0: [1], 1: [2, 3], 2: [4, 5], 3: [4, 5], 4: [6], 5: [], 6: []}", "type": "dict"}], "return": {"value": "[[6], [4], [5], [2], [3], [1], [0]]", "type": "list"}}, {"args": [{"name": "graph", "value": "{0: [1], 1: [2, 3, 4], 2: [0, 3], 3: [4], 4: [3]}", "type": "dict"}], "return": {"value": "[[4, 3], [2, 1, 0]]", "type": "list"}}]}], "classes": []}, "FR": {"name": "strongly_connected_components", "description": "Vivement les composants connect\u00e9s\ncomposantes fortement connexes\njill-j\u00eann vie et christoph d\u00fcrr - 2015-2018\n", "functions": [{"name": "kosaraju", "description": "Vivement les composants raccord\u00e9s par Kosaraju\n\n:param graphe: graphe orient\u00e9 dans listlist format, ne peut pas \u00eatre listdict\n:retourne: liste de listes pour chaque composant\n:complexit\u00e9: lin\u00e9aire\n"}, {"name": "kosaraju_dfs", "description": "\nkosaraju la profondeur de la premi\u00e8re recherche sur le graphique\n"}, {"name": "inverse", "description": "remplacer tous les arcs (u, v) par des arcs (v, u) dans un graphique"}, {"name": "tarjan", "description": "Vivement les composants raccord\u00e9s par Tarjan, it\u00e9ratif de mise en \u0153uvre\n\n:param graphe: graphe orient\u00e9 dans listlist format, ne peut pas \u00eatre listdict\n:retourne: liste de listes pour chaque composant\n:complexit\u00e9: lin\u00e9aire\n"}, {"name": "tarjan_recursif", "description": "Vivement les composants raccord\u00e9s par Tarjan, r\u00e9cursive de la mise en \u0153uvre\n\n:param graphe: graphe orient\u00e9 dans listlist format, ne peut pas \u00eatre listdict\n:retourne: liste de listes pour chaque composant\n:complexit\u00e9: lin\u00e9aire\n"}], "classes": []}}, {"EN": {"name": "our_heap", "description": "A min heap\nchristoph d\u00fcrr et jill-j\u00eann vie - 2015-2019\n", "functions": [], "classes": [{"name": "OurHeap", "description": " min heap\n\n    * heap: is the actual heap, heap[1] = index of the smallest element\n    * rank: inverse of heap with rank[x]=i iff heap[i]=x\n    * n: size of the heap\n\n    :complexity: init O(n log n), len O(1),\n                other operations O(log n) in expectation\n                and O(n) in worst case, due to the usage of a dictionary\n    ", "methods": [{"name": "__init__", "description": null}, {"name": "__len__", "description": null}, {"name": "down", "description": "the value of heap[i] has increased. Maintain heap invariant."}, {"name": "pop", "description": "Remove and return smallest element"}, {"name": "push", "description": "Insert new element x in the heap.\n           Assumption: x is not already in the heap"}, {"name": "up", "description": "The value of heap[i] has decreased. Maintain heap invariant."}, {"name": "update", "description": "Replace an element in the heap\n        "}]}]}, "FR": {"name": "our_heap", "description": "Un tas min\nchristoph d\u00fcrr et jill-j\u00eann vie - la p\u00e9riode 2015-2019\n", "functions": [], "classes": [{"name": "OurHeap", "description": " min tas\n\n* segment: le tas, tas[1] = indice du plus petit \u00e9l\u00e9ment\n* rang: l'inverse de tas avec le rang[x]=i iff tas[i]=x\n* n: taille de la heap\n\n:complexit\u00e9: init O(n log n), len O(1),\nd'autres op\u00e9rations en O(log n) dans l'attente\net O(n) dans le pire des cas, en raison de l'utilisation d'un dictionnaire\n", "methods": [{"name": "__init__", "description": null}, {"name": "__len__", "description": null}, {"name": "en bas", "description": "la valeur des tas[i] a augment\u00e9. Maintenir tas invariant."}, {"name": "pop", "description": "Retirer et de retourner le plus petit \u00e9l\u00e9ment"}, {"name": "pousser", "description": "Ins\u00e9rer un nouvel \u00e9l\u00e9ment x dans le tas.\nHypoth\u00e8se: x n'est pas d\u00e9j\u00e0 dans le tas"}, {"name": "jusqu'", "description": "La valeur des tas[i] a diminu\u00e9. Maintenir tas invariant."}, {"name": "mise \u00e0 jour", "description": "Remplacer un \u00e9l\u00e9ment dans le tas\n"}]}]}}, {"EN": {"name": "matrix_chain_mult", "description": "Matrix chain multiplication\nmultiplication de matrices\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "_apply_order", "description": null, "examples": []}, {"name": "matrix_chain_mult", "description": "Matrix chain multiplication\n\n    :param M: list of matrices\n    :returns: M[0] * ... * M[-1], computed in time optimal order\n    :complexity: whatever is needed by the multiplications\n    ", "examples": []}, {"name": "matrix_mult_opt_order", "description": "Matrix chain multiplication optimal order\n\n    :param M: list of matrices\n    :returns: matrices opt, arg, such that opt[i][j] is the optimal number of\n              operations to compute M[i] * ... * M[j] when done in the order\n              (M[i] * ... * M[k]) * (M[k + 1] * ... * M[j]) for k = arg[i][j]\n    :complexity: :math:`O(n^2)`\n    ", "examples": []}], "classes": []}, "FR": {"name": "matrix_chain_mult", "description": "La matrice de la cha\u00eene de multiplication\nla multiplication de matrices\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "_apply_order", "description": null}, {"name": "matrix_chain_mult", "description": "La matrice de la cha\u00eene de multiplication\n\n:param M: la liste de matrices\n:retourne: M[0] * ... * M[-1], calcul\u00e9e en temps d'ordre optimal\n:complexit\u00e9: tout ce qui est n\u00e9cessaire par la multiplication\n"}, {"name": "matrix_mult_opt_order", "description": "La matrice de la cha\u00eene d'multiplication ordre optimal\n\n:param M: la liste de matrices\n:retourne: matrices opt, arg, tels que opt[i][j] est le nombre optimal de\nop\u00e9rations pour calculer M[i] * ... * M[j] lorsqu'il est effectu\u00e9 dans l'ordre\n(M[i] * ... * M[k]) * (M[k + 1] * ... * M[j]) pour k = arg[i][j]\n:complexit\u00e9: :math:`O(n^2)`\n"}], "classes": []}}, {"EN": {"name": "horn_sat", "description": "Solving Horn SAT\n\nchristoph d\u00fcrr - 2016-2019\n\nclauses are numbered starting from 0\nvariables are strings (identifier)\n\nsolution  : set of variables that are set to true\nposvar_in_clause : maps clause to the unique positive variable in clause\n(or None)\nclause_with_negvar : maps variable v to all clauses that contain not(v)\n\nevery clause has a score: number of its negative variables\nthat are not in solution sol\npool : maps score to clauses of that score\n", "functions": [{"name": "horn_sat", "description": " Solving a HORN Sat formula\n\n    :param formula: list of couple(posvar, negvars).\n                    negvars is a list of the negative variables (can be empty)\n                    posvar is the positive variable (can be None)\n                    Variables can be any hashable objects: integers, strings...\n    :returns: None if formula is not satisfiable, else a minimal set of vars\n              that have to be set to true in order to satisfy the formula.\n    :complexity: linear\n    ", "examples": [{"args": [{"name": "formula", "value": "[(1, []), (1, []), (None, [2])]", "type": "list"}], "return": {"value": "{1}", "type": "set"}}, {"args": [{"name": "formula", "value": "[(1, []), (2, []), (3, [1, 2]), (3, [5]), (4, [1, 3, 3, 3]), (5, [1, 1, 6])]", "type": "list"}], "return": {"value": "{1, 2, 3, 4}", "type": "set"}}, {"args": [{"name": "formula", "value": "[(1, [1, 2]), (2, [])]", "type": "list"}], "return": {"value": "{2}", "type": "set"}}, {"args": [{"name": "formula", "value": "[(1, []), (2, []), (3, [1, 2]), (3, [5]), (4, [1, 3, 3, 3]), (5, [1, 1, 6]), (None, [1, 3])]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "formula", "value": "[(1, [2, 2]), (2, [])]", "type": "list"}], "return": {"value": "{1, 2}", "type": "set"}}]}, {"name": "read", "description": " reads a Horn SAT formula from a text file\n\n    :file format:\n        # comment\n        A     # clause with unique positive literal\n        :- A  # clause with unique negative literal\n        A :- B, C, D # clause where A is positive and B,C,D negative\n        # variables are strings without spaces\n    "}], "classes": []}, "FR": {"name": "horn_sat", "description": "La r\u00e9solution de la Corne SAT\n\nchristoph d\u00fcrr - 2016-2019\n\nles clauses sont num\u00e9rot\u00e9s \u00e0 partir de 0\nles variables sont des cha\u00eenes de caract\u00e8res (identificateur)\n\nsolution : ensemble de variables qui sont d\u00e9finies sur true\nposvar_in_clause : cartes clause positive unique variable dans la clause\n(ou Aucun)\nclause_with_negvar : cartes variable v \u00e0 toutes les clauses qui en contiennent pas(v)\n\nchaque clause a un score: nombre de ses n\u00e9gatifs variables\nqui ne sont pas dans la solution de sol\npiscine : les cartes de score pour les clauses de ce score\n", "functions": [{"name": "horn_sat", "description": " La r\u00e9solution d'une CORNE Sat formule\n\n:param formule: liste de couple(posvar, negvars).\nnegvars est une liste des n\u00e9gatifs variables (peut \u00eatre vide)\nposvar est le positif de la variable (peut-\u00eatre Aucun)\nLes Variables peuvent \u00eatre tout hashable objets: les entiers, les cha\u00eenes de...\n:r\u00e9sultat: Aucun si la formule n'est pas satisfaisante, sinon un ensemble minimal de vars\nqui doivent \u00eatre mis \u00e0 true afin de satisfaire \u00e0 la formule.\n:complexit\u00e9: lin\u00e9aire\n"}, {"name": "lire", "description": " lit une Corne SAT formule \u00e0 partir d'un fichier texte\n\nformat de fichier :\n# commentaire\nUn # clause positive unique litt\u00e9rale\n:- Un # clause unique litt\u00e9ral n\u00e9gatif\nA :- B, C, D # clause o\u00f9 A est positif et B,C,D n\u00e9gatif\n# les variables sont des cha\u00eenes de caract\u00e8res sans les espaces\n"}], "classes": []}}, {"EN": {"name": "three_partition", "description": "subsetsum\njill-j\u00eann vie et christoph d\u00fcrr - 2015-2019\n", "functions": [{"name": "three_partition", "description": "partition a set of integers in 3 parts of same total value\n\n    :param x: table of non negative values\n    :returns: triplet of the integers encoding the sets, or None otherwise\n    :complexity: :math:`O(2^{2n})`\n    ", "examples": [{"args": [{"name": "x", "value": "[5, 5, 3, 2]", "type": "list"}], "return": {"value": "(1, 2, 12)", "type": "tuple"}}, {"args": [{"name": "x", "value": "[1, 4, 5, 3, 2]", "type": "list"}], "return": {"value": "(3, 4, 24)", "type": "tuple"}}, {"args": [{"name": "x", "value": "[10, 2, 3]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}]}], "classes": []}, "FR": {"name": "three_partition", "description": "subsetsum\njill-j\u00eann vie et christoph d\u00fcrr - 2015-2019\n", "functions": [{"name": "three_partition", "description": "partition d'un ensemble d'entiers dans 3 pi\u00e8ces de m\u00eame valeur\n\n:param x: tableau des non valeurs n\u00e9gatives\n:retourne: triplet de nombres entiers codage des ensembles, ou nul sinon\n:complexit\u00e9: :math:`O(2^{2n})`\n"}], "classes": []}}, {"EN": {"name": "gale_shapley", "description": "Stable matching by Gale-Shapley\njill-j\u00eann vie et christoph durr - 2014-2019\n", "functions": [{"name": "gale_shapley", "description": "Stable matching by Gale-Shapley\n\n    :param men: table of size n, men[i] is preference list of women for men i\n    :param women: similar\n    :returns: matching table, from women to men\n    :complexity: :math:`O(n^2)`\n    ", "examples": [{"args": [{"name": "men", "value": "[[0, 1, 2], [2, 1, 0], [0, 2, 1]]", "type": "list"}, {"name": "women", "value": "[[0, 1, 2], [1, 2, 0], [1, 2, 0]]", "type": "list"}], "return": {"value": "[0, 2, 1]", "type": "list"}}]}], "classes": []}, "FR": {"name": "gale_shapley", "description": "Stable correspondant par Gale-Shapley\njill-j\u00eann vie et christoph durr - 2014-2019\n", "functions": [{"name": "gale_shapley", "description": "Stable correspondant par Gale-Shapley\n\n:param hommes: le tableau de taille n, les hommes[i] est la liste de pr\u00e9f\u00e9rence des femmes pour les hommes, je\n:param femmes: similaires\n:retourne: table de correspondance, de femmes et d'hommes\n:complexit\u00e9: :math:`O(n^2)`\n"}], "classes": []}}, {"EN": {"name": "dilworth", "description": "Decompose DAG into a minimum number of chains\njill-jenn vie et christoph durr - 2015-2018\n", "functions": [{"name": "dilworth", "description": "Decompose a DAG into a minimum number of chains by Dilworth\n\n    :param graph: directed graph in listlist or listdict format\n    :assumes: graph is acyclic\n    :returns: table giving for each vertex the number of its chains\n    :complexity: same as matching\n    ", "examples": [{"args": [{"name": "graph", "value": "[[1], [2, 3, 5], [6, 7], [7, 8], [5, 6], [8], [8], [], []]", "type": "list"}], "return": {"value": "[2, 2, 2, 1, 0, 0, 2, 1, 0]", "type": "list"}}, {"args": [{"name": "graph", "value": "[{1: None}, {2: None, 3: None, 5: None}, {6: None, 7: None}, {7: None, 8: None}, {5: None, 6: None}, {8: None}, {8: None}, {}, {}]", "type": "list"}], "return": {"value": "[2, 2, 2, 1, 0, 0, 2, 1, 0]", "type": "list"}}]}], "classes": []}, "FR": {"name": "dilworth", "description": "D\u00e9composer DAG en un nombre minimum de cha\u00eenes\njill-jenn vie et christoph durr - 2015-2018\n", "functions": [{"name": "dilworth", "description": "D\u00e9composer un DAG en un nombre minimum de cha\u00eenes par Dilworth\n\n:param graphe: graphe orient\u00e9 dans listlist ou listdict format\n:suppose: graphe est acyclique\n:retourne: tableau donnant pour chaque sommet le nombre de ses cha\u00eenes\n:complexit\u00e9: le m\u00eame en respectant\n"}], "classes": []}}, {"EN": {"name": "longest_increasing_subsequence", "description": "Longest increasing subsequence\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "longest_increasing_subsequence", "description": "Longest increasing subsequence\n\n    :param x: sequence\n    :returns: longest strictly increasing subsequence y\n    :complexity: `O(|x|*log(|y|))`\n    ", "examples": [{"args": [{"name": "x", "value": "[0, 2, 4, 6, 8]", "type": "list"}], "return": {"value": "[0, 2, 4, 6, 8]", "type": "list"}}, {"args": [{"name": "x", "value": "[0, 2, 4, 6, 8, 0, 2, 4, 6, 8]", "type": "list"}], "return": {"value": "[0, 2, 4, 6, 8]", "type": "list"}}, {"args": [{"name": "x", "value": "[8, 6, 4, 2, 0]", "type": "list"}], "return": {"value": "[0]", "type": "list"}}, {"args": [{"name": "x", "value": "[]", "type": "list"}], "return": {"value": "[]", "type": "list"}}, {"args": [{"name": "x", "value": "[7]", "type": "list"}], "return": {"value": "[7]", "type": "list"}}, {"args": [{"name": "x", "value": "[-2, 4, 4]", "type": "list"}], "return": {"value": "[-2, 4]", "type": "list"}}, {"args": [{"name": "x", "value": "[4, 4, -2]", "type": "list"}], "return": {"value": "[-2]", "type": "list"}}, {"args": [{"name": "x", "value": "[3, 1, 4, 1, 5, 9, 2, 6, 5, 4, 5, 3, 9, 7, 9]", "type": "list"}], "return": {"value": "[1, 2, 4, 5, 7, 9]", "type": "list"}}]}], "classes": []}, "FR": {"name": "longest_increasing_subsequence", "description": "Plus longue sous-suite croissante\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "longest_increasing_subsequence", "description": "Plus longue sous-suite croissante\n\n:param x: s\u00e9quence\n:retourne: la plus longue sous-suite strictement croissante y\n:complexit\u00e9: O(|x|*log(|y|))`\n"}], "classes": []}}, {"EN": {"name": "graph", "description": "Reading graphs from files and writing into files\njill-j\u00eann vie et christoph d\u00fcrr - 2015-2019\n", "functions": [{"name": "add_reverse_arcs", "description": "Utility function for flow algorithms that need for every arc (u,v),\n    the existence of an (v,u) arc, by default with zero capacity.\n    graph can be in adjacency list, possibly with capacity matrix capac.\n    or graph can be in adjacency dictionary, then capac parameter is ignored.\n\n    :param capac: arc capacity matrix\n    :param graph: in listlist representation, or in listdict representation,\n    in this case capac is ignored\n    :complexity: linear\n    :returns: nothing, but graph is modified\n    ", "examples": [{"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1}, {4: 1}, {5: 9}, {5: 9}, {}]", "type": "list"}, {"name": "capac", "value": "[{1: 9, 2: 9}, {3: 1}, {4: 1}, {5: 9}, {5: 9}, {}]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capac", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}]}, {"name": "dictdict_to_listdict", "description": "Transforms a dict-dict graph representation into a\n    adjacency dictionary representation (list-dict)\n\n    :param dictgraph: dictionary mapping vertices to dictionary\n           such that dictgraph[u][v] is weight of arc (u,v)\n    :complexity: linear\n    :returns: tuple with graph (listdict), name_to_node (dict),\n    node_to_name (list)\n    ", "examples": [{"args": [{"name": "dictgraph", "value": "{'A': {'B': 7}, 'B': {'A': 6, 'B': 1, 'C': 0, 'D': -1}, 'C': {}, 'D': {'C': 8}}", "type": "dict"}], "return": {"value": "([{1: 7}, {0: 6, 1: 1, 2: 0, 3: -1}, {}, {2: 8}], {'A': 0, 'B': 1, 'C': 2, 'D': 3}, ['A', 'B', 'C', 'D'])", "type": "tuple"}}]}, {"name": "extract_path", "description": "extracts a path in form of vertex list from source to vertex v\n       given a precedence table prec leading to the source\n\n    :param prec: precedence table of a tree\n    :param v: vertex on the tree\n    :returns: path from root to v, in form of a list\n    :complexity: linear\n    ", "examples": [{"args": [{"name": "prec", "value": "[None, 0, 1, None, None, 2, None, None, 5]", "type": "list"}, {"name": "v", "value": "8", "type": "int"}], "return": {"value": "[0, 1, 2, 5, 8]", "type": "list"}}, {"args": [{"name": "prec", "value": "[None]", "type": "list"}, {"name": "v", "value": "0", "type": "int"}], "return": {"value": "[0]", "type": "list"}}, {"args": [{"name": "prec", "value": "[None, 0]", "type": "list"}, {"name": "v", "value": "1", "type": "int"}], "return": {"value": "[0, 1]", "type": "list"}}, {"args": [{"name": "prec", "value": "[None, 0, 1, None, 5, 2, None, None, 5]", "type": "list"}, {"name": "v", "value": "8", "type": "int"}], "return": {"value": "[0, 1, 2, 5, 8]", "type": "list"}}, {"args": [{"name": "prec", "value": "[None, None]", "type": "list"}, {"name": "v", "value": "1", "type": "int"}], "return": {"value": "[1]", "type": "list"}}, {"args": [{"name": "prec", "value": "[None, 0, 1, 0, 7, 4, 3, 6, 5]", "type": "list"}, {"name": "v", "value": "8", "type": "int"}], "return": {"value": "[0, 3, 6, 7, 4, 5, 8]", "type": "list"}}]}, {"name": "listdict_to_listlist_and_matrix", "description": "Transforms the adjacency list representation of a graph\n    of type listdict into the listlist + weight matrix representation\n\n    :param sparse: graph in listdict representation\n    :returns: couple with listlist representation, and weight matrix\n    :complexity: linear\n    ", "examples": [{"args": [{"name": "sparse", "value": "[{1: 7}, {0: 6, 1: 1, 2: 0, 3: -1}, {}, {2: 8}]", "type": "list"}], "return": {"value": "([[1], [0, 1, 2, 3], [], [2]], [[None, 7, None, None], [6, 1, 0, -1], [None, None, None, None], [None, None, 8, None]])", "type": "tuple"}}, {"args": [{"name": "sparse", "value": "[{1: 11, 2: 13, 3: 12}, {0: 11, 3: 14}, {0: 13, 3: 10}, {0: 12, 1: 14, 2: 10}]", "type": "list"}], "return": {"value": "([[1, 2, 3], [0, 3], [0, 3], [0, 1, 2]], [[None, 11, 13, 12], [11, None, None, 14], [13, None, None, 10], [12, 14, 10, None]])", "type": "tuple"}}]}, {"name": "listlist_and_matrix_to_listdict", "description": "Transforms the weighted adjacency list representation of a graph\n    of type listlist + optional weight matrix\n    into the listdict representation\n\n    :param graph: in listlist representation\n    :param weight: optional weight matrix\n    :returns: graph in listdict representation\n    :complexity: linear\n    ", "examples": [{"args": [{"name": "graph", "value": "[[]]", "type": "list"}, {"name": "weight", "value": "[[None]]", "type": "list"}], "return": {"value": "[{}]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1], []]", "type": "list"}, {"name": "weight", "value": "[[None, -3], [None, None]]", "type": "list"}], "return": {"value": "[{1: -3}, {}]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[], []]", "type": "list"}, {"name": "weight", "value": "[[None, None], [None, None]]", "type": "list"}], "return": {"value": "[{}, {}]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[0, 1], [0, 1]]", "type": "list"}, {"name": "weight", "value": "[[2, 3], [3, -1]]", "type": "list"}], "return": {"value": "[{0: 2, 1: 3}, {0: 3, 1: -1}]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1, 2, 3, 4, 5, 6], [0, 2, 3, 4, 5, 6], [0, 1, 3, 4, 5, 6], [0, 1, 2, 4, 5, 6], [0, 1, 2, 3, 5, 6], [0, 1, 2, 3, 4, 6], [0, 1, 2, 3, 4, 5], []]", "type": "list"}, {"name": "weight", "value": "None", "type": "NoneType"}], "return": {"value": "[{1: None, 2: None, 3: None, 4: None, 5: None, 6: None}, {0: None, 2: None, 3: None, 4: None, 5: None, 6: None}, {0: None, 1: None, 3: None, 4: None, 5: None, 6: None}, {0: None, 1: None, 2: None, 4: None, 5: None, 6: None}, {0: None, 1: None, 2: None, 3: None, 5: None, 6: None}, {0: None, 1: None, 2: None, 3: None, 4: None, 6: None}, {0: None, 1: None, 2: None, 3: None, 4: None, 5: None}, {}]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[], [2, 3], [4, 5, 1], [6, 7, 1], [8, 9, 2], [10, 11, 2], [12, 13, 3], [14, 15, 3], [4], [4], [5], [5], [6], [6], [7], [7]]", "type": "list"}, {"name": "weight", "value": "None", "type": "NoneType"}], "return": {"value": "[{}, {2: None, 3: None}, {4: None, 5: None, 1: None}, {6: None, 7: None, 1: None}, {8: None, 9: None, 2: None}, {10: None, 11: None, 2: None}, {12: None, 13: None, 3: None}, {14: None, 15: None, 3: None}, {4: None}, {4: None}, {5: None}, {5: None}, {6: None}, {6: None}, {7: None}, {7: None}]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[]]", "type": "list"}, {"name": "weight", "value": "None", "type": "NoneType"}], "return": {"value": "[{}]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[], []]", "type": "list"}, {"name": "weight", "value": "None", "type": "NoneType"}], "return": {"value": "[{}, {}]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1], [0]]", "type": "list"}, {"name": "weight", "value": "None", "type": "NoneType"}], "return": {"value": "[{1: None}, {0: None}]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1], []]", "type": "list"}, {"name": "weight", "value": "None", "type": "NoneType"}], "return": {"value": "[{1: None}, {}]", "type": "list"}}]}, {"name": "make_flow_labels", "description": "Generate arc labels for a flow in a graph with capacities.\n\n    :param graph: adjacency list or adjacency dictionary\n    :param flow:  flow matrix or adjacency dictionary\n    :param capac: capacity matrix or adjacency dictionary\n    :returns: listdic graph representation, with the arc label strings\n    "}, {"name": "matrix_to_listlist", "description": "transforms a squared weight matrix in a adjacency table of type listlist\n    encoding the directed graph corresponding to the entries of the matrix\n    different from None\n\n    :param weight: squared weight matrix, weight[u][v] != None iff arc (u, v)\n    exists\n    :complexity: linear\n    :returns: the unweighted directed graph in the listlist representation,\n                       listlist[u] contains all v for which arc (u,v) exists.\n    ", "examples": [{"args": [{"name": "weight", "value": "[[None, 7, None, None], [6, 1, 0, -1], [None, None, None, None], [None, None, 8, None]]", "type": "list"}], "return": {"value": "[[1], [0, 1, 2, 3], [], [2]]", "type": "list"}}, {"args": [{"name": "weight", "value": "[[None, -5, None, None], [None, None, -3, 0], [9, None, None, 2], [7, 0, -1, None]]", "type": "list"}], "return": {"value": "[[1], [2, 3], [0, 3], [0, 1, 2]]", "type": "list"}}, {"args": [{"name": "weight", "value": "[[None, 10, None], [None, -2, None], [None, None, -20]]", "type": "list"}], "return": {"value": "[[1], [1], [2]]", "type": "list"}}, {"args": [{"name": "weight", "value": "[[None, 10, 10], [None, -8, -8], [None, -8, -8]]", "type": "list"}], "return": {"value": "[[1, 2], [1, 2], [1, 2]]", "type": "list"}}, {"args": [{"name": "weight", "value": "[[None, None], [0, -4]]", "type": "list"}], "return": {"value": "[[], [0, 1]]", "type": "list"}}]}, {"name": "read_graph", "description": "Read a graph from a text file\n\n    :param filename: plain text file. All numbers are separated by space.\n              Starts with a line containing n (#vertices) and m (#edges).\n              Then m lines follow, for each edge.\n              Vertices are numbered from 0 to n-1.\n              Line for unweighted edge u,v contains two integers u, v.\n              Line for weighted edge u,v contains three integers u, v, w[u,v].\n\n    :param directed: true for a directed graph, false for undirected\n    :param weighted: true for an edge weighted graph\n    :returns: graph in listlist format, possibly followed by weight matrix\n    :complexity: O(n + m) for unweighted graph,\n                 :math:`O(n^2)` for weighted graph\n    "}, {"name": "readtab", "description": "Reads a line from file with a space separated list\n       of items of type ty\n\n    :param file: input stream, for example sys.stdin\n    :param ty: a type, for example int\n    :returns: a tuple with elements of type ty\n    "}, {"name": "readval", "description": "Reads a line from file with an item of type ty\n\n    :param file: input stream, for example sys.stdin\n    :param ty: a type, for example int\n    :returns: an element of type ty\n    "}, {"name": "tree_adj_to_prec", "description": "Transforms a tree given as adjacency list into predecessor table form.\n    if graph is not a tree: will return a DFS spanning tree\n\n    :param graph: directed graph in listlist or listdict format\n    :returns: tree in predecessor table representation\n    :complexity: linear\n    ", "examples": [{"args": [{"name": "graph", "value": "[[1], [0, 2, 9], [1, 3, 5], [2, 4], [3], [2, 6, 7, 8], [5], [5], [5], [1]]", "type": "list"}, {"name": "root", "value": "0", "type": "int"}], "return": {"value": "[None, 0, 1, 2, 3, 2, 5, 5, 5, 1]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1, 2], [0, 2], [0, 1]]", "type": "list"}, {"name": "root", "value": "0", "type": "int"}], "return": {"value": "[None, 0, 0]", "type": "list"}}]}, {"name": "tree_prec_to_adj", "description": "Transforms a tree given as predecessor table into adjacency list form\n\n    :param prec: predecessor table representing a tree, prec[u] == v iff u is\n    successor of v,\n                 except for the root where prec[root] == root\n    :param root: root vertex of the tree\n    :returns: undirected graph in listlist representation\n    :complexity: linear\n    ", "examples": [{"args": [{"name": "prec", "value": "[None, 0, 1, 2, 3, 2, 5, 5, 5, 1]", "type": "list"}, {"name": "root", "value": "0", "type": "int"}], "return": {"value": "[[1], [0, 2, 9], [1, 3, 5], [2, 4], [3], [2, 6, 7, 8], [5], [5], [5], [1]]", "type": "list"}}]}, {"name": "write_graph", "description": "Writes a graph to a file in the DOT format\n\n    :param dotfile: the filename.\n    :param graph: directed graph in listlist or listdict format\n    :param directed: true if graph is directed, false if undirected\n    :param weight: in matrix format or same listdict graph or None\n    :param node_label: vertex label table or None\n    :param arc_label: arc label matrix or None\n    :param comment: comment string for the dot file or None\n    :param node_mark: set of nodes to be shown in gray\n    :param arc_marc: set of arcs to be shown in red\n    :complexity: `O(|V| + |E|)`\n    "}], "classes": [{"name": "Graph", "description": null, "methods": [{"name": "__getitem__", "description": null}, {"name": "__init__", "description": null}, {"name": "__len__", "description": null}, {"name": "add_arc", "description": null}, {"name": "add_edge", "description": null}, {"name": "add_node", "description": null}]}]}, "FR": {"name": "graphique", "description": "La lecture des graphiques \u00e0 partir de fichiers et de l'\u00e9criture dans les fichiers\njill-j\u00eann vie et christoph d\u00fcrr - 2015-2019\n", "functions": [{"name": "add_reverse_arcs", "description": "La fonction d'utilit\u00e9 pour l'\u00e9coulement des algorithmes de n\u00e9cessit\u00e9, pour chaque arc (u,v),\nl'existence d'un (v,u) de l'arc, par d\u00e9faut \u00e0 z\u00e9ro de la capacit\u00e9.\nle graphique peut \u00eatre dans la liste d'adjacence, \u00e9ventuellement avec la capacit\u00e9 de la matrice de la capac.\nou graphique peut \u00eatre dans la contigu\u00eft\u00e9 dictionnaire, puis capac param\u00e8tre est ignor\u00e9.\n\n:param capac: arc de la capacit\u00e9 de la matrice\n:param graphique: listlist repr\u00e9sentation, ou dans listdict repr\u00e9sentation,\ndans ce cas, la capac est ignor\u00e9\n:complexit\u00e9: lin\u00e9aire\n:retourne: rien du tout, mais le graphique est modifi\u00e9\n"}, {"name": "dictdict_to_listdict", "description": "Transforme un dict-dict repr\u00e9sentation graphique dans un\nla contigu\u00eft\u00e9 dictionnaire de la repr\u00e9sentation (liste-dict)\n\n:param dictgraph: dictionnaire de la cartographie des sommets de dictionnaire\ntels que dictgraph[u][v] est le poids de l'arc (u,v)\n:complexit\u00e9: lin\u00e9aire\n:retourne: tuple avec le graphique (listdict), name_to_node (dict),\nnode_to_name (liste)\n"}, {"name": "extract_path", "description": "extraits d'un chemin en forme de sommet de la liste de la source au sommet v\n\u00e9tant donn\u00e9 un tableau de pr\u00e9c\u00e9dence prec menant \u00e0 la source\n\n:param prec: tableau de pr\u00e9c\u00e9dence d'un arbre\n:param v: sommet sur l'arbre\n:retourne: chemin de la racine \u00e0 la v, sous la forme d'une liste\n:complexit\u00e9: lin\u00e9aire\n"}, {"name": "listdict_to_listlist_and_matrix", "description": "Transforme la repr\u00e9sentation des listes d'adjacence d'un graphe\nde type listdict dans le listlist + poids de la matrice de la repr\u00e9sentation\n\n:param \u00e9parses: graphique de la repr\u00e9sentation listdict\n:retourne: un couple avec listlist repr\u00e9sentation, et de la matrice de poids\n:complexit\u00e9: lin\u00e9aire\n"}, {"name": "listlist_and_matrix_to_listdict", "description": "Transforme le pond\u00e9r\u00e9e de la repr\u00e9sentation des listes d'adjacence d'un graphe\nde type listlist + en option matrice de poids\ndans le listdict repr\u00e9sentation\n\n:param graphique: repr\u00e9sentation listlist\n:param poids: option matrice de poids\n:retourne: graphique de la repr\u00e9sentation listdict\n:complexit\u00e9: lin\u00e9aire\n"}, {"name": "make_flow_labels", "description": "G\u00e9n\u00e9rer arc \u00e9tiquettes pour un \u00e9coulement dans un graphe avec des capacit\u00e9s.\n\n:param graphique: liste d'adjacence ou de contigu\u00eft\u00e9 dictionnaire\n:param flux: matrice de flux ou de contigu\u00eft\u00e9 dictionnaire\n:param capac: capacit\u00e9 ou de matrice d'adjacence dictionnaire\n:retourne: listdic repr\u00e9sentation graphique, avec l'arc de l'\u00e9tiquette de cha\u00eenes\n"}, {"name": "matrix_to_listlist", "description": "transforme un carr\u00e9 de la matrice de poids dans une contigu\u00eft\u00e9 de table de type listlist\nle codage du graphe orient\u00e9 correspondant aux entr\u00e9es de la matrice\ndiff\u00e9rent de None\n\n:param poids: carr\u00e9 de la matrice de poids, de poids[u][v] != Aucun forum de l'arc (u, v)\nexiste\n:complexit\u00e9: lin\u00e9aire\n:r\u00e9sultat: non pond\u00e9r\u00e9es des graphes orient\u00e9s dans le listlist repr\u00e9sentation,\nlistlist[u] contient tous les v pour laquelle l'arc (u,v) existe.\n"}, {"name": "read_graph", "description": "Lire un graphique \u00e0 partir d'un fichier texte\n\n:param nom de fichier: fichier de texte brut. Tous les num\u00e9ros sont s\u00e9par\u00e9s par un espace.\nCommence par une ligne contenant n (#sommets) et m (#bords).\nAlors m des lignes de suivre, pour chaque bord.\nLes sommets sont num\u00e9rot\u00e9s de 0 \u00e0 n-1.\nLigne pour non pond\u00e9r\u00e9e bord u,v contient deux entiers u, v.\nLigne pour pond\u00e9r\u00e9e bord u,v contient trois nombres entiers u, v, w[u,v].\n\n:param dirig\u00e9: true pour un graphe orient\u00e9, false pour les non-orient\u00e9\n:param pond\u00e9r\u00e9e: true pour un bord pond\u00e9r\u00e9e graphique\n:retourne: graphique en listlist format, qui peut \u00eatre suivi par la matrice de poids\n:complexit\u00e9: O(n + m) pour les non pond\u00e9r\u00e9e graphique,\n:math:`O(n^2)` pour pond\u00e9r\u00e9e graphique\n"}, {"name": "readtab", "description": "Lit une ligne depuis un fichier avec une liste s\u00e9par\u00e9e par des espaces\ndes \u00e9l\u00e9ments de type ty\n\n:param fichier: flux d'entr\u00e9e, par exemple sys.stdin\n:param ty: un type, par exemple de type int\n:retourne: un tuple avec des \u00e9l\u00e9ments de type ty\n"}, {"name": "readval", "description": "Lit une ligne depuis un fichier avec un \u00e9l\u00e9ment de type ty\n\n:param fichier: flux d'entr\u00e9e, par exemple sys.stdin\n:param ty: un type, par exemple de type int\n:retourne: un \u00e9l\u00e9ment de type ty\n"}, {"name": "tree_adj_to_prec", "description": "Transforme un arbre donn\u00e9 que la contigu\u00eft\u00e9 de la liste de pr\u00e9d\u00e9cesseur forme de tableau.\nsi le graphique n'est pas un arbre: sera de retour d'un DFS spanning tree\n\n:param graphe: graphe orient\u00e9 dans listlist ou listdict format\n:retourne: arbre pr\u00e9d\u00e9cesseur table repr\u00e9sentation\n:complexit\u00e9: lin\u00e9aire\n"}, {"name": "tree_prec_to_adj", "description": "Transforme un arbre donn\u00e9 en tant que pr\u00e9d\u00e9cesseur de table en forme de liste d'adjacence\n\n:param prec: pr\u00e9d\u00e9cesseur tableau repr\u00e9sentant un arbre, prec[u] == v ssi u est\nsuccesseur de v,\nsauf pour la racine o\u00f9 prec[root] == root\n:param root: root sommet de l'arbre\n:retourne: graphes non orient\u00e9s dans listlist repr\u00e9sentation\n:complexit\u00e9: lin\u00e9aire\n"}, {"name": "write_graph", "description": "\u00c9crit un graphique vers un fichier au format DOT\n\n:param dotfile: le nom de fichier.\n:param graphe: graphe orient\u00e9 dans listlist ou listdict format\n:param dirig\u00e9: true si le graphe est orient\u00e9, false si non orient\u00e9\n:param poids: dans un format de matrice ou m\u00eame listdict graphique ou Aucun\n:param node_label: sommet de l'\u00e9tiquette de table ou Aucun\n:param arc_label: arc \u00e9tiquette de la matrice ou Aucun\n:param commentaire: cha\u00eene de commentaire pour la dot de fichier ou Aucun\n:param node_mark: ensemble de n\u0153uds pour \u00eatre affich\u00e9es en gris\n:param arc_marc: ensemble d'arcs \u00e0 \u00eatre montr\u00e9 en rouge\n:complexit\u00e9: O(|V| + |E|)`\n"}], "classes": [{"name": "Graphique", "description": null, "methods": [{"name": "__getitem__", "description": null}, {"name": "__init__", "description": null}, {"name": "__len__", "description": null}, {"name": "add_arc", "description": null}, {"name": "add_edge", "description": null}, {"name": "add_node", "description": null}]}]}}, {"EN": {"name": "next_permutation", "description": "Next permutation\nprochaine permuation\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "convert", "description": "\n    solves a cryptogram in the style SEND + MORE = MONEY\n    "}, {"name": "next_permutation", "description": "find the next permutation of tab in the lexicographical order\n\n    :param tab: table with n elements from an ordered set\n    :modifies: table to next permutation\n    :returns: False if permutation is already lexicographical maximal\n    :complexity: O(n)\n    ", "examples": [{"args": [{"name": "tab", "value": "[2, 2, 0, 0, 1, 1, 0]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "tab", "value": "[2, 2, 1, 1, 0, 0, 0]", "type": "list"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "tab", "value": "[2]", "type": "list"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "tab", "value": "[]", "type": "list"}], "return": {"value": "False", "type": "bool"}}]}, {"name": "solve_word_addition", "description": "returns number of solutions"}], "classes": []}, "FR": {"name": "next_permutation", "description": "Prochaine permutation\nprochaine permuation\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "convertir", "description": "\nr\u00e9sout un cryptogramme dans le style SEND + MORE = MONEY\n"}, {"name": "next_permutation", "description": "trouver la prochaine permutation de l'onglet dans l'ordre lexicographique\n\n:onglet param\u00e8tres: tableau \u00e0 n \u00e9l\u00e9ments d'un ensemble ordonn\u00e9\n:modifie: table \u00e0 c\u00f4t\u00e9 de permutation\n:retourne False si la permutation est d\u00e9j\u00e0 lexicographiques maximale\n:complexit\u00e9: O(n)\n"}, {"name": "solve_word_addition", "description": "retourne le nombre de solutions"}], "classes": []}}, {"EN": {"name": "gauss_jordan", "description": "Linear equation system Ax=b by Gauss-Jordan\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "diagonalize", "description": "diagonalize ", "examples": [{"args": [{"name": "S", "value": "[[3, 2, -1, 1], [2, -2, 4, -2], [-1, 0.5, -1, 0], [0, 1, 2]]", "type": "list"}, {"name": "n", "value": "3", "type": "int"}, {"name": "m", "value": "3", "type": "int"}], "return": {"value": "3", "type": "int"}}, {"args": [{"name": "S", "value": "[[3, 2, 6], [6, 4, 12], [0, 1]]", "type": "list"}, {"name": "n", "value": "2", "type": "int"}, {"name": "m", "value": "2", "type": "int"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "S", "value": "[[1, -2, -1], [3, 5, 8], [4, 3, 7], [0, 1]]", "type": "list"}, {"name": "n", "value": "2", "type": "int"}, {"name": "m", "value": "3", "type": "int"}], "return": {"value": "2", "type": "int"}}, {"args": [{"name": "S", "value": "[[3, 2, 6], [3, 2, 12], [0, 1]]", "type": "list"}, {"name": "n", "value": "2", "type": "int"}, {"name": "m", "value": "2", "type": "int"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "S", "value": "[[1, 1, 1], [2, 1, 1], [3, 2, 3], [0, 1]]", "type": "list"}, {"name": "n", "value": "2", "type": "int"}, {"name": "m", "value": "3", "type": "int"}], "return": {"value": "2", "type": "int"}}]}, {"name": "gauss_jordan", "description": "Linear equation system Ax=b by Gauss-Jordan\n\n    :param A: n by m matrix\n    :param x: table of size n\n    :param b: table of size m\n    :modifies: x will contain solution if any\n    :returns int:\n          0 if no solution,\n          1 if solution unique,\n          2 otherwise\n    :complexity: :math:`O(n^2m)`\n    ", "examples": [{"args": [{"name": "A", "value": "[[3, 2, -1], [2, -2, 4], [-1, 0.5, -1]]", "type": "list"}, {"name": "x", "value": "[0, 0, 0]", "type": "list"}, {"name": "b", "value": "[1, -2, 0]", "type": "list"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "A", "value": "[[3, 2], [6, 4]]", "type": "list"}, {"name": "x", "value": "[0, 0]", "type": "list"}, {"name": "b", "value": "[6, 12]", "type": "list"}], "return": {"value": "2", "type": "int"}}, {"args": [{"name": "A", "value": "[[1, -2], [3, 5], [4, 3]]", "type": "list"}, {"name": "x", "value": "[2.0, 0]", "type": "list"}, {"name": "b", "value": "[-1, 8, 7]", "type": "list"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "A", "value": "[[3, 2], [3, 2]]", "type": "list"}, {"name": "x", "value": "[0.9999999999999996, 1.0000000000000004]", "type": "list"}, {"name": "b", "value": "[6, 12]", "type": "list"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "A", "value": "[[1, 1], [2, 1], [3, 2]]", "type": "list"}, {"name": "x", "value": "[0.9999999999999996, 1.0000000000000004]", "type": "list"}, {"name": "b", "value": "[1, 1, 3]", "type": "list"}], "return": {"value": "0", "type": "int"}}]}, {"name": "is_zero", "description": "error tolerant zero test\n    ", "examples": [{"args": [{"name": "x", "value": "4", "type": "int"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "x", "value": "3.5", "type": "float"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "x", "value": "0.21428571428571427", "type": "float"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "x", "value": "6", "type": "int"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "x", "value": "0.0", "type": "float"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "x", "value": "5", "type": "int"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "x", "value": "2.2", "type": "float"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "x", "value": "8.881784197001252e-16", "type": "float"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "x", "value": "3", "type": "int"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "x", "value": "-6.0", "type": "float"}], "return": {"value": "False", "type": "bool"}}]}], "classes": []}, "FR": {"name": "gauss_jordan", "description": "\u00c9quation lin\u00e9aire du syst\u00e8me Ax=b par Gauss-Jordan\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "diagonalize", "description": "diagonalize "}, {"name": "gauss_jordan", "description": "\u00c9quation lin\u00e9aire du syst\u00e8me Ax=b par Gauss-Jordan\n\n:param A: n par m la matrice\n:param x: tableau de taille n\n:param b: tableau de taille m\n:modifie: x contiendra solution si tout\n:renvoie int:\n0 si pas de solution,\n1 si la solution unique,\n2 dans le cas contraire\n:complexit\u00e9: :math:`O(n^2 m)`\n"}, {"name": "is_zero", "description": "erreur \u00e0 tol\u00e9rance z\u00e9ro test\n"}], "classes": []}}, {"EN": {"name": "range_minimum_query", "description": "Range minimum query\nMinimum d'une plage --- range minimum query\njill-jenn vie et christoph durr - 2014-2019\n", "functions": [], "classes": [{"name": "LazySegmentTree", "description": "maintains a tree to allow quick updates and queries on a table.\n\n    This is more general than a Fenwick tree or a tree for MinRangeQuery. Here\n    queries and updates act on index ranges. Updates can be set a range to a\n    value or add a value to a range. Queries can be max, min and sum over an\n    index range. All operations run in time O(log n) for a the table size n.\n    The given ranges are in the form [i,j] where i is included and j excluded.\n    In the recursive calls, node is the index of a node in the tree, and left,\n    right its range. Values can be any numerical values allowing max, min, and\n    sum, such as integers, floating point numbers or fractions (from the class\n    Fraction). Updates over an empty range is valid and does nothing. Queries\n    over an empty range is valid and returns the neutral value -inf, +inf or\n    0.\n\n    If the node is cleared, then maxval, minval, sumval represent for each\n    node the query responses over the corresponding index ranges.  If the node\n    is not clean, it means that lazyset and/or lazyadd contain suspendet\n    update instructions for that node. Clearing a node means propagating these\n    values to the descents in the subtrees, and updating maxval,minval and\n    sumval for that node.\n    ", "methods": [{"name": "__init__", "description": "stores an integer table tab.\n        will be padded to get a table with a size of a power of 2.\n\n        :param array tab: of positive length\n        "}, {"name": "_add", "description": null}, {"name": "_clear", "description": "propagates the lazy updates for this node to the subtrees.\n        as a result the maxval, minval, sumval values for the node\n        are up to date.\n        "}, {"name": "_dump", "description": null}, {"name": "_maintain", "description": "maintains the invariant for the given node\n        :promize: the lazy values are None/0 for this node\n        "}, {"name": "_max", "description": null}, {"name": "_min", "description": null}, {"name": "_set", "description": null}, {"name": "_sum", "description": null}, {"name": "add", "description": null}, {"name": "max", "description": null}, {"name": "min", "description": null}, {"name": "set", "description": null}, {"name": "sum", "description": null}]}, {"name": "RangeMinQuery", "description": "Range minimum query\n\n    maintains a table t, can read/write items t[i],\n    and query range_min(i,k) = min{ t[i], t[i + 1], ..., t[k - 1]}\n    :complexity: all operations in O(log n), for n = len(t)\n    ", "methods": [{"name": "__getitem__", "description": null}, {"name": "__init__", "description": null}, {"name": "__setitem__", "description": " sets t[i] to v.\n            :complexity: O(log len(t))\n        "}, {"name": "_range_min", "description": "returns the minimum in t in the indexes [i, k) intersected\n           with [start, start + span).\n           p is the node associated to the later interval.\n        "}, {"name": "range_min", "description": ":returns:  min{ t[i], t[i + 1], ..., t[k - 1]}\n        :complexity: O(log len(t))\n        "}]}]}, "FR": {"name": "range_minimum_query", "description": "Le minimum de la plage de la requ\u00eate\nMinimum d'une plage --- le minimum de la plage de la requ\u00eate\njill-jenn vie et christoph durr - 2014-2019\n", "functions": [], "classes": [{"name": "LazySegmentTree", "description": "maintient un arbre pour permettre des mises \u00e0 jour rapides et des requ\u00eates sur une table.\n\nC'est plus g\u00e9n\u00e9ral qu'un Fenwick arbre ou un arbre pour MinRangeQuery. Ici\nles requ\u00eates et mises \u00e0 jour de la loi sur l'indice des plages. Les mises \u00e0 jour peuvent \u00eatre d\u00e9finir une plage pour un\nvaleur ou d'ajouter une valeur \u00e0 une plage. Les requ\u00eates peuvent \u00eatre max, min et somme sur un\nl'indice de gamme. Toutes les op\u00e9rations sont ex\u00e9cut\u00e9es en temps O(log n) pour un tableau de taille n.\nLes plages sont de la forme [i,j] o\u00f9 i est inclus et j exclus.\nDans les appels r\u00e9cursifs, n\u0153ud est l'indice d'un n\u0153ud de l'arbre, et \u00e0 gauche,\ndroit de sa gamme. Les valeurs peuvent \u00eatre des valeurs num\u00e9riques permettant de max, min, et\nsomme, tels que les entiers, les nombres \u00e0 virgule flottante ou fractions (\u00e0 partir de la classe\nFraction). Les mises \u00e0 jour sur un vide gamme est valide et ne fait rien. Les requ\u00eates\nsur un espace de plage est valide et renvoie la valeur neutre -inf, +inf ou\n0.\n\nSi le n\u0153ud est d\u00e9sactiv\u00e9e, puis maxval, minval, sumval repr\u00e9senter, pour chacun\nn\u0153ud de r\u00e9ponses \u00e0 des requ\u00eates sur l'index correspondant plages. Si le n\u0153ud\nn'est pas propre, il signifie que lazyset et/ou lazyadd contenir suspendet\ninstructions de mise \u00e0 jour pour ce n\u0153ud. La compensation d'un n\u0153ud moyens de multiplication de ces\nles valeurs pour les descentes dans les sous-arborescences, et la mise \u00e0 jour maxval,minval et\nsumval pour ce n\u0153ud.\n", "methods": [{"name": "__init__", "description": "contient un entier onglet table.\nsera compl\u00e9t\u00e9e de fa\u00e7on \u00e0 obtenir un tableau avec une taille, d'une puissance de 2.\n\n:param array onglet: positifs de la longueur\n"}, {"name": "_add", "description": null}, {"name": "_clear", "description": "propage les paresseux mises \u00e0 jour pour ce n\u0153ud, de la sous-arbres.\nen cons\u00e9quence, le maxval, minval, sumval valeurs pour le n\u0153ud\nsont \u00e0 jour.\n"}, {"name": "_dump", "description": null}, {"name": "_maintain", "description": "maintient l'invariant pour le noeud donn\u00e9\n:promize: les paresseux, les valeurs sont non/0 pour ce n\u0153ud\n"}, {"name": "_max", "description": null}, {"name": "_min", "description": null}, {"name": "_set", "description": null}, {"name": "_sum", "description": null}, {"name": "ajouter", "description": null}, {"name": "max", "description": null}, {"name": "min", "description": null}, {"name": "ensemble", "description": null}, {"name": "somme", "description": null}]}, {"name": "RangeMinQuery", "description": "Le minimum de la plage de la requ\u00eate\n\nmaintient une table t, peut lire/\u00e9crire les \u00e9l\u00e9ments de t[i],\net la requ\u00eate range_min(i,k) = min{ t[i], t[i + 1], ..., t[k - 1]}\n:complexit\u00e9: toutes les op\u00e9rations en O(log n), pour n = len(t)\n", "methods": [{"name": "__getitem__", "description": null}, {"name": "__init__", "description": null}, {"name": "__setitem__", "description": " jeux de t[i] v.\n:complexit\u00e9: O(log len(t))\n"}, {"name": "_range_min", "description": "renvoie le minimum en t dans les indices [i, k) a recoup\u00e9\navec [start, start + dur\u00e9e).\np est le n\u0153ud associ\u00e9 \u00e0 la fin de l'intervalle.\n"}, {"name": "range_min", "description": ":retourne: min{ t[i], t[i + 1], ..., t[k - 1]}\n:complexit\u00e9: O(log len(t))\n"}]}]}}, {"EN": {"name": "biconnected_components", "description": "bi-connected components, cut vertices and cut cut-nodes\njill-jenn vie, christoph durr et louis abraham - 2015-2019\n", "functions": [{"name": "cut_nodes_edges", "description": "Bi-connected components\n\n    :param graph: undirected graph. in listlist format. Cannot be in listdict\n    format.\n    :returns: a tuple with the list of cut-nodes and the list of cut-edges\n    :complexity: `O(|V|+|E|)`\n    ", "examples": [{"args": [{"name": "graph", "value": "[[1, 2, 5], [0, 5], [0, 3, 4], [2, 4, 5, 6], [2, 3, 5, 6], [0, 1, 3, 4], [3, 4]]", "type": "list"}], "return": {"value": "([], [])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[], [2, 4], [1, 3, 5], [2, 4, 5], [3, 1], [2, 3, 6, 7], [5, 7, 8], [5, 6, 8], [6, 7, 9], [8, 10, 11], [9, 11], [9, 10]]", "type": "list"}], "return": {"value": "([5, 8, 9], [(8, 9)])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[2, 5], [3, 8], [0, 3, 5], [1, 2, 6, 8], [7], [0, 2], [3, 8], [4], [1, 3, 6]]", "type": "list"}], "return": {"value": "([2, 3], [(2, 3), (4, 7)])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[1, 2], [0, 2], [0, 1, 3], [2]]", "type": "list"}], "return": {"value": "([2], [(2, 3)])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[]]", "type": "list"}], "return": {"value": "([], [])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[1, 2], [0], [0]]", "type": "list"}], "return": {"value": "([0], [(0, 1), (0, 2)])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[1], [0]]", "type": "list"}], "return": {"value": "([], [(0, 1)])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[1], [0, 2], [1]]", "type": "list"}], "return": {"value": "([1], [(0, 1), (1, 2)])", "type": "tuple"}}]}, {"name": "cut_nodes_edges2", "description": "Bi-connected components, alternative recursive implementation\n\n    :param graph: undirected graph. in listlist format. Cannot be in listdict\n    format.\n    :assumes: graph has about 5000 vertices at most, otherwise memory limit is\n    reached\n    :returns: a tuple with the list of cut-nodes and the list of cut-edges\n    :complexity: `O(|V|+|E|)` in average, `O(|V|+|E|^2)` in worst case due to\n    use of dictionary\n    ", "examples": [{"args": [{"name": "graph", "value": "[[1, 2, 5], [0, 5], [0, 3, 4], [2, 4, 5, 6], [2, 3, 5, 6], [0, 1, 3, 4], [3, 4]]", "type": "list"}], "return": {"value": "(set(), set())", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[], [2, 4], [1, 3, 5], [2, 4, 5], [3, 1], [2, 3, 6, 7], [5, 7, 8], [5, 6, 8], [6, 7, 9], [8, 10, 11], [9, 11], [9, 10]]", "type": "list"}], "return": {"value": "({8, 9, 5}, {(8, 9)})", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[2, 5], [3, 8], [0, 3, 5], [1, 2, 6, 8], [7], [0, 2], [3, 8], [4], [1, 3, 6]]", "type": "list"}], "return": {"value": "({2, 3}, {(4, 7), (2, 3)})", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[1, 2], [0, 2], [0, 1, 3], [2]]", "type": "list"}], "return": {"value": "({2}, {(2, 3)})", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[]]", "type": "list"}], "return": {"value": "(set(), set())", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[1, 2], [0], [0]]", "type": "list"}], "return": {"value": "({0}, {(0, 1), (0, 2)})", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[1], [0]]", "type": "list"}], "return": {"value": "(set(), {(0, 1)})", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[1], [0, 2], [1]]", "type": "list"}], "return": {"value": "({1}, {(0, 1), (1, 2)})", "type": "tuple"}}]}], "classes": []}, "FR": {"name": "biconnected_components", "description": "bi-composants connect\u00e9s, couper les sommets et coupe-n\u0153uds\njill-jenn vie, christoph durr et louis abraham - 2015-2019\n", "functions": [{"name": "cut_nodes_edges", "description": "Bi-composants connect\u00e9s\n\n:param graphe: graphe non-dirig\u00e9. dans listlist format. Ne peut pas \u00eatre dans listdict\nformat.\n:retourne: un tuple avec la liste des coupe-n\u0153uds et la liste des bords coup\u00e9s\n:complexit\u00e9: O(|V|+|E|)`\n"}, {"name": "cut_nodes_edges2", "description": "Bi-composants connect\u00e9s, la variante r\u00e9cursive de la mise en \u0153uvre\n\n:param graphe: graphe non-dirig\u00e9. dans listlist format. Ne peut pas \u00eatre dans listdict\nformat.\n:suppose: graphique a environ 5000 sommets \u00e0 la plupart, sinon de la limite de m\u00e9moire est\natteint\n:retourne: un tuple avec la liste des coupe-n\u0153uds et la liste des bords coup\u00e9s\n:complexit\u00e9: O(|V|+|E|)` en moyenne, \" O(|V|+|E|^2)` dans le pire des cas, \u00e0 cause de\nl'utilisation du dictionnaire\n"}], "classes": []}}, {"EN": {"name": "bipartite_vertex_cover", "description": "Bipartie vertex cover\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "_alternate", "description": "extend alternating tree from free vertex u.\n      visitU, visitV marks all vertices covered by the tree.\n    ", "examples": [{"args": [{"name": "u", "value": "0", "type": "int"}, {"name": "bigraph", "value": "[[]]", "type": "list"}, {"name": "visitU", "value": "[False]", "type": "list"}, {"name": "visitV", "value": "[False]", "type": "list"}, {"name": "matchV", "value": "[None]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "u", "value": "0", "type": "int"}, {"name": "bigraph", "value": "[[], []]", "type": "list"}, {"name": "visitU", "value": "[False, False]", "type": "list"}, {"name": "visitV", "value": "[False, False]", "type": "list"}, {"name": "matchV", "value": "[None, None]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "u", "value": "1", "type": "int"}, {"name": "bigraph", "value": "[[], []]", "type": "list"}, {"name": "visitU", "value": "[True, False]", "type": "list"}, {"name": "visitV", "value": "[False, False]", "type": "list"}, {"name": "matchV", "value": "[None, None]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "u", "value": "1", "type": "int"}, {"name": "bigraph", "value": "[[2], [], []]", "type": "list"}, {"name": "visitU", "value": "[False, False, False]", "type": "list"}, {"name": "visitV", "value": "[False, False, False]", "type": "list"}, {"name": "matchV", "value": "[None, None, 0]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "u", "value": "2", "type": "int"}, {"name": "bigraph", "value": "[[2], [], []]", "type": "list"}, {"name": "visitU", "value": "[False, True, False]", "type": "list"}, {"name": "visitV", "value": "[False, False, False]", "type": "list"}, {"name": "matchV", "value": "[None, None, 0]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "u", "value": "0", "type": "int"}, {"name": "bigraph", "value": "[[2], [2], []]", "type": "list"}, {"name": "visitU", "value": "[False, True, False]", "type": "list"}, {"name": "visitV", "value": "[False, False, True]", "type": "list"}, {"name": "matchV", "value": "[None, None, 0]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "u", "value": "1", "type": "int"}, {"name": "bigraph", "value": "[[2], [2], []]", "type": "list"}, {"name": "visitU", "value": "[False, False, False]", "type": "list"}, {"name": "visitV", "value": "[False, False, False]", "type": "list"}, {"name": "matchV", "value": "[None, None, 0]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "u", "value": "2", "type": "int"}, {"name": "bigraph", "value": "[[2], [2], []]", "type": "list"}, {"name": "visitU", "value": "[True, True, False]", "type": "list"}, {"name": "visitV", "value": "[False, False, True]", "type": "list"}, {"name": "matchV", "value": "[None, None, 0]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "u", "value": "0", "type": "int"}, {"name": "bigraph", "value": "[[2], [2], [1]]", "type": "list"}, {"name": "visitU", "value": "[False, True, False]", "type": "list"}, {"name": "visitV", "value": "[False, False, True]", "type": "list"}, {"name": "matchV", "value": "[None, 2, 0]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "u", "value": "1", "type": "int"}, {"name": "bigraph", "value": "[[2], [2], [1]]", "type": "list"}, {"name": "visitU", "value": "[False, False, False]", "type": "list"}, {"name": "visitV", "value": "[False, False, False]", "type": "list"}, {"name": "matchV", "value": "[None, 2, 0]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}]}, {"name": "bipartite_vertex_cover", "description": "Bipartite minimum vertex cover by Koenig's theorem\n\n    :param bigraph: adjacency list, index = vertex in U,\n                                    value = neighbor list in V\n    :assumption: U = V = {0, 1, 2, ..., n - 1} for n = len(bigraph)\n    :returns: boolean table for U, boolean table for V\n    :comment: selected vertices form a minimum vertex cover,\n              i.e. every edge is adjacent to at least one selected vertex\n              and number of selected vertices is minimum\n    :complexity: `O(|V|*|E|)`\n    ", "examples": [{"args": [{"name": "bigraph", "value": "[[]]", "type": "list"}], "return": {"value": "([False], [False])", "type": "tuple"}}, {"args": [{"name": "bigraph", "value": "[[], []]", "type": "list"}], "return": {"value": "([False, False], [False, False])", "type": "tuple"}}, {"args": [{"name": "bigraph", "value": "[[2], [], []]", "type": "list"}], "return": {"value": "([True, False, False], [False, False, False])", "type": "tuple"}}, {"args": [{"name": "bigraph", "value": "[[2], [2], []]", "type": "list"}], "return": {"value": "([False, False, False], [False, False, True])", "type": "tuple"}}, {"args": [{"name": "bigraph", "value": "[[2], [2], [1]]", "type": "list"}], "return": {"value": "([False, False, True], [False, False, True])", "type": "tuple"}}, {"args": [{"name": "bigraph", "value": "[[2], [2], [1, 2]]", "type": "list"}], "return": {"value": "([False, False, True], [False, False, True])", "type": "tuple"}}, {"args": [{"name": "bigraph", "value": "[[2, 1], [2], [1, 2]]", "type": "list"}], "return": {"value": "([False, False, False], [False, True, True])", "type": "tuple"}}, {"args": [{"name": "bigraph", "value": "[[2, 1], [2], [1, 2, 0]]", "type": "list"}], "return": {"value": "([True, True, True], [False, False, False])", "type": "tuple"}}, {"args": [{"name": "bigraph", "value": "[[2, 1, 0], [2], [1, 2, 0]]", "type": "list"}], "return": {"value": "([True, True, True], [False, False, False])", "type": "tuple"}}, {"args": [{"name": "bigraph", "value": "[[2, 1, 0], [2, 0], [1, 2, 0]]", "type": "list"}], "return": {"value": "([True, True, True], [False, False, False])", "type": "tuple"}}]}], "classes": []}, "FR": {"name": "bipartite_vertex_cover", "description": "Bipartie vertex cover\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "_alternate", "description": "\u00e9tendre une alternance de arbre gratuit sommet u.\nvisitU, visitV les marques de tous les sommets couverts par l'arbre.\n"}, {"name": "bipartite_vertex_cover", "description": "Bipartite minimum vertex cover par le th\u00e9or\u00e8me de Koenig\n\n:param bigraph: la contigu\u00eft\u00e9 de la liste, index = sommet U,\nvaleur = voisin la liste en V\n:hypoth\u00e8se: U = V = {0, 1, 2, ..., n - 1} pour n = len(bigraph)\n:retourne: boolean table en U, boolean table pour V\n:commentaire: les vertices s\u00e9lectionn\u00e9s former un minimum vertex cover,\nc'est \u00e0 dire chaque ar\u00eate est adjacent \u00e0 au moins un sommet s\u00e9lectionn\u00e9\net le nombre de vertices s\u00e9lectionn\u00e9s est minimum\n:complexit\u00e9: O(|V|*|E|)`\n"}], "classes": []}}, {"EN": {"name": "longest_common_subsequence", "description": "Longest increasing subsequence\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "longest_common_subsequence", "description": "Longest common subsequence\n\n    Dynamic programming\n\n    :param x:\n    :param y: x, y are lists or strings\n    :returns: longest common subsequence in form of a string\n    :complexity: `O(|x|*|y|)`\n    ", "examples": [{"args": [{"name": "x", "value": "'GAC'", "type": "str"}, {"name": "y", "value": "'AGCAT'", "type": "str"}], "return": {"value": "'GA'", "type": "str"}}, {"args": [{"name": "x", "value": "'ABCDEFGHI'", "type": "str"}, {"name": "y", "value": "'ABCDEFGHI'", "type": "str"}], "return": {"value": "'ABCDEFGHI'", "type": "str"}}, {"args": [{"name": "x", "value": "'ABCDEFGHI'", "type": "str"}, {"name": "y", "value": "'D'", "type": "str"}], "return": {"value": "'D'", "type": "str"}}, {"args": [{"name": "x", "value": "'ABCDEFGHI'", "type": "str"}, {"name": "y", "value": "'IHGFEDCBA'", "type": "str"}], "return": {"value": "'A'", "type": "str"}}, {"args": [{"name": "x", "value": "'ABCDEFGHI'", "type": "str"}, {"name": "y", "value": "'X'", "type": "str"}], "return": {"value": "''", "type": "str"}}, {"args": [{"name": "x", "value": "'ABCDEFGHI'", "type": "str"}, {"name": "y", "value": "''", "type": "str"}], "return": {"value": "''", "type": "str"}}, {"args": [{"name": "x", "value": "''", "type": "str"}, {"name": "y", "value": "''", "type": "str"}], "return": {"value": "''", "type": "str"}}]}], "classes": []}, "FR": {"name": "longest_common_subsequence", "description": "Plus longue sous-suite croissante\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "longest_common_subsequence", "description": "Plus longue sous-suite commune\n\nLa programmation dynamique\n\n:param x:\n:param y: x, y sont des listes ou des cha\u00eenes de caract\u00e8res\n:retourne: la plus longue sous-suite commune sous la forme d'une cha\u00eene de caract\u00e8res\n:complexit\u00e9: O(|x|*|y|)`\n"}], "classes": []}}, {"EN": {"name": "min_mean_cycle", "description": "Minimum mean cycle by Karp\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "min_mean_cycle", "description": "Minimum mean cycle by Karp\n\n    :param graph: directed graph in listlist or listdict format\n    :param weight: in matrix format or same listdict graph\n    :param int start: vertex that should be contained in cycle\n    :returns: cycle as vertex list, average arc weights\n              or None if there is no cycle from start\n    :complexity:  `O(|V|*|E|)`\n    ", "examples": [{"args": [{"name": "graph", "value": "[[1], [2, 3], [0, 3], [0, 1, 2]]", "type": "list"}, {"name": "weight", "value": "[[None, -5, None, None], [None, None, -3, 0], [9, None, None, 2], [7, 0, -1, None]]", "type": "list"}, {"name": "start", "value": "0", "type": "int"}], "return": {"value": "([2, 3, 1], -0.3333333333333333)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[{1: -5}, {2: -3, 3: 0}, {0: 9, 3: 2}, {0: 7, 1: 0, 2: -1}]", "type": "list"}, {"name": "weight", "value": "[{1: -5}, {2: -3, 3: 0}, {0: 9, 3: 2}, {0: 7, 1: 0, 2: -1}]", "type": "list"}, {"name": "start", "value": "0", "type": "int"}], "return": {"value": "([2, 3, 1], -0.3333333333333333)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[1], [1], [2]]", "type": "list"}, {"name": "weight", "value": "[[None, 10, None], [None, -2, None], [None, None, -20]]", "type": "list"}, {"name": "start", "value": "0", "type": "int"}], "return": {"value": "([1], -2.0)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[{1: 10}, {1: -2}, {2: -20}]", "type": "list"}, {"name": "weight", "value": "[{1: 10}, {1: -2}, {2: -20}]", "type": "list"}, {"name": "start", "value": "0", "type": "int"}], "return": {"value": "([1], -2.0)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[1, 2], [1, 2], [1, 2]]", "type": "list"}, {"name": "weight", "value": "[[None, 10, 10], [None, -8, -8], [None, -8, -8]]", "type": "list"}, {"name": "start", "value": "0", "type": "int"}], "return": {"value": "([1], -8.0)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[{1: 10, 2: 10}, {1: -8, 2: -8}, {1: -8, 2: -8}]", "type": "list"}, {"name": "weight", "value": "[{1: 10, 2: 10}, {1: -8, 2: -8}, {1: -8, 2: -8}]", "type": "list"}, {"name": "start", "value": "0", "type": "int"}], "return": {"value": "([1], -8.0)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[], [0, 1]]", "type": "list"}, {"name": "weight", "value": "[[None, None], [0, -4]]", "type": "list"}, {"name": "start", "value": "0", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "graph", "value": "[{}, {0: 0, 1: -4}]", "type": "list"}, {"name": "weight", "value": "[{}, {0: 0, 1: -4}]", "type": "list"}, {"name": "start", "value": "0", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}]}], "classes": []}, "FR": {"name": "min_mean_cycle", "description": "Minimum moyenne du cycle par Karp\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "min_mean_cycle", "description": "Minimum moyenne du cycle par Karp\n\n:param graphe: graphe orient\u00e9 dans listlist ou listdict format\n:param poids: dans un format de matrice ou m\u00eame listdict graphique\n:param int start: vertex qui doivent \u00eatre contenues dans le cycle\n:retourne: cycle sommet de la liste, la moyenne de poids de l'arc\nou Aucun si il n'y a pas de cycle de d\u00e9marrage\n:complexit\u00e9: O(|V|*|E|)`\n"}], "classes": []}}, {"EN": {"name": "kuhn_munkres", "description": "Maximum profit bipartite matching by Kuhn-Munkres\njill-jenn vie, christoph durr and samuel tardieu - 2014-2019\n\nprimal LP\n\n    max sum_{u,v} w[u,v] * x[u,v]\n\n    such that\n    for all u in U: sum_v x[u,v] == 1   (l[u])\n\n    for all v in V: sum_u x[u,v] <= 1   (l[v])\n\n    for all u,v: x[u,v] >= 0\n\n\ndual LP\n\n    min sum_u l[u] + sum_v l[v]\n\n    such that\n    for all u,v:  l[u] + l[v] >= w[u,v]   (*)\n\n    for all u in U: l[u] is arbitrary (free variable)\n    for all v in V: l[v] >= 0\n\n\nprimal-dual algorithm:\n\n    Start with trivial solution l for dual and with trivial\n    non-solution x for primal.\n\n    Iteratively improve primal or dual solution, maintaining complementary\n    slackness conditions.\n\n", "functions": [{"name": "kuhn_munkres", "description": "Maximum profit bipartite matching by Kuhn-Munkres\n\n    :param G: weight matrix where G[u][v] is the weight of edge (u,v),\n    :param TOLERANCE: a value with absolute value below tolerance\n                      is considered as being zero.\n                      If G consists of integer or fractional values\n                      then TOLERANCE can be chosen 0.\n    :requires: graph (U,V,E) is complete bi-partite graph with len(U) <= len(V)\n               float('-inf') or float('inf') entries in G\n               are allowed but not None.\n    :returns: matching table from U to V, value of matching\n    :complexity: :math:`O(|U|^2 |V|)`\n    ", "examples": [{"args": [{"name": "G", "value": "[[1]]", "type": "list"}, {"name": "TOLERANCE", "value": "1e-06", "type": "float"}], "return": {"value": "([0], 1)", "type": "tuple"}}, {"args": [{"name": "G", "value": "[[1, 1], [1, 1]]", "type": "list"}, {"name": "TOLERANCE", "value": "1e-06", "type": "float"}], "return": {"value": "([1, 0], 2)", "type": "tuple"}}, {"args": [{"name": "G", "value": "[[1, 2], [1, 1]]", "type": "list"}, {"name": "TOLERANCE", "value": "1e-06", "type": "float"}], "return": {"value": "([1, 0], 3)", "type": "tuple"}}, {"args": [{"name": "G", "value": "[[1, 1], [2, 1]]", "type": "list"}, {"name": "TOLERANCE", "value": "1e-06", "type": "float"}], "return": {"value": "([1, 0], 3)", "type": "tuple"}}, {"args": [{"name": "G", "value": "[[2, 1], [1, 1]]", "type": "list"}, {"name": "TOLERANCE", "value": "1e-06", "type": "float"}], "return": {"value": "([0, 1], 3)", "type": "tuple"}}, {"args": [{"name": "G", "value": "[[1, 1], [1, 2]]", "type": "list"}, {"name": "TOLERANCE", "value": "1e-06", "type": "float"}], "return": {"value": "([0, 1], 3)", "type": "tuple"}}, {"args": [{"name": "G", "value": "[[-1, -2, -3], [-6, -5, -4], [-1, -1, -1]]", "type": "list"}, {"name": "TOLERANCE", "value": "1e-06", "type": "float"}], "return": {"value": "([0, 2, 1], -6)", "type": "tuple"}}, {"args": [{"name": "G", "value": "[[1, 2, 3], [6, 5, 4], [1, 1, 1]]", "type": "list"}, {"name": "TOLERANCE", "value": "1e-06", "type": "float"}], "return": {"value": "([2, 0, 1], 10)", "type": "tuple"}}, {"args": [{"name": "G", "value": "[[7, 53, 183, 439, 863], [497, 383, 563, 79, 973], [287, 63, 343, 169, 583], [627, 343, 773, 959, 943], [767, 473, 103, 699, 303]]", "type": "list"}, {"name": "TOLERANCE", "value": "1e-06", "type": "float"}], "return": {"value": "([4, 1, 2, 3, 0], 3315)", "type": "tuple"}}, {"args": [{"name": "G", "value": "[[62, 78, 50, 101, 82], [71, 84, 61, 73, 59], [87, 92, 111, 71, 81], [48, 64, 87, 77, 80]]", "type": "list"}, {"name": "TOLERANCE", "value": "1e-06", "type": "float"}], "return": {"value": "([3, 1, 2, 4], 376)", "type": "tuple"}}]}], "classes": []}, "FR": {"name": "kuhn_munkres", "description": "Le Maximum de profit bipartite correspondance par Kuhn-Munkres\njill-jenn vie, christoph durr et samuel tardieu - 2014-2019\n\nprimal LP\n\nmax sum_{u,v} w[u,v] * x[u,v]\n\ntels que\npour tout u dans U: sum_v x[u,v] == 1 (g[u])\n\npour tout v dans V: sum_u x[u,v] <= 1 (l[v])\n\npour tous u,v: x[u,v] >= 0\n\n\ndouble LP\n\nmin sum_u l[u] + sum_v l[v]\n\ntels que\npour tous u,v: l[u] + l[v] >= w[u,v] (*)\n\npour tout u dans U: l[u] est arbitraire (variable ind\u00e9pendante)\npour tout v dans V: l[v] >= 0\n\n\nprimal-dual algorithme:\n\nCommencer avec la solution triviale l pour le double et avec trivial\nnon-solution x pour primal.\n\nDe mani\u00e8re it\u00e9rative am\u00e9liorer primal ou double solution, le maintien de la compl\u00e9mentaire\nla paresse conditions.\n\n", "functions": [{"name": "kuhn_munkres", "description": "Le Maximum de profit bipartite correspondance par Kuhn-Munkres\n\n:param G: matrice de poids o\u00f9 G[u][v] est le poids de l'ar\u00eate (u,v),\n:param TOL\u00c9RANCE: une valeur absolue de la valeur au-dessous de la tol\u00e9rance\nest consid\u00e9r\u00e9 comme \u00e9tant \u00e9gal \u00e0 z\u00e9ro.\nSi G est constitu\u00e9 d'un nombre entier ou fractionnaire valeurs\nensuite, la TOL\u00c9RANCE peut \u00eatre choisi 0.\n:n\u00e9cessite: graphique (U,V,E) est complet bi-partite graphique avec len(U) <= len(V)\nfloat('-inf') ou float('inf') entr\u00e9es en G\nsont permis, mais pas Aucun.\n:retourne: table de correspondance de U \u00e0 V, la valeur de correspondance\n:complexit\u00e9: :math:`O(|U|^2 |V|)`\n"}], "classes": []}}, {"EN": {"name": "freivalds", "description": "Test matrix product AB = C by Freivalds\njill-j\u00eann vie et christoph d\u00fcrr - 2015-2019\n", "functions": [{"name": "freivalds", "description": "Tests matrix product AB=C by Freivalds\n\n    :param A: n by n numerical matrix\n    :param B: same\n    :param C: same\n    :returns: False with high probability if AB != C\n\n    :complexity:\n        :math:`O(n^2)`\n    ", "examples": [{"args": [{"name": "A", "value": "[[2, 3], [3, 4]]", "type": "list"}, {"name": "B", "value": "[[1, 0], [1, 2]]", "type": "list"}, {"name": "C", "value": "[[5, 6], [7, 8]]", "type": "list"}], "return": {"value": "True", "type": "bool"}}]}, {"name": "mult", "description": "\n    function to multiply a matrix times a vector\n    ", "examples": [{"args": [{"name": "M", "value": "[[1, 0], [1, 2]]", "type": "list"}, {"name": "v", "value": "[528810, 869619]", "type": "list"}], "return": {"value": "[528810, 2268048]", "type": "list"}}, {"args": [{"name": "M", "value": "[[2, 3], [3, 4]]", "type": "list"}, {"name": "v", "value": "[528810, 2268048]", "type": "list"}], "return": {"value": "[7861764, 10658622]", "type": "list"}}, {"args": [{"name": "M", "value": "[[5, 6], [7, 8]]", "type": "list"}, {"name": "v", "value": "[528810, 869619]", "type": "list"}], "return": {"value": "[7861764, 10658622]", "type": "list"}}]}, {"name": "readarray", "description": "\n    function to read an array\n    "}, {"name": "readint", "description": "\n    function to read an integer from stdin\n    "}, {"name": "readmatrix", "description": "\n    function to read a matrix\n    "}], "classes": []}, "FR": {"name": "freivalds", "description": "Test de la matrice produit AB = C par Freivalds\njill-j\u00eann vie et christoph d\u00fcrr - 2015-2019\n", "functions": [{"name": "freivalds", "description": "Les Tests de la matrice produit AB=C par Freivalds\n\n:param A: n par n matrice num\u00e9rique\n:param B: m\u00eame\n:param C: m\u00eame\n:retourne: Faux avec une forte probabilit\u00e9, si AB != C\n\n:complexit\u00e9:\n:math:`O(n^2)`\n"}, {"name": "mult", "description": "\nfonction pour multiplier une matrice fois un vecteur\n"}, {"name": "readarray", "description": "\nfonction pour lire un tableau\n"}, {"name": "readint", "description": "\nfonction pour lire un entier sur l'entr\u00e9e standard\n"}, {"name": "readmatrix", "description": "\nla fonction de lecture d'une matrice\n"}], "classes": []}}, {"EN": {"name": "trie", "description": "trie - correcteur orthographique\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "Trie", "description": "\n    :param S: set of words\n    :returns: trie containing all words from S\n    :complexity: linear in total word sizes from S\n    ", "examples": [{"args": [{"name": "S", "value": "['as', 'porc', 'pore', 'pre', 'pres', 'pret']", "type": "list"}], "return": {"value": "<tryalgo.trie.TrieNode object at 0x7efdae88df28>", "type": "TrieNode"}}]}, {"name": "add", "description": "\n    :param T: trie\n    :param string w: word to be added to T\n    :returns: new trie consisting of w added into T\n    :complexity: O(len(w))\n    ", "examples": [{"args": [{"name": "T", "value": "None", "type": "NoneType"}, {"name": "w", "value": "'as'", "type": "str"}, {"name": "i", "value": "2", "type": "int"}], "return": {"value": "<tryalgo.trie.TrieNode object at 0x7efdaec76278>", "type": "TrieNode"}}, {"args": [{"name": "T", "value": "None", "type": "NoneType"}, {"name": "w", "value": "'as'", "type": "str"}, {"name": "i", "value": "1", "type": "int"}], "return": {"value": "<tryalgo.trie.TrieNode object at 0x7efdaec76128>", "type": "TrieNode"}}, {"args": [{"name": "T", "value": "None", "type": "NoneType"}, {"name": "w", "value": "'as'", "type": "str"}, {"name": "i", "value": "0", "type": "int"}], "return": {"value": "<tryalgo.trie.TrieNode object at 0x7efdae88df28>", "type": "TrieNode"}}, {"args": [{"name": "T", "value": "None", "type": "NoneType"}, {"name": "w", "value": "'porc'", "type": "str"}, {"name": "i", "value": "4", "type": "int"}], "return": {"value": "<tryalgo.trie.TrieNode object at 0x7efdaec768d0>", "type": "TrieNode"}}, {"args": [{"name": "T", "value": "None", "type": "NoneType"}, {"name": "w", "value": "'porc'", "type": "str"}, {"name": "i", "value": "3", "type": "int"}], "return": {"value": "<tryalgo.trie.TrieNode object at 0x7efdaec76780>", "type": "TrieNode"}}, {"args": [{"name": "T", "value": "None", "type": "NoneType"}, {"name": "w", "value": "'porc'", "type": "str"}, {"name": "i", "value": "2", "type": "int"}], "return": {"value": "<tryalgo.trie.TrieNode object at 0x7efdaec76630>", "type": "TrieNode"}}, {"args": [{"name": "T", "value": "None", "type": "NoneType"}, {"name": "w", "value": "'porc'", "type": "str"}, {"name": "i", "value": "1", "type": "int"}], "return": {"value": "<tryalgo.trie.TrieNode object at 0x7efdaec764e0>", "type": "TrieNode"}}, {"args": [{"name": "T", "value": "<tryalgo.trie.TrieNode object at 0x7efdae88df28>", "type": "TrieNode"}, {"name": "w", "value": "'porc'", "type": "str"}, {"name": "i", "value": "0", "type": "int"}], "return": {"value": "<tryalgo.trie.TrieNode object at 0x7efdae88df28>", "type": "TrieNode"}}, {"args": [{"name": "T", "value": "None", "type": "NoneType"}, {"name": "w", "value": "'pore'", "type": "str"}, {"name": "i", "value": "4", "type": "int"}], "return": {"value": "<tryalgo.trie.TrieNode object at 0x7efdaec76da0>", "type": "TrieNode"}}, {"args": [{"name": "T", "value": "<tryalgo.trie.TrieNode object at 0x7efdaec76780>", "type": "TrieNode"}, {"name": "w", "value": "'pore'", "type": "str"}, {"name": "i", "value": "3", "type": "int"}], "return": {"value": "<tryalgo.trie.TrieNode object at 0x7efdaec76780>", "type": "TrieNode"}}]}, {"name": "search", "description": "Searches for w[i:] in trie T with distance at most dist\n    ", "examples": [{"args": [{"name": "T", "value": "<tryalgo.trie.TrieNode object at 0x7efdaec76128>", "type": "TrieNode"}, {"name": "dist", "value": "0", "type": "int"}, {"name": "w", "value": "'a'", "type": "str"}, {"name": "i", "value": "1", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "T", "value": "<tryalgo.trie.TrieNode object at 0x7efdae88df28>", "type": "TrieNode"}, {"name": "dist", "value": "0", "type": "int"}, {"name": "w", "value": "'a'", "type": "str"}, {"name": "i", "value": "0", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "T", "value": "<tryalgo.trie.TrieNode object at 0x7efdaec76128>", "type": "TrieNode"}, {"name": "dist", "value": "1", "type": "int"}, {"name": "w", "value": "'a'", "type": "str"}, {"name": "i", "value": "1", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "T", "value": "None", "type": "NoneType"}, {"name": "dist", "value": "0", "type": "int"}, {"name": "w", "value": "'a'", "type": "str"}, {"name": "i", "value": "1", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "T", "value": "<tryalgo.trie.TrieNode object at 0x7efdaec76128>", "type": "TrieNode"}, {"name": "dist", "value": "0", "type": "int"}, {"name": "w", "value": "'a'", "type": "str"}, {"name": "i", "value": "0", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "T", "value": "None", "type": "NoneType"}, {"name": "dist", "value": "0", "type": "int"}, {"name": "w", "value": "'a'", "type": "str"}, {"name": "i", "value": "0", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "T", "value": "<tryalgo.trie.TrieNode object at 0x7efdaec764e0>", "type": "TrieNode"}, {"name": "dist", "value": "0", "type": "int"}, {"name": "w", "value": "'a'", "type": "str"}, {"name": "i", "value": "0", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "T", "value": "<tryalgo.trie.TrieNode object at 0x7efdaec764e0>", "type": "TrieNode"}, {"name": "dist", "value": "0", "type": "int"}, {"name": "w", "value": "'a'", "type": "str"}, {"name": "i", "value": "1", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "T", "value": "<tryalgo.trie.TrieNode object at 0x7efdae88df28>", "type": "TrieNode"}, {"name": "dist", "value": "0", "type": "int"}, {"name": "w", "value": "'a'", "type": "str"}, {"name": "i", "value": "1", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "T", "value": "<tryalgo.trie.TrieNode object at 0x7efdae88df28>", "type": "TrieNode"}, {"name": "dist", "value": "1", "type": "int"}, {"name": "w", "value": "'a'", "type": "str"}, {"name": "i", "value": "0", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}]}, {"name": "spell_check", "description": "Spellchecker\n\n    :param T: trie encoding the dictionary\n    :param w: given word\n    :returns: a closest word from the dictionary\n    :complexity: linear if distance was constant\n    ", "examples": [{"args": [{"name": "T", "value": "<tryalgo.trie.TrieNode object at 0x7efdae88df28>", "type": "TrieNode"}, {"name": "w", "value": "'a'", "type": "str"}], "return": {"value": "'as'", "type": "str"}}, {"args": [{"name": "T", "value": "<tryalgo.trie.TrieNode object at 0x7efdae88df28>", "type": "TrieNode"}, {"name": "w", "value": "'aas'", "type": "str"}], "return": {"value": "'as'", "type": "str"}}, {"args": [{"name": "T", "value": "<tryalgo.trie.TrieNode object at 0x7efdae88df28>", "type": "TrieNode"}, {"name": "w", "value": "'ass'", "type": "str"}], "return": {"value": "'as'", "type": "str"}}, {"args": [{"name": "T", "value": "<tryalgo.trie.TrieNode object at 0x7efdae88df28>", "type": "TrieNode"}, {"name": "w", "value": "'pars'", "type": "str"}], "return": {"value": "'porc'", "type": "str"}}, {"args": [{"name": "T", "value": "<tryalgo.trie.TrieNode object at 0x7efdae88df28>", "type": "TrieNode"}, {"name": "w", "value": "'por'", "type": "str"}], "return": {"value": "'porc'", "type": "str"}}, {"args": [{"name": "T", "value": "<tryalgo.trie.TrieNode object at 0x7efdae88df28>", "type": "TrieNode"}, {"name": "w", "value": "'pes'", "type": "str"}], "return": {"value": "'pres'", "type": "str"}}, {"args": [{"name": "T", "value": "<tryalgo.trie.TrieNode object at 0x7efdae88df28>", "type": "TrieNode"}, {"name": "w", "value": "'pred'", "type": "str"}], "return": {"value": "'pres'", "type": "str"}}, {"args": [{"name": "T", "value": "<tryalgo.trie.TrieNode object at 0x7efdae88df28>", "type": "TrieNode"}, {"name": "w", "value": "'pire'", "type": "str"}], "return": {"value": "'pore'", "type": "str"}}, {"args": [{"name": "T", "value": "<tryalgo.trie.TrieNode object at 0x7efdae88df28>", "type": "TrieNode"}, {"name": "w", "value": "'brzlgrmpf'", "type": "str"}], "return": {"value": "'pres'", "type": "str"}}]}], "classes": [{"name": "TrieNode", "description": null, "methods": [{"name": "__init__", "description": null}]}]}, "FR": {"name": "trie", "description": "trie - correcteur orthographique\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "Trie", "description": "\n:param S: jeu de mots\n:retourne: trie contenant tous les mots de S\n:complexit\u00e9: lin\u00e9aire total de mot tailles de S\n"}, {"name": "ajouter", "description": "\n:param T: trie\n:param string w: mot \u00e0 ajouter \u00e0 T\n:retourne: nouvelle trie compos\u00e9 de w ajout\u00e9 dans T\n:complexit\u00e9: O(len(l))\n"}, {"name": "recherche", "description": "Recherches pour w[i:] dans trie T avec la distance \u00e0 la plupart des dist\n"}, {"name": "spell_check", "description": "Correcteur d'orthographe\n\n:param T: trie codant pour le dictionnaire\n:param w: mot donn\u00e9\n:retourne: plus proche d'un mot du dictionnaire\n:complexit\u00e9: lin\u00e9aire si la distance est constante\n"}], "classes": [{"name": "TrieNode", "description": null, "methods": [{"name": "__init__", "description": null}]}]}}, {"EN": {"name": "polygon", "description": "Area of polygone\nmesures polygone\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "area", "description": "Area of a polygone\n\n    :param p: list of the points taken in any orientation,\n              p[0] can differ from p[-1]\n    :returns: area\n    :complexity: linear\n    ", "examples": [{"args": [{"name": "p", "value": "[(1, 0), (2, 3), (2, 4), (0, 3)]", "type": "list"}], "return": {"value": "4.0", "type": "float"}}, {"args": [{"name": "p", "value": "[(1, 1), (2, 1), (2, 2), (1, 2)]", "type": "list"}], "return": {"value": "1.0", "type": "float"}}]}, {"name": "is_simple", "description": "Test if a rectilinear polygon is is_simple\n\n    :param polygon: list of points as (x,y) pairs along the closed polygon\n    :returns: True if the segements do not intersect\n    :complexity: O(n log n) for n=len(polygon)\n    ", "examples": [{"args": [{"name": "polygon", "value": "[(0, 0), (0, 1), (1, 1), (1, 0)]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "polygon", "value": "[(0, 0), (0, 1), (1, 1), (1, 2), (0, 2), (0, 3), (2, 3), (2, 0)]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "polygon", "value": "[(0, 0), (0, 1), (2, 1), (2, 2), (0, 2), (0, 3), (2, 3), (2, 0)]", "type": "list"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "polygon", "value": "[(0, 0), (0, 3), (2, 3), (2, 2), (0, 2), (0, 1), (2, 1), (2, 0)]", "type": "list"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "polygon", "value": "[(0, 0), (0, 1), (1, 1), (1, 2), (2, 2), (2, 1), (1, 1), (1, 0)]", "type": "list"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "polygon", "value": "[(0, 0), (0, 1), (2, 1), (2, 2), (1, 2), (1, 1), (3, 1), (3, 0)]", "type": "list"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "polygon", "value": "[(0, 0), (0, 1), (2, 1), (2, 2), (0, 2), (0, 3), (1, 3), (1, 0)]", "type": "list"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "polygon", "value": "[(0, 0), (0, 1), (2, 1), (2, 2), (3, 2), (3, 3), (0, 3), (0, 4), (1, 4), (1, 0)]", "type": "list"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "polygon", "value": "[(2, 20), (1, 20), (1, 0), (0, 0), (0, 10), (2, 10)]", "type": "list"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "polygon", "value": "[(0, 0), (0, 1), (2, 1), (2, 2), (3, 2), (3, 3), (1, 3), (1, 0)]", "type": "list"}], "return": {"value": "False", "type": "bool"}}]}], "classes": []}, "FR": {"name": "polygone", "description": "Zone de polygone\nmesures polygone\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "la zone", "description": "Aire d'un polygone\n\n:param p: liste des points de pris dans n'importe quelle orientation,\np[0] peut diff\u00e9rer de p[-1]\n:r\u00e9sultat: domaine\n:complexit\u00e9: lin\u00e9aire\n"}, {"name": "is_simple", "description": "Tester si un polygone rectiligne est is_simple\n\n:param polygone: liste des points (x,y) paires le long du polygone ferm\u00e9\n:retourne: True si le segements ne se croisent pas\n:complexit\u00e9: O(n log n) pour n=len(polygone)\n"}], "classes": []}}, {"EN": {"name": "huffman", "description": "Huffman code\njill-jenn vie et christoph durr - 2014-2019\n", "functions": [{"name": "extract", "description": "Extract Huffman code from a Huffman tree\n\n    :param code: a dictionary that will contain the constructed code.\n                 should initially be empty.\n    :param tree: a node of the tree.\n                 Leafs are of the form (frequency, symbol).\n                 Inner nodes are of the form [left_sub_tree, right_sub_tree].\n    :param prefix: a list with the 01 characters encoding the path from\n                    the root to the node `tree`\n    :complexity: O(n), where n = number of nodes in tree\n    ", "examples": [{"args": [{"name": "code", "value": "{}", "type": "dict"}, {"name": "tree", "value": "'a'", "type": "str"}, {"name": "prefix", "value": "['0', '0']", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "code", "value": "{'a': '00'}", "type": "dict"}, {"name": "tree", "value": "'b'", "type": "str"}, {"name": "prefix", "value": "['0', '1']", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "code", "value": "{}", "type": "dict"}, {"name": "tree", "value": "['a', 'b']", "type": "list"}, {"name": "prefix", "value": "['0']", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "code", "value": "{'a': '00', 'b': '01'}", "type": "dict"}, {"name": "tree", "value": "'c'", "type": "str"}, {"name": "prefix", "value": "['1', '0']", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "code", "value": "{'a': '00', 'b': '01', 'c': '10'}", "type": "dict"}, {"name": "tree", "value": "'d'", "type": "str"}, {"name": "prefix", "value": "['1', '1']", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "code", "value": "{'a': '00', 'b': '01'}", "type": "dict"}, {"name": "tree", "value": "['c', 'd']", "type": "list"}, {"name": "prefix", "value": "['1']", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "code", "value": "{}", "type": "dict"}, {"name": "tree", "value": "[['a', 'b'], ['c', 'd']]", "type": "list"}, {"name": "prefix", "value": "[]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "code", "value": "{}", "type": "dict"}, {"name": "tree", "value": "'d'", "type": "str"}, {"name": "prefix", "value": "['0', '0', '0']", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "code", "value": "{'d': '000'}", "type": "dict"}, {"name": "tree", "value": "'c'", "type": "str"}, {"name": "prefix", "value": "['0', '0', '1']", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "code", "value": "{}", "type": "dict"}, {"name": "tree", "value": "['d', 'c']", "type": "list"}, {"name": "prefix", "value": "['0', '0']", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}]}, {"name": "huffman", "description": "Huffman code\n\n    :param freq: dictionary with frequencies for each item\n    :returns: dictionary with binary code string for each item\n    :complexity: O(n log n), where n = len(freq)\n    ", "examples": [{"args": [{"name": "freq", "value": "{'a': 7, 'b': 7, 'c': 7, 'd': 7}", "type": "dict"}], "return": {"value": "{'a': '00', 'b': '01', 'c': '10', 'd': '11'}", "type": "dict"}}, {"args": [{"name": "freq", "value": "{'a': 40, 'b': 5, 'c': 2, 'd': 1}", "type": "dict"}], "return": {"value": "{'d': '000', 'c': '001', 'b': '01', 'a': '1'}", "type": "dict"}}]}], "classes": []}, "FR": {"name": "huffman", "description": "Le code de Huffman\njill-jenn vie et christoph durr - 2014-2019\n", "functions": [{"name": "extrait", "description": "Extrait de Huffman code \u00e0 partir d'un arbre de Huffman\n\n:param code: un dictionnaire qui contient la construction du code.\ndoit \u00eatre initialement vide.\n:param arbre: un n\u0153ud de l'arbre.\nLeafs sont de la forme (fr\u00e9quence, symbole).\nInt\u00e9rieure n\u0153uds sont de la forme [left_sub_tree, right_sub_tree].\n:param pr\u00e9fixe: une liste avec les 01 encodage de caract\u00e8res du chemin de\nla racine au n\u0153ud de l'arbre\n:complexit\u00e9: O(n), o\u00f9 n = nombre de n\u0153uds dans l'arbre\n"}, {"name": "huffman", "description": "Le code de Huffman\n\n:param freq: dictionnaire avec des fr\u00e9quences pour chaque \u00e9l\u00e9ment\n:retourne: dictionnaire avec le code binaire de la cha\u00eene pour chaque \u00e9l\u00e9ment\n:complexit\u00e9: O(n log n), o\u00f9 n = len(freq)\n"}], "classes": []}}, {"EN": {"name": "arithm_expr_target", "description": "Create arithmetic expression approaching target value\njill-j\u00eann vie, christoph d\u00fcrr et jean-christophe filli\u00e2tre - 2014-2019\n", "functions": [{"name": "arithm_expr_target", "description": " Create arithmetic expression approaching target value\n    :param x: allowed constants\n    :param target: target value\n    :returns: string in form 'expression=value'\n    :complexity: huge\n    ", "examples": [{"args": [{"name": "x", "value": "[3, 100, 8, 8, 10, 6]", "type": "list"}, {"name": "target", "value": "683", "type": "int"}], "return": {"value": "'(((((100+8)+8)*6)-10)-3)=683'", "type": "str"}}, {"args": [{"name": "x", "value": "[3, 75, 2, 4, 1, 1]", "type": "list"}, {"name": "target", "value": "997", "type": "int"}], "return": {"value": "'(((75+2)*((3*4)+1))-1)=1000'", "type": "str"}}]}], "classes": []}, "FR": {"name": "arithm_expr_target", "description": "Cr\u00e9er une expression arithm\u00e9tique approche de la valeur de la cible\njill-j\u00eann vie, christoph d\u00fcrr et jean-christophe filli\u00e2tre - 2014-2019\n", "functions": [{"name": "arithm_expr_target", "description": " Cr\u00e9er une expression arithm\u00e9tique approche de la valeur de la cible\n:param x: permis constantes\n:param cible: valeur cible\n:retourne: cha\u00eene en forme de l '\"expression=valeur\"\n:complexit\u00e9: \u00e9norme\n"}], "classes": []}}, {"EN": {"name": "subsetsum", "description": "subsetsum\njill-jenn vie et christoph durr - 2015-2018\n", "functions": [{"name": "coin_change", "description": "Coin change\n\n    :param x: table of non negative values\n    :param R: target value\n    :returns bool: True if there is a non negative linear combination\n    of x that has value R\n    :complexity: O(n*R)\n    ", "examples": [{"args": [{"name": "x", "value": "[3, 5, 11]", "type": "list"}, {"name": "R", "value": "0", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "x", "value": "[3, 5, 11]", "type": "list"}, {"name": "R", "value": "1", "type": "int"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "x", "value": "[3, 5, 11]", "type": "list"}, {"name": "R", "value": "2", "type": "int"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "x", "value": "[3, 5, 11]", "type": "list"}, {"name": "R", "value": "3", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "x", "value": "[3, 5, 11]", "type": "list"}, {"name": "R", "value": "4", "type": "int"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "x", "value": "[3, 5, 11]", "type": "list"}, {"name": "R", "value": "5", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "x", "value": "[3, 5, 11]", "type": "list"}, {"name": "R", "value": "6", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "x", "value": "[3, 5, 11]", "type": "list"}, {"name": "R", "value": "7", "type": "int"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "x", "value": "[3, 5, 11]", "type": "list"}, {"name": "R", "value": "8", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "x", "value": "[3, 5, 11]", "type": "list"}, {"name": "R", "value": "9", "type": "int"}], "return": {"value": "True", "type": "bool"}}]}, {"name": "subset_sum", "description": "Subsetsum\n\n    :param x: table of non negative values\n    :param R: target value\n    :returns bool: True if a subset of x sums to R\n    :complexity: O(n*R)\n    ", "examples": [{"args": [{"name": "x", "value": "[2, 4, 8, 16, 32]", "type": "list"}, {"name": "R", "value": "27", "type": "int"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "x", "value": "[2, 4, 8, 16, 32]", "type": "list"}, {"name": "R", "value": "28", "type": "int"}], "return": {"value": "True", "type": "bool"}}]}], "classes": []}, "FR": {"name": "subsetsum", "description": "subsetsum\njill-jenn vie et christoph durr - 2015-2018\n", "functions": [{"name": "coin_change", "description": "Pi\u00e8ce de monnaie de changement\n\n:param x: tableau des non valeurs n\u00e9gatives\n:param R: valeur cible\n:renvoie un bool\u00e9en: True si il y a un non n\u00e9gatif combinaison lin\u00e9aire\nde x qui a de la valeur R\n:complexit\u00e9: O(n*R)\n"}, {"name": "subset_sum", "description": "Subsetsum\n\n:param x: tableau des non valeurs n\u00e9gatives\n:param R: valeur cible\n:renvoie un bool\u00e9en: True si un sous-ensemble de x sommes \u00e0 la R\n:complexit\u00e9: O(n*R)\n"}], "classes": []}}, {"EN": {"name": "windows_k_distinct", "description": "All sliding windows containing k distinct elements\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "windows_k_distinct", "description": "Find all largest windows containing exactly k distinct elements\n\n    :param x: list or string\n    :param k: positive integer\n    :yields: largest intervals [i, j) with len(set(x[i:j])) == k\n    :complexity: `O(|x|)`\n    ", "examples": [{"args": [{"name": "x", "value": "'abbaca'", "type": "str"}, {"name": "k", "value": "2", "type": "int"}], "return": {"value": "(0, 4)", "type": "tuple"}}, {"args": [{"name": "x", "value": "'abbaca'", "type": "str"}, {"name": "k", "value": "2", "type": "int"}], "return": {"value": "(3, 6)", "type": "tuple"}}, {"args": [{"name": "x", "value": "'abbaca'", "type": "str"}, {"name": "k", "value": "2", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "x", "value": "'abbaca'", "type": "str"}, {"name": "k", "value": "1", "type": "int"}], "return": {"value": "(0, 1)", "type": "tuple"}}, {"args": [{"name": "x", "value": "'abbaca'", "type": "str"}, {"name": "k", "value": "1", "type": "int"}], "return": {"value": "(1, 3)", "type": "tuple"}}, {"args": [{"name": "x", "value": "'abbaca'", "type": "str"}, {"name": "k", "value": "1", "type": "int"}], "return": {"value": "(3, 4)", "type": "tuple"}}, {"args": [{"name": "x", "value": "'abbaca'", "type": "str"}, {"name": "k", "value": "1", "type": "int"}], "return": {"value": "(4, 5)", "type": "tuple"}}, {"args": [{"name": "x", "value": "'abbaca'", "type": "str"}, {"name": "k", "value": "1", "type": "int"}], "return": {"value": "(5, 6)", "type": "tuple"}}, {"args": [{"name": "x", "value": "'abbaca'", "type": "str"}, {"name": "k", "value": "1", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "x", "value": "'abbabacccabaabaccacab'", "type": "str"}, {"name": "k", "value": "2", "type": "int"}], "return": {"value": "(0, 6)", "type": "tuple"}}]}], "classes": []}, "FR": {"name": "windows_k_distinct", "description": "Toutes les fen\u00eatres coulissantes contenant k \u00e9l\u00e9ments distincts\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "windows_k_distinct", "description": "Trouver toutes les plus grandes fen\u00eatres contenant exactement k \u00e9l\u00e9ments distincts\n\n:param x: liste ou cha\u00eene\n:param k: entier positif\n:rendements: de plus grands intervalles [i, j) avec len(set(x[i:j])) == k\n:complexit\u00e9: O(|x|)`\n"}], "classes": []}}, {"EN": {"name": "interval_tree", "description": "Interval tree\nchristoph d\u00fcrr - jill-j\u00eann vie - 2013-2018\n", "functions": [{"name": "interval_tree", "description": "Construct an interval tree\n\n    :param intervals: list of half-open intervals\n                      encoded as value pairs *[left, right)*\n    :assumes: intervals are lexicographically ordered\n              ``>>> assert intervals == sorted(intervals)``\n    :returns: the root of the interval tree\n    :complexity: :math:`O(n)`\n    ", "examples": [{"args": [{"name": "intervals", "value": "[]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "intervals", "value": "[(1, 3)]", "type": "list"}], "return": {"value": "<tryalgo.interval_tree._Node object at 0x7efdaff41c18>", "type": "_Node"}}, {"args": [{"name": "intervals", "value": "[(1, 3), (5, 7)]", "type": "list"}], "return": {"value": "<tryalgo.interval_tree._Node object at 0x7efdaff41da0>", "type": "_Node"}}, {"args": [{"name": "intervals", "value": "[(5, 7)]", "type": "list"}], "return": {"value": "<tryalgo.interval_tree._Node object at 0x7efdaff41eb8>", "type": "_Node"}}, {"args": [{"name": "intervals", "value": "[(1, 3), (3, 6), (5, 7)]", "type": "list"}], "return": {"value": "<tryalgo.interval_tree._Node object at 0x7efdaff41c88>", "type": "_Node"}}, {"args": [{"name": "intervals", "value": "[(83, 99)]", "type": "list"}], "return": {"value": "<tryalgo.interval_tree._Node object at 0x7efdaff41eb8>", "type": "_Node"}}, {"args": [{"name": "intervals", "value": "[(193, 282)]", "type": "list"}], "return": {"value": "<tryalgo.interval_tree._Node object at 0x7efdaff41e10>", "type": "_Node"}}, {"args": [{"name": "intervals", "value": "[(124, 272), (190, 240), (193, 282)]", "type": "list"}], "return": {"value": "<tryalgo.interval_tree._Node object at 0x7efdaff41f60>", "type": "_Node"}}, {"args": [{"name": "intervals", "value": "[(79, 255), (83, 99), (95, 175), (107, 187), (124, 272), (190, 240), (193, 282)]", "type": "list"}], "return": {"value": "<tryalgo.interval_tree._Node object at 0x7efdaff41c18>", "type": "_Node"}}, {"args": [{"name": "intervals", "value": "[(4, 61), (6, 251), (11, 155), (13, 73), (13, 163), (17, 121), (29, 80), (31, 135), (79, 255), (83, 99), (95, 175), (107, 187), (124, 272), (190, 240), (193, 282)]", "type": "list"}], "return": {"value": "<tryalgo.interval_tree._Node object at 0x7efdaff41f28>", "type": "_Node"}}]}, {"name": "intervals_containing", "description": "Query the interval tree\n\n    :param t: root of the interval tree\n    :param p: value\n    :returns: a list of intervals containing p\n    :complexity: O(log n + m), where n is the number of intervals in t,\n                and m the length of the returned list\n    ", "examples": [{"args": [{"name": "t", "value": "None", "type": "NoneType"}, {"name": "p", "value": "0", "type": "int"}], "return": {"value": "[]", "type": "list"}}, {"args": [{"name": "t", "value": "None", "type": "NoneType"}, {"name": "p", "value": "1", "type": "int"}], "return": {"value": "[]", "type": "list"}}, {"args": [{"name": "t", "value": "None", "type": "NoneType"}, {"name": "p", "value": "2", "type": "int"}], "return": {"value": "[]", "type": "list"}}, {"args": [{"name": "t", "value": "None", "type": "NoneType"}, {"name": "p", "value": "3", "type": "int"}], "return": {"value": "[]", "type": "list"}}, {"args": [{"name": "t", "value": "None", "type": "NoneType"}, {"name": "p", "value": "4", "type": "int"}], "return": {"value": "[]", "type": "list"}}, {"args": [{"name": "t", "value": "None", "type": "NoneType"}, {"name": "p", "value": "5", "type": "int"}], "return": {"value": "[]", "type": "list"}}, {"args": [{"name": "t", "value": "None", "type": "NoneType"}, {"name": "p", "value": "6", "type": "int"}], "return": {"value": "[]", "type": "list"}}, {"args": [{"name": "t", "value": "None", "type": "NoneType"}, {"name": "p", "value": "7", "type": "int"}], "return": {"value": "[]", "type": "list"}}, {"args": [{"name": "t", "value": "None", "type": "NoneType"}, {"name": "p", "value": "8", "type": "int"}], "return": {"value": "[]", "type": "list"}}, {"args": [{"name": "t", "value": "None", "type": "NoneType"}, {"name": "p", "value": "9", "type": "int"}], "return": {"value": "[]", "type": "list"}}]}], "classes": [{"name": "_Node", "description": null, "methods": [{"name": "__init__", "description": null}]}]}, "FR": {"name": "interval_tree", "description": "Intervalle d'arbre\nchristoph d\u00fcrr - jill-j\u00eann vie - 2013-2018\n", "functions": [{"name": "interval_tree", "description": "Construire un intervalle de l'arbre\n\n:param intervalles: liste des demi-ouvert intervalles\ncod\u00e9s comme des paires de valeur *[gauche, droite)*\n:suppose: les intervalles sont ordonn\u00e9 lexicographiquement\n`>>> affirmer intervalles == sorted(intervalles)`\n:renvoie: la racine de l'intervalle de l'arbre\n:complexit\u00e9: :math:`O(n)`\n"}, {"name": "intervals_containing", "description": "Requ\u00eate de l'intervalle de l'arbre\n\n:param t: racine de l'intervalle de l'arbre\n:param p: valeur\n:retourne: une liste d'intervalles contenant p\n:complexit\u00e9: O(log n + m), o\u00f9 n est le nombre d'intervalles dans t,\net m la longueur de la liste retourn\u00e9e\n"}], "classes": [{"name": "_Node", "description": null, "methods": [{"name": "__init__", "description": null}]}]}}, {"EN": {"name": "bipartite_matching", "description": "Bipartie maximum matching\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "augment", "description": "augment ", "examples": [{"args": [{"name": "u", "value": "0", "type": "int"}, {"name": "bigraph", "value": "[[]]", "type": "list"}, {"name": "visit", "value": "[False]", "type": "list"}, {"name": "match", "value": "[None]", "type": "list"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "u", "value": "0", "type": "int"}, {"name": "bigraph", "value": "[[], []]", "type": "list"}, {"name": "visit", "value": "[False, False]", "type": "list"}, {"name": "match", "value": "[None, None]", "type": "list"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "u", "value": "1", "type": "int"}, {"name": "bigraph", "value": "[[], []]", "type": "list"}, {"name": "visit", "value": "[False, False]", "type": "list"}, {"name": "match", "value": "[None, None]", "type": "list"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "u", "value": "0", "type": "int"}, {"name": "bigraph", "value": "[[2], [], []]", "type": "list"}, {"name": "visit", "value": "[False, False, False]", "type": "list"}, {"name": "match", "value": "[None, None, None]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "u", "value": "1", "type": "int"}, {"name": "bigraph", "value": "[[2], [], []]", "type": "list"}, {"name": "visit", "value": "[False, False, False]", "type": "list"}, {"name": "match", "value": "[None, None, 0]", "type": "list"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "u", "value": "2", "type": "int"}, {"name": "bigraph", "value": "[[2], [], []]", "type": "list"}, {"name": "visit", "value": "[False, False, False]", "type": "list"}, {"name": "match", "value": "[None, None, 0]", "type": "list"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "u", "value": "0", "type": "int"}, {"name": "bigraph", "value": "[[2], [2], []]", "type": "list"}, {"name": "visit", "value": "[False, False, False]", "type": "list"}, {"name": "match", "value": "[None, None, None]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "u", "value": "0", "type": "int"}, {"name": "bigraph", "value": "[[2], [2], []]", "type": "list"}, {"name": "visit", "value": "[False, False, True]", "type": "list"}, {"name": "match", "value": "[None, None, 0]", "type": "list"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "u", "value": "1", "type": "int"}, {"name": "bigraph", "value": "[[2], [2], []]", "type": "list"}, {"name": "visit", "value": "[False, False, False]", "type": "list"}, {"name": "match", "value": "[None, None, 0]", "type": "list"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "u", "value": "2", "type": "int"}, {"name": "bigraph", "value": "[[2], [2], []]", "type": "list"}, {"name": "visit", "value": "[False, False, False]", "type": "list"}, {"name": "match", "value": "[None, None, 0]", "type": "list"}], "return": {"value": "False", "type": "bool"}}]}, {"name": "max_bipartite_matching", "description": "Bipartie maximum matching\n\n    :param bigraph: adjacency list, index = vertex in U,\n                                    value = neighbor list in V\n    :assumption: U = V = {0, 1, 2, ..., n - 1} for n = len(bigraph)\n    :returns: matching list, match[v] == u iff (u, v) in matching\n    :complexity: `O(|V|*|E|)`\n    ", "examples": [{"args": [{"name": "bigraph", "value": "[[]]", "type": "list"}], "return": {"value": "[None]", "type": "list"}}, {"args": [{"name": "bigraph", "value": "[[], []]", "type": "list"}], "return": {"value": "[None, None]", "type": "list"}}, {"args": [{"name": "bigraph", "value": "[[2], [], []]", "type": "list"}], "return": {"value": "[None, None, 0]", "type": "list"}}, {"args": [{"name": "bigraph", "value": "[[2], [2], []]", "type": "list"}], "return": {"value": "[None, None, 0]", "type": "list"}}, {"args": [{"name": "bigraph", "value": "[[2], [2], [1]]", "type": "list"}], "return": {"value": "[None, 2, 0]", "type": "list"}}, {"args": [{"name": "bigraph", "value": "[[2], [2], [1, 2]]", "type": "list"}], "return": {"value": "[None, 2, 0]", "type": "list"}}, {"args": [{"name": "bigraph", "value": "[[2, 1], [2], [1, 2]]", "type": "list"}], "return": {"value": "[None, 0, 1]", "type": "list"}}, {"args": [{"name": "bigraph", "value": "[[2, 1], [2], [1, 2, 0]]", "type": "list"}], "return": {"value": "[2, 0, 1]", "type": "list"}}, {"args": [{"name": "bigraph", "value": "[[2, 1, 0], [2], [1, 2, 0]]", "type": "list"}], "return": {"value": "[0, 2, 1]", "type": "list"}}, {"args": [{"name": "bigraph", "value": "[[2, 1, 0], [2, 0], [1, 2, 0]]", "type": "list"}], "return": {"value": "[1, 2, 0]", "type": "list"}}]}, {"name": "max_bipartite_matching2", "description": "Bipartie maximum matching\n\n    :param bigraph: adjacency list, index = vertex in U,\n                                    value = neighbor list in V\n    :comment: U and V can have different cardinalities\n    :returns: matching list, match[v] == u iff (u, v) in matching\n    :complexity: `O(|V|*|E|)`\n    ", "examples": [{"args": [{"name": "bigraph", "value": "[[]]", "type": "list"}], "return": {"value": "[]", "type": "list"}}, {"args": [{"name": "bigraph", "value": "[[], []]", "type": "list"}], "return": {"value": "[]", "type": "list"}}, {"args": [{"name": "bigraph", "value": "[[0], [0]]", "type": "list"}], "return": {"value": "[0]", "type": "list"}}, {"args": [{"name": "bigraph", "value": "[[0], [0, 1]]", "type": "list"}], "return": {"value": "[0, 1]", "type": "list"}}, {"args": [{"name": "bigraph", "value": "[[0], [0, 1], [2, 3], [1], [0, 3]]", "type": "list"}], "return": {"value": "[0, 1, 2, 4]", "type": "list"}}]}], "classes": []}, "FR": {"name": "bipartite_matching", "description": "Bipartie maximum correspondant\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "augmenter", "description": "augmenter "}, {"name": "max_bipartite_matching", "description": "Bipartie maximum correspondant\n\n:param bigraph: la contigu\u00eft\u00e9 de la liste, index = sommet U,\nvaleur = voisin la liste en V\n:hypoth\u00e8se: U = V = {0, 1, 2, ..., n - 1} pour n = len(bigraph)\n:retourne: liste, correspondance[v] == u ssi (u, v) dans la correspondance de\n:complexit\u00e9: O(|V|*|E|)`\n"}, {"name": "max_bipartite_matching2", "description": "Bipartie maximum correspondant\n\n:param bigraph: la contigu\u00eft\u00e9 de la liste, index = sommet U,\nvaleur = voisin la liste en V\ncommentaire: U et V peuvent avoir diff\u00e9rentes cardinalit\u00e9s\n:retourne: liste, correspondance[v] == u ssi (u, v) dans la correspondance de\n:complexit\u00e9: O(|V|*|E|)`\n"}], "classes": []}}, {"EN": {"name": "manacher", "description": "Longest palindrome in a string by Manacher\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n\nhttp://leetcode.com/2011/11/longest-palindromic-substring-part-ii.html\n\nAlgorithme de Manacher\nprobl\u00e8me: plus long palindrome\nentr\u00e9e: cha\u00eene s\nsortie: indices i, j tel que s[i:j] est un palindrome\n        et que j-i est maximal et i maximal\ncomplexit\u00e9: temps lin\u00e9aire\n\ntous les indices r\u00e9f\u00e8rent \u00e0 une cha\u00eene fictive t\nde la forme \"^#a#b#a#a#$\" si s=\"abaa\"\ninvariant: pour chaque pr\u00e9fixe vu\non maintient un palindrome centr\u00e9 en c et de bord droit r\nqui maximise r\nainsi que p[i] = plus grand rayon d'un palindrome centr\u00e9 en i\n", "functions": [{"name": "manacher", "description": "Longest palindrome in a string by Manacher\n\n    :param s: string\n    :requires: s is not empty\n    :returns: i,j such that s[i:j] is the longest palindrome in s\n    :complexity: O(len(s))\n    ", "examples": [{"args": [{"name": "s", "value": "'a'", "type": "str"}], "return": {"value": "(0, 1)", "type": "tuple"}}, {"args": [{"name": "s", "value": "'aa'", "type": "str"}], "return": {"value": "(0, 2)", "type": "tuple"}}, {"args": [{"name": "s", "value": "'ab'", "type": "str"}], "return": {"value": "(1, 2)", "type": "tuple"}}, {"args": [{"name": "s", "value": "'aba'", "type": "str"}], "return": {"value": "(0, 3)", "type": "tuple"}}, {"args": [{"name": "s", "value": "'baa'", "type": "str"}], "return": {"value": "(1, 3)", "type": "tuple"}}, {"args": [{"name": "s", "value": "'aab'", "type": "str"}], "return": {"value": "(0, 2)", "type": "tuple"}}, {"args": [{"name": "s", "value": "'babcbabcbaccba'", "type": "str"}], "return": {"value": "(1, 10)", "type": "tuple"}}]}], "classes": []}, "FR": {"name": "manacher", "description": "Le plus long palindrome dans une cha\u00eene de caract\u00e8res par Manacher\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n\nhttp://leetcode.com/2011/11/longest-palindromic-substring-part-ii.html\n\nAlgorithme de Manacher\nprobleme: plus long palindrome\nentr\u00e9e: cha\u00eene s\nsortie: les indices i, j tel que s[i:j] est un palindrome\net que j-je hne maximale et j'maximale\ncomplexit\u00e9: temps lin\u00e9aire\n\ntous les indices r\u00e9f\u00e8rent \u00e0 une cha\u00eene fictive t\nde la forme \"^#a#b#a#a#$\" si s=\"abaa\"\ninvariant: pour chaque pr\u00e9fixe vu\nsur le maintient de l'onu palindrome centr\u00e9 en c et de bord droit de r\nqui de maximiser r\nainsi que p[i] = plus grand rayon d'un palindrome centr\u00e9 en i\n", "functions": [{"name": "manacher", "description": "Le plus long palindrome dans une cha\u00eene de caract\u00e8res par Manacher\n\n:param s: string\n:n\u00e9cessite: s n'est pas vide\n:retourne: i,j tel que s[i:j] est le plus long palindrome de la s\n:complexit\u00e9: O(len(s))\n"}], "classes": []}}, {"EN": {"name": "left_right_inversions", "description": "Left and right inversions in a table\nchristoph d\u00fcrr - 2016-2019\n", "functions": [{"name": "_merge_sort", "description": null, "examples": [{"args": [{"name": "tab", "value": "[1]", "type": "list"}, {"name": "tmp", "value": "[None]", "type": "list"}, {"name": "rank", "value": "[0]", "type": "list"}, {"name": "left", "value": "[0]", "type": "list"}, {"name": "right", "value": "[0]", "type": "list"}, {"name": "lo", "value": "0", "type": "int"}, {"name": "hi", "value": "1", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "tab", "value": "[1, 2]", "type": "list"}, {"name": "tmp", "value": "[None, None]", "type": "list"}, {"name": "rank", "value": "[0, 1]", "type": "list"}, {"name": "left", "value": "[0, 0]", "type": "list"}, {"name": "right", "value": "[0, 0]", "type": "list"}, {"name": "lo", "value": "0", "type": "int"}, {"name": "hi", "value": "1", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "tab", "value": "[1, 2]", "type": "list"}, {"name": "tmp", "value": "[None, None]", "type": "list"}, {"name": "rank", "value": "[0, 1]", "type": "list"}, {"name": "left", "value": "[0, 0]", "type": "list"}, {"name": "right", "value": "[0, 0]", "type": "list"}, {"name": "lo", "value": "1", "type": "int"}, {"name": "hi", "value": "2", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "tab", "value": "[1, 2]", "type": "list"}, {"name": "tmp", "value": "[None, None]", "type": "list"}, {"name": "rank", "value": "[0, 1]", "type": "list"}, {"name": "left", "value": "[0, 0]", "type": "list"}, {"name": "right", "value": "[0, 0]", "type": "list"}, {"name": "lo", "value": "0", "type": "int"}, {"name": "hi", "value": "2", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "tab", "value": "[2, 2]", "type": "list"}, {"name": "tmp", "value": "[None, None]", "type": "list"}, {"name": "rank", "value": "[0, 1]", "type": "list"}, {"name": "left", "value": "[0, 0]", "type": "list"}, {"name": "right", "value": "[0, 0]", "type": "list"}, {"name": "lo", "value": "0", "type": "int"}, {"name": "hi", "value": "1", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "tab", "value": "[2, 2]", "type": "list"}, {"name": "tmp", "value": "[None, None]", "type": "list"}, {"name": "rank", "value": "[0, 1]", "type": "list"}, {"name": "left", "value": "[0, 0]", "type": "list"}, {"name": "right", "value": "[0, 0]", "type": "list"}, {"name": "lo", "value": "1", "type": "int"}, {"name": "hi", "value": "2", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "tab", "value": "[2, 2]", "type": "list"}, {"name": "tmp", "value": "[None, None]", "type": "list"}, {"name": "rank", "value": "[0, 1]", "type": "list"}, {"name": "left", "value": "[0, 0]", "type": "list"}, {"name": "right", "value": "[0, 0]", "type": "list"}, {"name": "lo", "value": "0", "type": "int"}, {"name": "hi", "value": "2", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "tab", "value": "[2, 1]", "type": "list"}, {"name": "tmp", "value": "[None, None]", "type": "list"}, {"name": "rank", "value": "[0, 1]", "type": "list"}, {"name": "left", "value": "[0, 0]", "type": "list"}, {"name": "right", "value": "[0, 0]", "type": "list"}, {"name": "lo", "value": "0", "type": "int"}, {"name": "hi", "value": "1", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "tab", "value": "[2, 1]", "type": "list"}, {"name": "tmp", "value": "[None, None]", "type": "list"}, {"name": "rank", "value": "[0, 1]", "type": "list"}, {"name": "left", "value": "[0, 0]", "type": "list"}, {"name": "right", "value": "[0, 0]", "type": "list"}, {"name": "lo", "value": "1", "type": "int"}, {"name": "hi", "value": "2", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "tab", "value": "[2, 1]", "type": "list"}, {"name": "tmp", "value": "[None, None]", "type": "list"}, {"name": "rank", "value": "[0, 1]", "type": "list"}, {"name": "left", "value": "[0, 0]", "type": "list"}, {"name": "right", "value": "[0, 0]", "type": "list"}, {"name": "lo", "value": "0", "type": "int"}, {"name": "hi", "value": "2", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}]}, {"name": "left_right_inversions", "description": " Compute left and right inversions of each element of a table.\n\n    :param tab: list with comparable elements\n    :returns: lists left and right. left[j] = the number of\n    i<j such that tab[i] > tab[j].\n              right[i] = the number of i<j such that tab[i] > tab[j].\n    :complexity: `O(n log n)`\n    ", "examples": [{"args": [{"name": "tab", "value": "[1]", "type": "list"}], "return": {"value": "([0], [0])", "type": "tuple"}}, {"args": [{"name": "tab", "value": "[1, 2]", "type": "list"}], "return": {"value": "([0, 0], [0, 0])", "type": "tuple"}}, {"args": [{"name": "tab", "value": "[2, 2]", "type": "list"}], "return": {"value": "([0, 0], [0, 0])", "type": "tuple"}}, {"args": [{"name": "tab", "value": "[2, 1]", "type": "list"}], "return": {"value": "([0, 1], [1, 0])", "type": "tuple"}}, {"args": [{"name": "tab", "value": "[1, 1]", "type": "list"}], "return": {"value": "([0, 0], [0, 0])", "type": "tuple"}}, {"args": [{"name": "tab", "value": "[2, 1, 3]", "type": "list"}], "return": {"value": "([0, 1, 0], [1, 0, 0])", "type": "tuple"}}, {"args": [{"name": "tab", "value": "[1, 3, 1]", "type": "list"}], "return": {"value": "([0, 0, 1], [0, 1, 0])", "type": "tuple"}}, {"args": [{"name": "tab", "value": "[2, 3, 3]", "type": "list"}], "return": {"value": "([0, 0, 0], [0, 0, 0])", "type": "tuple"}}, {"args": [{"name": "tab", "value": "[2, 1, 2]", "type": "list"}], "return": {"value": "([0, 1, 0], [1, 0, 0])", "type": "tuple"}}, {"args": [{"name": "tab", "value": "[3, 1, 1]", "type": "list"}], "return": {"value": "([0, 1, 1], [2, 0, 0])", "type": "tuple"}}]}], "classes": []}, "FR": {"name": "left_right_inversions", "description": "\u00c0 gauche et \u00e0 droite des inversions dans une table\nchristoph d\u00fcrr - 2016-2019\n", "functions": [{"name": "_merge_sort", "description": null}, {"name": "left_right_inversions", "description": " Calculer \u00e0 gauche et \u00e0 droite des inversions de chaque \u00e9l\u00e9ment d'un tableau.\n\n:param onglet: liste comparables, avec des \u00e9l\u00e9ments\n:retourne: les listes de gauche et de droite. gauche[j] = le nombre de\ni<j tels que tab[i] > tab[j].\ndroit[i] = le nombre de i<j tels que tab[i] > tab[j].\n:complexit\u00e9: O(n log n)`\n"}], "classes": []}}, {"EN": {"name": "edmonds_karp", "description": "Maximum flow by Edmonds-Karp\njill-j\u00eann vie et christoph d\u00fcrr - 2015-2019\n", "functions": [{"name": "_augment", "description": "find a shortest augmenting path\n    ", "examples": [{"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "flow", "value": "[[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "5", "type": "int"}], "return": {"value": "([0, 0, 0, 1, 2, 3], 1)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "flow", "value": "[[0, 1, 0, 0, 0, 0], [-1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0], [0, -1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0], [0, 0, 0, -1, 0, 0]]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "5", "type": "int"}], "return": {"value": "([0, 0, 0, None, 2, 4], 1)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "flow", "value": "[[0, 1, 1, 0, 0, 0], [-1, 0, 0, 1, 0, 0], [-1, 0, 0, 0, 1, 0], [0, -1, 0, 0, 0, 1], [0, 0, -1, 0, 0, 1], [0, 0, 0, -1, -1, 0]]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "5", "type": "int"}], "return": {"value": "([0, 0, 0, None, None, None], 0)", "type": "tuple"}}]}, {"name": "edmonds_karp", "description": "Maximum flow by Edmonds-Karp\n\n    :param graph: directed graph in listlist or listdict format\n    :param capacity: in matrix format or same listdict graph\n    :param int source: vertex\n    :param int target: vertex\n    :returns: flow matrix, flow value\n    :complexity: :math:`O(|V|*|E|^2)`\n    ", "examples": [{"args": [{"name": "graph", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "capacity", "value": "[{1: 9, 2: 9}, {3: 1, 0: 0}, {4: 1, 0: 0}, {5: 9, 1: 0}, {5: 9, 2: 0}, {3: 0, 4: 0}]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}, {"name": "target", "value": "5", "type": "int"}], "return": {"value": "([[0, 1, 1, 0, 0, 0], [-1, 0, 0, 1, 0, 0], [-1, 0, 0, 0, 1, 0], [0, -1, 0, 0, 0, 1], [0, 0, -1, 0, 0, 1], [0, 0, 0, -1, -1, 0]], 2)", "type": "tuple"}}]}], "classes": []}, "FR": {"name": "edmonds_karp", "description": "D\u00e9bit maximal par Edmonds-Karp\njill-j\u00eann vie et christoph d\u00fcrr - 2015-2019\n", "functions": [{"name": "_augment", "description": "trouver un plus court chemin augmentant\n"}, {"name": "edmonds_karp", "description": "D\u00e9bit maximal par Edmonds-Karp\n\n:param graphe: graphe orient\u00e9 dans listlist ou listdict format\n:param capacit\u00e9: dans un format de matrice ou m\u00eame listdict graphique\n:param int source: sommet\n:param int cible: sommet\n:retourne: matrice de flux, le flux de valeur\n:complexit\u00e9: :math:`O(|V|*|E|^2)`\n"}], "classes": []}}, {"EN": {"name": "bellman_ford", "description": "Single source shortest paths by Bellman-Ford\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "bellman_ford", "description": " Single source shortest paths by Bellman-Ford\n\n    :param graph: directed graph in listlist or listdict format\n    :param weight: can be negative.\n                   in matrix format or same listdict graph\n    :returns: distance table, precedence table, bool\n    :explanation: bool is True if a negative circuit is\n                  reachable from the source, circuits\n                  can have length 2.\n    :complexity: `O(|V|*|E|)`\n    ", "examples": [{"args": [{"name": "graph", "value": "[{1: 1}, {2: 4}, {5: -3}, {6: 3}, {3: 1}, {4: 5, 8: 2}, {7: -6}, {4: 1}, {2: 2}]", "type": "list"}, {"name": "weight", "value": "[{1: 1}, {2: 4}, {5: -3}, {6: 3}, {3: 1}, {4: 5, 8: 2}, {7: -6}, {4: 1}, {2: 2}]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}], "return": {"value": "([0, 1, 5, 5, 3, 2, 8, 2, 4], [None, 0, 1, 4, 7, 2, 3, 6, 5], True)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[{1: 1}, {2: 4}, {5: -3}, {6: 3}, {3: 1}, {8: 2}, {7: -6}, {4: 1}, {2: 2}]", "type": "list"}, {"name": "weight", "value": "[{1: 1}, {2: 4}, {5: -3}, {6: 3}, {3: 1}, {8: 2}, {7: -6}, {4: 1}, {2: 2}]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}], "return": {"value": "([0, 1, 5, inf, inf, 2, inf, inf, 4], [None, 0, 1, None, None, 2, None, None, 5], False)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[]]", "type": "list"}, {"name": "weight", "value": "[[None]]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}], "return": {"value": "([0], [None], False)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[{}]", "type": "list"}, {"name": "weight", "value": "[{}]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}], "return": {"value": "([0], [None], False)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[1], []]", "type": "list"}, {"name": "weight", "value": "[[None, -3], [None, None]]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}], "return": {"value": "([0, -3], [None, 0], False)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[{1: -3}, {}]", "type": "list"}, {"name": "weight", "value": "[{1: -3}, {}]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}], "return": {"value": "([0, -3], [None, 0], False)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[], []]", "type": "list"}, {"name": "weight", "value": "[[None, None], [None, None]]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}], "return": {"value": "([0, inf], [None, None], False)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[{}, {}]", "type": "list"}, {"name": "weight", "value": "[{}, {}]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}], "return": {"value": "([0, inf], [None, None], False)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[0, 1], [0, 1]]", "type": "list"}, {"name": "weight", "value": "[[2, 3], [3, -1]]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}], "return": {"value": "([0, 1], [None, 1], True)", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[{0: 2, 1: 3}, {0: 3, 1: -1}]", "type": "list"}, {"name": "weight", "value": "[{0: 2, 1: 3}, {0: 3, 1: -1}]", "type": "list"}, {"name": "source", "value": "0", "type": "int"}], "return": {"value": "([0, 1], [None, 1], True)", "type": "tuple"}}]}], "classes": []}, "FR": {"name": "bellman_ford", "description": "Unique source de plus courts chemins par Bellman-Ford\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "bellman_ford", "description": " Unique source de plus courts chemins par Bellman-Ford\n\n:param graphe: graphe orient\u00e9 dans listlist ou listdict format\n:param poids: peut \u00eatre n\u00e9gatif.\ndans un format de matrice ou m\u00eame listdict graphique\n:retourne: distance de la table, tableau de pr\u00e9c\u00e9dence, bool\n:explication: bool Vrai si un circuit est n\u00e9gatif\naccessible \u00e0 partir de la source, circuits\npeut avoir une longueur de 2.\n:complexit\u00e9: O(|V|*|E|)`\n"}], "classes": []}}, {"EN": {"name": "rabin_karp", "description": "Find substrings by Rabin-Karp\njill-jenn vie et christoph durr - 2015-2019\n", "functions": [{"name": "matches", "description": "\n    Checks whether s[i:i + k] is equal to t[j:j + k].\n    We used a loop to ease the implementation in other languages.\n    ", "examples": [{"args": [{"name": "s", "value": "'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab'", "type": "str"}, {"name": "t", "value": "'aaaaaaaaaab'", "type": "str"}, {"name": "i", "value": "90", "type": "int"}, {"name": "j", "value": "0", "type": "int"}, {"name": "k", "value": "11", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "s", "value": "'ab'", "type": "str"}, {"name": "t", "value": "'a'", "type": "str"}, {"name": "i", "value": "0", "type": "int"}, {"name": "j", "value": "0", "type": "int"}, {"name": "k", "value": "1", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "s", "value": "'ab'", "type": "str"}, {"name": "t", "value": "'b'", "type": "str"}, {"name": "i", "value": "1", "type": "int"}, {"name": "j", "value": "0", "type": "int"}, {"name": "k", "value": "1", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "s", "value": "'h'", "type": "str"}, {"name": "t", "value": "'h'", "type": "str"}, {"name": "i", "value": "0", "type": "int"}, {"name": "j", "value": "0", "type": "int"}, {"name": "k", "value": "1", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "s", "value": "'ab'", "type": "str"}, {"name": "t", "value": "'ab'", "type": "str"}, {"name": "i", "value": "0", "type": "int"}, {"name": "j", "value": "0", "type": "int"}, {"name": "k", "value": "2", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "s", "value": "'ab'", "type": "str"}, {"name": "t", "value": "'ba'", "type": "str"}, {"name": "i", "value": "0", "type": "int"}, {"name": "j", "value": "1", "type": "int"}, {"name": "k", "value": "1", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "s", "value": "'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'", "type": "str"}, {"name": "t", "value": "'ccccccccccccccccccccccccccccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbcccccccccccccccccccccccccccccc'", "type": "str"}, {"name": "i", "value": "30", "type": "int"}, {"name": "j", "value": "30", "type": "int"}, {"name": "k", "value": "30", "type": "int"}], "return": {"value": "True", "type": "bool"}}]}, {"name": "rabin_karp_factor", "description": "Find a common factor by Rabin-Karp\n\n    :param string s: haystack\n    :param string t: needle\n    :param int k: factor length\n    :returns: (i, j) such that s[i:i + k] == t[j:j + k] or None.\n              In case of tie, lexicographical minimum (i, j) is returned\n    :complexity: O(len(s) + len(t)) in expected time,\n                and O(len(s) + len(t) * k) in worst case\n    ", "examples": [{"args": [{"name": "s", "value": "'h'", "type": "str"}, {"name": "t", "value": "'h'", "type": "str"}, {"name": "k", "value": "1", "type": "int"}], "return": {"value": "(0, 0)", "type": "tuple"}}, {"args": [{"name": "s", "value": "'h'", "type": "str"}, {"name": "t", "value": "'h'", "type": "str"}, {"name": "k", "value": "2", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "s", "value": "'ab'", "type": "str"}, {"name": "t", "value": "'ab'", "type": "str"}, {"name": "k", "value": "2", "type": "int"}], "return": {"value": "(0, 0)", "type": "tuple"}}, {"args": [{"name": "s", "value": "'ab'", "type": "str"}, {"name": "t", "value": "'ba'", "type": "str"}, {"name": "k", "value": "2", "type": "int"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "s", "value": "'ab'", "type": "str"}, {"name": "t", "value": "'ba'", "type": "str"}, {"name": "k", "value": "1", "type": "int"}], "return": {"value": "(0, 1)", "type": "tuple"}}, {"args": [{"name": "s", "value": "'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'", "type": "str"}, {"name": "t", "value": "'ccccccccccccccccccccccccccccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbcccccccccccccccccccccccccccccc'", "type": "str"}, {"name": "k", "value": "30", "type": "int"}], "return": {"value": "(30, 30)", "type": "tuple"}}]}, {"name": "rabin_karp_matching", "description": "Find a substring by Rabin-Karp\n\n    :param s: the haystack string\n    :param t: the needle string\n\n    :returns: index i such that s[i: i + len(t)] == t, or -1\n    :complexity: O(len(s) + len(t)) in expected time,\n                and O(len(s) * len(t)) in worst case\n    ", "examples": [{"args": [{"name": "s", "value": "'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab'", "type": "str"}, {"name": "t", "value": "'aaaaaaaaaab'", "type": "str"}], "return": {"value": "90", "type": "int"}}, {"args": [{"name": "s", "value": "'8061575318677703578265206043568110115100106197121003230801829591341508593957690922346964515634768785'", "type": "str"}, {"name": "t", "value": "'3824397160'", "type": "str"}], "return": {"value": "-1", "type": "int"}}, {"args": [{"name": "s", "value": "'ab'", "type": "str"}, {"name": "t", "value": "'a'", "type": "str"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "s", "value": "'ab'", "type": "str"}, {"name": "t", "value": "'b'", "type": "str"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "s", "value": "'ab'", "type": "str"}, {"name": "t", "value": "'c'", "type": "str"}], "return": {"value": "-1", "type": "int"}}, {"args": [{"name": "s", "value": "''", "type": "str"}, {"name": "t", "value": "'c'", "type": "str"}], "return": {"value": "-1", "type": "int"}}]}, {"name": "roll_hash", "description": "roll_hash ", "examples": [{"args": [{"name": "old_val", "value": "55036115139339590", "type": "int"}, {"name": "out_digit", "value": "97", "type": "int"}, {"name": "in_digit", "value": "97", "type": "int"}, {"name": "last_pos", "value": "81920", "type": "int"}], "return": {"value": "55036115139339590", "type": "int"}}, {"args": [{"name": "old_val", "value": "55036115139339590", "type": "int"}, {"name": "out_digit", "value": "97", "type": "int"}, {"name": "in_digit", "value": "98", "type": "int"}, {"name": "last_pos", "value": "81920", "type": "int"}], "return": {"value": "55036115139339591", "type": "int"}}, {"args": [{"name": "old_val", "value": "30616637705905576", "type": "int"}, {"name": "out_digit", "value": "56", "type": "int"}, {"name": "in_digit", "value": "54", "type": "int"}, {"name": "last_pos", "value": "640", "type": "int"}], "return": {"value": "27819548303217988", "type": "int"}}, {"args": [{"name": "old_val", "value": "27819548303217988", "type": "int"}, {"name": "out_digit", "value": "48", "type": "int"}, {"name": "in_digit", "value": "55", "type": "int"}, {"name": "last_pos", "value": "640", "type": "int"}], "return": {"value": "30080074949501740", "type": "int"}}, {"args": [{"name": "old_val", "value": "30080074949501740", "type": "int"}, {"name": "out_digit", "value": "54", "type": "int"}, {"name": "in_digit", "value": "55", "type": "int"}, {"name": "last_pos", "value": "640", "type": "int"}], "return": {"value": "31197109521618752", "type": "int"}}, {"args": [{"name": "old_val", "value": "31197109521618752", "type": "int"}, {"name": "out_digit", "value": "49", "type": "int"}, {"name": "in_digit", "value": "55", "type": "int"}, {"name": "last_pos", "value": "640", "type": "int"}], "return": {"value": "30062346677150026", "type": "int"}}, {"args": [{"name": "old_val", "value": "30062346677150026", "type": "int"}, {"name": "out_digit", "value": "53", "type": "int"}, {"name": "in_digit", "value": "48", "type": "int"}, {"name": "last_pos", "value": "640", "type": "int"}], "return": {"value": "28927890660681273", "type": "int"}}, {"args": [{"name": "old_val", "value": "28927890660681273", "type": "int"}, {"name": "out_digit", "value": "55", "type": "int"}, {"name": "in_digit", "value": "51", "type": "int"}, {"name": "last_pos", "value": "640", "type": "int"}], "return": {"value": "27832708628372914", "type": "int"}}, {"args": [{"name": "old_val", "value": "27832708628372914", "type": "int"}, {"name": "out_digit", "value": "53", "type": "int"}, {"name": "in_digit", "value": "53", "type": "int"}, {"name": "last_pos", "value": "640", "type": "int"}], "return": {"value": "31764596568922666", "type": "int"}}, {"args": [{"name": "old_val", "value": "31764596568922666", "type": "int"}, {"name": "out_digit", "value": "51", "type": "int"}, {"name": "in_digit", "value": "55", "type": "int"}, {"name": "last_pos", "value": "640", "type": "int"}], "return": {"value": "30643094693959247", "type": "int"}}]}], "classes": []}, "FR": {"name": "rabin_karp", "description": "Trouver des sous-cha\u00eenes par Rabin-Karp\njill-jenn vie et christoph durr - 2015-2019\n", "functions": [{"name": "matchs", "description": "\nV\u00e9rifie si s[i:i + k] est \u00e9gal \u00e0 t[j:j + k].\nNous avons utilis\u00e9 une boucle pour faciliter la mise en \u0153uvre dans d'autres langues.\n"}, {"name": "rabin_karp_factor", "description": "Trouver un facteur commun par Rabin-Karp\n\n:param string s: botte de foin\n:param string t: aiguille\n:param int k: facteur de longueur\n:renvoie: (i, j) tel que s[i:i + k] == t[j:j + k] ou Aucune.\nEn cas d'\u00e9galit\u00e9, le vocabulaire minimum (i, j) est retourn\u00e9\n:complexit\u00e9: O(len(s) + len(t)) dans le temps pr\u00e9vu,les\net O(len(s) + len(t) * k) dans le pire des cas\n"}, {"name": "rabin_karp_matching", "description": "Rechercher une sous-cha\u00eene par Rabin-Karp\n\n:param s: la botte de foin de la cha\u00eene\n:param t: l'aiguille de la cha\u00eene\n\n:retourne: indice i tel que s[i: i + len(t)] == t, ou -1\n:complexit\u00e9: O(len(s) + len(t)) dans le temps pr\u00e9vu,les\net O(len(s) * len(t)) dans le pire des cas\n"}, {"name": "roll_hash", "description": "roll_hash "}], "classes": []}}, {"EN": {"name": "two_sat", "description": "Solving 2-SAT boolean formulas\njill-jenn vie et christoph durr - 2015-2019\n", "functions": [{"name": "_vertex", "description": null, "examples": [{"args": [{"name": "lit", "value": "-2", "type": "int"}], "return": {"value": "3", "type": "int"}}, {"args": [{"name": "lit", "value": "2", "type": "int"}], "return": {"value": "2", "type": "int"}}, {"args": [{"name": "lit", "value": "1", "type": "int"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "lit", "value": "-1", "type": "int"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "lit", "value": "3", "type": "int"}], "return": {"value": "4", "type": "int"}}, {"args": [{"name": "lit", "value": "-3", "type": "int"}], "return": {"value": "5", "type": "int"}}, {"args": [{"name": "lit", "value": "4", "type": "int"}], "return": {"value": "6", "type": "int"}}, {"args": [{"name": "lit", "value": "-4", "type": "int"}], "return": {"value": "7", "type": "int"}}, {"args": [{"name": "lit", "value": "125", "type": "int"}], "return": {"value": "248", "type": "int"}}, {"args": [{"name": "lit", "value": "-125", "type": "int"}], "return": {"value": "249", "type": "int"}}]}, {"name": "two_sat", "description": "Solving a 2-SAT boolean formula\n\n    :param formula: list of clauses, a clause is pair of literals\n                    over X1,...,Xn for some n.\n                    a literal is an integer, for example -1 = not X1, 3 = X3\n    :returns: table with boolean assignment satisfying the formula or None\n    :complexity: linear\n    ", "examples": [{"args": [{"name": "formula", "value": "[(2, 2)]", "type": "list"}], "return": {"value": "[True, True]", "type": "list"}}, {"args": [{"name": "formula", "value": "[(-1, 1)]", "type": "list"}], "return": {"value": "[True]", "type": "list"}}, {"args": [{"name": "formula", "value": "[[2, -1], [-3, -3], [3, -2], [2, 2]]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "formula", "value": "[[3, -2], [3, 2], [2, -2], [-1, -1]]", "type": "list"}], "return": {"value": "[False, True, True]", "type": "list"}}, {"args": [{"name": "formula", "value": "[(-1, 2), (-1, 3), (-2, -1), (-2, 3)]", "type": "list"}], "return": {"value": "[False, True, True]", "type": "list"}}, {"args": [{"name": "formula", "value": "[(-1, 2), (-2, -1), (1, 3), (-3, 4), (-3, 2), (-4, 1)]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}]}], "classes": []}, "FR": {"name": "two_sat", "description": "La r\u00e9solution de 2-SAT formules bool\u00e9ennes\njill-jenn vie et christoph durr - 2015-2019\n", "functions": [{"name": "_vertex", "description": null}, {"name": "two_sat", "description": "La r\u00e9solution d'un 2-SAT formule bool\u00e9enne\n\n:param formule: liste de clauses, une clause est la paire de litt\u00e9raux\nplus de X1,...,Xn pour n.\nun litt\u00e9ral est un entier, par exemple -1 = pas de X1, 3 = X3\n:retourne: tableau de bool\u00e9ens attribution de la satisfaction de la formule ou Aucun\n:complexit\u00e9: lin\u00e9aire\n"}], "classes": []}}, {"EN": {"name": "permutation_rank", "description": "Permutation rank\nchristoph d\u00fcrr - 2016-2019\n", "functions": [{"name": "permutation_rank", "description": "Given a permutation of {0,..,n-1} find its rank according to\n    lexicographical order\n\n       :param p: list of length n containing all integers from 0 to n-1\n       :returns: rank between 0 and n! -1\n       :beware: computation with big numbers\n       :complexity: `O(n^2)`\n    ", "examples": [{"args": [{"name": "p", "value": "[0, 1, 2, 3]", "type": "list"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "p", "value": "[0, 1, 3, 2]", "type": "list"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "p", "value": "[0, 2, 1, 3]", "type": "list"}], "return": {"value": "2", "type": "int"}}, {"args": [{"name": "p", "value": "[0, 2, 3, 1]", "type": "list"}], "return": {"value": "3", "type": "int"}}, {"args": [{"name": "p", "value": "[0, 3, 1, 2]", "type": "list"}], "return": {"value": "4", "type": "int"}}, {"args": [{"name": "p", "value": "[0, 3, 2, 1]", "type": "list"}], "return": {"value": "5", "type": "int"}}, {"args": [{"name": "p", "value": "[1, 0, 2, 3]", "type": "list"}], "return": {"value": "6", "type": "int"}}, {"args": [{"name": "p", "value": "[1, 0, 3, 2]", "type": "list"}], "return": {"value": "7", "type": "int"}}, {"args": [{"name": "p", "value": "[1, 2, 0, 3]", "type": "list"}], "return": {"value": "8", "type": "int"}}, {"args": [{"name": "p", "value": "[1, 2, 3, 0]", "type": "list"}], "return": {"value": "9", "type": "int"}}]}, {"name": "rank_permutation", "description": "Given r and n find the permutation of {0,..,n-1} with rank according to\n    lexicographical order equal to r\n\n       :param r n: integers with 0 \u2264 r < n!\n       :returns: permutation p as a list of n integers\n       :beware: computation with big numbers\n       :complexity: `O(n^2)`\n    ", "examples": [{"args": [{"name": "r", "value": "0", "type": "int"}, {"name": "n", "value": "4", "type": "int"}], "return": {"value": "[0, 1, 2, 3]", "type": "list"}}, {"args": [{"name": "r", "value": "0", "type": "int"}, {"name": "n", "value": "1", "type": "int"}], "return": {"value": "[0]", "type": "list"}}, {"args": [{"name": "r", "value": "1", "type": "int"}, {"name": "n", "value": "4", "type": "int"}], "return": {"value": "[0, 1, 3, 2]", "type": "list"}}, {"args": [{"name": "r", "value": "0", "type": "int"}, {"name": "n", "value": "2", "type": "int"}], "return": {"value": "[0, 1]", "type": "list"}}, {"args": [{"name": "r", "value": "1", "type": "int"}, {"name": "n", "value": "2", "type": "int"}], "return": {"value": "[1, 0]", "type": "list"}}, {"args": [{"name": "r", "value": "2", "type": "int"}, {"name": "n", "value": "4", "type": "int"}], "return": {"value": "[0, 2, 1, 3]", "type": "list"}}, {"args": [{"name": "r", "value": "3", "type": "int"}, {"name": "n", "value": "4", "type": "int"}], "return": {"value": "[0, 2, 3, 1]", "type": "list"}}, {"args": [{"name": "r", "value": "4", "type": "int"}, {"name": "n", "value": "4", "type": "int"}], "return": {"value": "[0, 3, 1, 2]", "type": "list"}}, {"args": [{"name": "r", "value": "5", "type": "int"}, {"name": "n", "value": "4", "type": "int"}], "return": {"value": "[0, 3, 2, 1]", "type": "list"}}, {"args": [{"name": "r", "value": "0", "type": "int"}, {"name": "n", "value": "3", "type": "int"}], "return": {"value": "[0, 1, 2]", "type": "list"}}]}], "classes": []}, "FR": {"name": "permutation_rank", "description": "Permutation rang\nchristoph d\u00fcrr - 2016-2019\n", "functions": [{"name": "permutation_rank", "description": "Donn\u00e9 une permutation de {0,..,n-1} trouver son rang selon\nl'ordre lexicographique\n\n:param p: liste de longueur n contenant tous les entiers de 0 \u00e0 n-1\n:retourne: rang entre 0 et n! -1\n:attention: le calcul avec les grands nombres\n:complexit\u00e9: O(n^2)`\n"}, {"name": "rank_permutation", "description": "Compte tenu de la r et de n de trouver la permutation de {0,..,n-1}, avec rang selon\nvocabulaire de la commande \u00e9gale \u00e0 r\n\n:param r n: entiers avec 0 \u2264 r < n!\n:retourne: permutation p, comme une liste de n entiers\n:attention: le calcul avec les grands nombres\n:complexit\u00e9: O(n^2)`\n"}], "classes": []}}, {"EN": {"name": "rectangles_from_points", "description": "How many rectangles can be formed from a set of points\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "rectangles_from_points", "description": "How many rectangles can be formed from a set of points\n\n    :param S: list of points, as coordinate pairs\n    :returns: the number of rectangles\n    :complexity: :math:`O(n^2)`\n    ", "examples": [{"args": [{"name": "S", "value": "[(0, 1), (0, 2), (1, 3), (2, 3), (3, 2), (3, 1), (2, 0), (1, 0)]", "type": "list"}], "return": {"value": "6", "type": "int"}}, {"args": [{"name": "S", "value": "[(0, 1), (0, 2), (1, 3), (2, 3), (3, 2), (3, 1), (2, 0)]", "type": "list"}], "return": {"value": "3", "type": "int"}}, {"args": [{"name": "S", "value": "[(0, 1), (0, 2), (1, 3), (2, 3), (3, 2), (3, 1)]", "type": "list"}], "return": {"value": "1", "type": "int"}}, {"args": [{"name": "S", "value": "[(0, 1), (0, 2), (1, 3), (2, 3), (3, 2)]", "type": "list"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "S", "value": "[(0, 1), (0, 2), (1, 3), (2, 3)]", "type": "list"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "S", "value": "[(0, 1), (0, 2), (1, 3)]", "type": "list"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "S", "value": "[(0, 1), (0, 2)]", "type": "list"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "S", "value": "[(0, 1)]", "type": "list"}], "return": {"value": "0", "type": "int"}}]}], "classes": []}, "FR": {"name": "rectangles_from_points", "description": "Combien de rectangles peuvent \u00eatre form\u00e9s \u00e0 partir d'un ensemble de points\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "rectangles_from_points", "description": "Combien de rectangles peuvent \u00eatre form\u00e9s \u00e0 partir d'un ensemble de points\n\n:param S: liste des points de, que les paires de coordonn\u00e9es\n:retourne: le nombre de rectangles\n:complexit\u00e9: :math:`O(n^2)`\n"}], "classes": []}}, {"EN": {"name": "rectangles_from_grid", "description": "Largest area rectangle in a binary matrix\nplus grand rectangle monochromatique\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "rectangles_from_grid", "description": "Largest area rectangle in a binary matrix\n\n    :param P: matrix\n    :param black: search for rectangles filled with value black\n    :returns: area, left, top, right, bottom of optimal rectangle\n             consisting of all (i,j) with\n             left <= j < right and top <= i <= bottom\n    :complexity: linear\n    ", "examples": [{"args": [{"name": "P", "value": "['10110111', '01000101', '11011000', '00111010', '11011101', '01000101']", "type": "list"}, {"name": "black", "value": "'1'", "type": "str"}], "return": {"value": "(6, 3, 4, 5, 1)", "type": "tuple"}}]}], "classes": []}, "FR": {"name": "rectangles_from_grid", "description": "Plus grand rectangle correspondant \u00e0 la zone dans une matrice binaire\nplus grand rectangle monochromatique\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "rectangles_from_grid", "description": "Plus grand rectangle correspondant \u00e0 la zone dans une matrice binaire\n\n:param P: matrice\n:param noir: recherche de rectangles rempli avec une valeur des noirs\n:r\u00e9sultat: domaine, gauche, haut, droite, bas optimale rectangle\ncompos\u00e9 de tous (i,j) avec\ngauche <= j < droite et de haut <= i <= en bas\n:complexit\u00e9: lin\u00e9aire\n"}], "classes": []}}, {"EN": {"name": "arithm_expr_eval", "description": "Evaluate an arithmetic expression\njill-jenn vie et christoph durr - 2014-2018\n\nIPCELLS\nhttp://www.spoj.com/problems/IPCELLS/\n", "functions": [{"name": "_readint", "description": null}, {"name": "arithm_expr_eval", "description": "Evaluates a given expression\n\n    :param expr: expression\n    :param cell: dictionary variable name -> expression\n\n    :returns: numerical value of expression\n\n    :complexity: linear\n    ", "examples": [{"args": [{"name": "cell", "value": "{'ZZ22': 3, 'A47': 8}", "type": "dict"}, {"name": "expr", "value": "13", "type": "int"}], "return": {"value": "13", "type": "int"}}, {"args": [{"name": "cell", "value": "{'ZZ22': 3, 'A47': 8}", "type": "dict"}, {"name": "expr", "value": "8", "type": "int"}], "return": {"value": "8", "type": "int"}}, {"args": [{"name": "cell", "value": "{'ZZ22': 3, 'A47': 8}", "type": "dict"}, {"name": "expr", "value": "'A47'", "type": "str"}], "return": {"value": "8", "type": "int"}}, {"args": [{"name": "cell", "value": "{'ZZ22': 3, 'A47': 8}", "type": "dict"}, {"name": "expr", "value": "3", "type": "int"}], "return": {"value": "3", "type": "int"}}, {"args": [{"name": "cell", "value": "{'ZZ22': 3, 'A47': 8}", "type": "dict"}, {"name": "expr", "value": "'ZZ22'", "type": "str"}], "return": {"value": "3", "type": "int"}}, {"args": [{"name": "cell", "value": "{'ZZ22': 3, 'A47': 8}", "type": "dict"}, {"name": "expr", "value": "('A47', '*', 'ZZ22')", "type": "tuple"}], "return": {"value": "24", "type": "int"}}, {"args": [{"name": "cell", "value": "{'ZZ22': 3, 'A47': 8}", "type": "dict"}, {"name": "expr", "value": "(13, '+', ('A47', '*', 'ZZ22'))", "type": "tuple"}], "return": {"value": "37", "type": "int"}}, {"args": [{"name": "cell", "value": "{'ZZ22': 3, 'A47': 8}", "type": "dict"}, {"name": "expr", "value": "4", "type": "int"}], "return": {"value": "4", "type": "int"}}, {"args": [{"name": "cell", "value": "{'ZZ22': 3, 'A47': 8}", "type": "dict"}, {"name": "expr", "value": "7", "type": "int"}], "return": {"value": "7", "type": "int"}}, {"args": [{"name": "cell", "value": "{'ZZ22': 3, 'A47': 8}", "type": "dict"}, {"name": "expr", "value": "(4, '/', 7)", "type": "tuple"}], "return": {"value": "0", "type": "int"}}]}, {"name": "arithm_expr_parse", "description": "Constructs an arithmetic expression tree\n\n    :param line_tokens: list of token strings containing the expression\n    :returns: expression tree\n\n    :complexity: linear\n    ", "examples": [{"args": [{"name": "line_tokens", "value": "['13', '+', 'A47', '*', 'ZZ22']", "type": "list"}], "return": {"value": "(13, '+', ('A47', '*', 'ZZ22'))", "type": "tuple"}}, {"args": [{"name": "line_tokens", "value": "['4', '/', '7', '+', '4', '/', '7']", "type": "list"}], "return": {"value": "((4, '/', 7), '+', (4, '/', 7))", "type": "tuple"}}, {"args": [{"name": "line_tokens", "value": "['3', '*', '3', '/', '7']", "type": "list"}], "return": {"value": "((3, '*', 3), '/', 7)", "type": "tuple"}}, {"args": [{"name": "line_tokens", "value": "['12']", "type": "list"}], "return": {"value": "12", "type": "int"}}]}], "classes": []}, "FR": {"name": "arithm_expr_eval", "description": "\u00c9valuer une expression arithm\u00e9tique\njill-jenn vie et christoph durr - 2014-2018\n\nIPCELLS\nhttp://www.spoj.com/problems/IPCELLS/\n", "functions": [{"name": "_readint", "description": null}, {"name": "arithm_expr_eval", "description": "\u00c9value une expression donn\u00e9e\n\n:param expr: expression\n:param cellule: dictionnaire nom de la variable -> expression\n\n:retourne: une valeur num\u00e9rique de l'expression\n\n:complexit\u00e9: lin\u00e9aire\n"}, {"name": "arithm_expr_parse", "description": "Construit une expression arithm\u00e9tique arbre\n\n:param line_tokens: liste de jeton de cha\u00eenes de caract\u00e8res contenant l'expression\n:retourne: arborescence d'expression\n\n:complexit\u00e9: lin\u00e9aire\n"}], "classes": []}}, {"EN": {"name": "topological_order", "description": "Topological order\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "topological_order", "description": "Topological sorting by maintaining indegree\n\n    :param graph: directed graph in listlist format, cannot be listdict\n    :returns: list of vertices in order\n    :complexity: `O(|V|+|E|)`\n    ", "examples": [{"args": [{"name": "graph", "value": "[]", "type": "list"}], "return": {"value": "[]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[]]", "type": "list"}], "return": {"value": "[0]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[], [0]]", "type": "list"}], "return": {"value": "[1, 0]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1], []]", "type": "list"}], "return": {"value": "[0, 1]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1, 5], [2, 3, 5], [3], [4, 5], [5], []]", "type": "list"}], "return": {"value": "[0, 1, 2, 3, 4, 5]", "type": "list"}}]}, {"name": "topological_order_dfs", "description": "Topological sorting by depth first search\n\n    :param graph: directed graph in listlist format, cannot be listdict\n    :returns: list of vertices in order\n    :complexity: `O(|V|+|E|)`\n    ", "examples": [{"args": [{"name": "graph", "value": "[]", "type": "list"}], "return": {"value": "[]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[]]", "type": "list"}], "return": {"value": "[0]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[], [0]]", "type": "list"}], "return": {"value": "[1, 0]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1], []]", "type": "list"}], "return": {"value": "[0, 1]", "type": "list"}}, {"args": [{"name": "graph", "value": "[[1, 5], [2, 3, 5], [3], [4, 5], [5], []]", "type": "list"}], "return": {"value": "[0, 1, 2, 3, 4, 5]", "type": "list"}}]}], "classes": []}, "FR": {"name": "topological_order", "description": "L'ordre topologique\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "topological_order", "description": "Le tri topologique par le maintien de indegree\n\n:param graphe: graphe orient\u00e9 dans listlist format, ne peut pas \u00eatre listdict\n:renvoie la liste des sommets dans l'ordre\n:complexit\u00e9: O(|V|+|E|)`\n"}, {"name": "topological_order_dfs", "description": "Le tri topologique en profondeur d'abord de recherche\n\n:param graphe: graphe orient\u00e9 dans listlist format, ne peut pas \u00eatre listdict\n:renvoie la liste des sommets dans l'ordre\n:complexit\u00e9: O(|V|+|E|)`\n"}], "classes": []}}, {"EN": {"name": "dist_grid", "description": "Distances in a grid\njill-jenn vie et christoph durr - 2014-2018\n--------------------------------------------\n", "functions": [{"name": "dist_grid", "description": "Distances in a grid by BFS\n\n    :param grid: matrix with 4-neighborhood\n    :param (int,int) source: pair of row, column ind_ices\n    :param (int,int) target: exploration stops if target is reached\n    :complexity: linear in grid size\n    ", "examples": [{"args": [{"name": "grid", "value": "[['#', '#', '#'], [' ', '#', '#'], [' ', '#', '#'], [' ', '#', '#'], [' ', '#', '#'], [' ', '#', '#'], [' ', '#', '#'], ['#', '#', '#']]", "type": "list"}, {"name": "source", "value": "(1, 0)", "type": "tuple"}, {"name": "target", "value": "(6, 0)", "type": "tuple"}], "return": {"value": "None", "type": "NoneType"}}]}], "classes": []}, "FR": {"name": "dist_grid", "description": "Les Distances dans une grille\njill-jenn vie et christoph durr - 2014-2018\n--------------------------------------------\n", "functions": [{"name": "dist_grid", "description": "Les Distances dans une grille BFS\n\n:param grille: matrice avec le 4-voisinage\n:param (int,int) source: paire de ligne, de colonne ind_ices\n:param (int,int) cible: l'exploration s'arr\u00eate si l'objectif est atteint\n:complexit\u00e9: lin\u00e9aire dans la taille de la grille\n"}], "classes": []}}, {"EN": {"name": "dancing_links", "description": "Exact set cover by the dancing links algorithm\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "cover", "description": null, "examples": [{"args": [{"name": "c", "value": "<tryalgo.dancing_links.Cell object at 0x7efdaeac5ef0>", "type": "Cell"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "c", "value": "<tryalgo.dancing_links.Cell object at 0x7efdaeac5d30>", "type": "Cell"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "c", "value": "<tryalgo.dancing_links.Cell object at 0x7efdaeac5b00>", "type": "Cell"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "c", "value": "<tryalgo.dancing_links.Cell object at 0x7efdaeac5f28>", "type": "Cell"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "c", "value": "<tryalgo.dancing_links.Cell object at 0x7efdaeac5ba8>", "type": "Cell"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "c", "value": "<tryalgo.dancing_links.Cell object at 0x7efdaeac5d68>", "type": "Cell"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "c", "value": "<tryalgo.dancing_links.Cell object at 0x7efdaeac5e10>", "type": "Cell"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "c", "value": "<tryalgo.dancing_links.Cell object at 0x7efdaff906d8>", "type": "Cell"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "c", "value": "<tryalgo.dancing_links.Cell object at 0x7efdaff90a58>", "type": "Cell"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "c", "value": "<tryalgo.dancing_links.Cell object at 0x7efdaff90a20>", "type": "Cell"}], "return": {"value": "None", "type": "NoneType"}}]}, {"name": "dancing_links", "description": "Exact set cover by the dancing links algorithm\n\n    :param size_universe: universe = {0, 1, ..., size_universe - 1}\n    :param sets: list of sets\n    :returns: list of set indices partitioning the universe, or None\n    :complexity: huge\n    ", "examples": [{"args": [{"name": "size_universe", "value": "7", "type": "int"}, {"name": "sets", "value": "[[2, 4, 5], [3, 4, 6], [1, 2, 5], [0, 3], [1, 6], [3, 4, 6]]", "type": "list"}], "return": {"value": "[3, 0, 4]", "type": "list"}}, {"args": [{"name": "size_universe", "value": "1", "type": "int"}, {"name": "sets", "value": "[[0]]", "type": "list"}], "return": {"value": "[0]", "type": "list"}}, {"args": [{"name": "size_universe", "value": "2", "type": "int"}, {"name": "sets", "value": "[[0], [0, 1]]", "type": "list"}], "return": {"value": "[1]", "type": "list"}}]}, {"name": "solve", "description": null, "examples": [{"args": [{"name": "header", "value": "<tryalgo.dancing_links.Cell object at 0x7efdaeac5b70>", "type": "Cell"}, {"name": "sol", "value": "[3, 0, 4]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "header", "value": "<tryalgo.dancing_links.Cell object at 0x7efdaeac5b70>", "type": "Cell"}, {"name": "sol", "value": "[3, 0]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "header", "value": "<tryalgo.dancing_links.Cell object at 0x7efdaeac5b70>", "type": "Cell"}, {"name": "sol", "value": "[3]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "header", "value": "<tryalgo.dancing_links.Cell object at 0x7efdaeac5b70>", "type": "Cell"}, {"name": "sol", "value": "[]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "header", "value": "<tryalgo.dancing_links.Cell object at 0x7efdaff906a0>", "type": "Cell"}, {"name": "sol", "value": "[0]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "header", "value": "<tryalgo.dancing_links.Cell object at 0x7efdaff906a0>", "type": "Cell"}, {"name": "sol", "value": "[]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "header", "value": "<tryalgo.dancing_links.Cell object at 0x7efdaff909b0>", "type": "Cell"}, {"name": "sol", "value": "[1]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "header", "value": "<tryalgo.dancing_links.Cell object at 0x7efdaff909b0>", "type": "Cell"}, {"name": "sol", "value": "[]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "header", "value": "<tryalgo.dancing_links.Cell object at 0x7efda96d8be0>", "type": "Cell"}, {"name": "sol", "value": "[4096, 198, 1350, 1856, 1899, 1367, 1388, 1620, 1640, 1134, 1193, 1584, 2377, 3118, 3090, 3762, 3734, 3787, 3591, 2366, 1079, 1687, 1564, 3884, 3382, 1046, 539, 1323, 1469, 1441, 1935, 1037, 1283]", "type": "list"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "header", "value": "<tryalgo.dancing_links.Cell object at 0x7efda96d8be0>", "type": "Cell"}, {"name": "sol", "value": "[4096, 198, 1350, 1856, 1899, 1367, 1388, 1620, 1640, 1134, 1193, 1584, 2377, 3118, 3090, 3762, 3734, 3787, 3591, 2366, 1079, 1687, 1564, 3884, 3382, 1046, 539, 1323, 1469, 1441, 1935, 1037]", "type": "list"}], "return": {"value": "True", "type": "bool"}}]}, {"name": "uncover", "description": null, "examples": [{"args": [{"name": "c", "value": "<tryalgo.dancing_links.Cell object at 0x7efdafea92e8>", "type": "Cell"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "c", "value": "<tryalgo.dancing_links.Cell object at 0x7efdafeaf4e0>", "type": "Cell"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "c", "value": "<tryalgo.dancing_links.Cell object at 0x7efdafebb320>", "type": "Cell"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "c", "value": "<tryalgo.dancing_links.Cell object at 0x7efdafec7160>", "type": "Cell"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "c", "value": "<tryalgo.dancing_links.Cell object at 0x7efdafeaaba8>", "type": "Cell"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "c", "value": "<tryalgo.dancing_links.Cell object at 0x7efdafeaf588>", "type": "Cell"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "c", "value": "<tryalgo.dancing_links.Cell object at 0x7efdafebb048>", "type": "Cell"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "c", "value": "<tryalgo.dancing_links.Cell object at 0x7efdafec4e48>", "type": "Cell"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "c", "value": "<tryalgo.dancing_links.Cell object at 0x7efdafeaaf28>", "type": "Cell"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "c", "value": "<tryalgo.dancing_links.Cell object at 0x7efdafea9d68>", "type": "Cell"}], "return": {"value": "None", "type": "NoneType"}}]}], "classes": [{"name": "Cell", "description": null, "methods": [{"name": "__init__", "description": null}, {"name": "hide_horiz", "description": null}, {"name": "hide_verti", "description": null}, {"name": "unhide_horiz", "description": null}, {"name": "unhide_verti", "description": null}]}]}, "FR": {"name": "dancing_links", "description": "Jeu Exact de couverture par la danse des liens algorithme\njill-jenn vie et christoph durr - 2014-2018\n", "functions": [{"name": "couvrir", "description": null}, {"name": "dancing_links", "description": "Jeu Exact de couverture par la danse des liens algorithme\n\n:param size_universe: univers = {0, 1, ..., size_universe - 1}\n:ensembles de param: liste de jeux\n:retourne: liste des indices de partitionnement de l'univers, ou Aucun\n:complexit\u00e9: \u00e9norme\n"}, {"name": "r\u00e9soudre", "description": null}, {"name": "d\u00e9couvrir", "description": null}], "classes": [{"name": "La cellule", "description": null, "methods": [{"name": "__init__", "description": null}, {"name": "hide_horiz", "description": null}, {"name": "hide_verti", "description": null}, {"name": "unhide_horiz", "description": null}, {"name": "unhide_verti", "description": null}]}]}}, {"EN": {"name": "max_interval_intersec", "description": "Sweepline algorithm technique\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "max_interval_intersec", "description": "determine a value that is contained in a largest number\n    of given intervals\n\n    :param S: list of half open intervals\n    :complexity: O(n log n), where n = len(S)\n    ", "examples": [{"args": [{"name": "S", "value": "[(0, 2)]", "type": "list"}], "return": {"value": "(1, 0)", "type": "tuple"}}, {"args": [{"name": "S", "value": "[]", "type": "list"}], "return": {"value": "(0, None)", "type": "tuple"}}, {"args": [{"name": "S", "value": "[(0, 2), (2, 4)]", "type": "list"}], "return": {"value": "(1, 0)", "type": "tuple"}}, {"args": [{"name": "S", "value": "[(0, 2), (1, 4)]", "type": "list"}], "return": {"value": "(2, 1)", "type": "tuple"}}, {"args": [{"name": "S", "value": "[(0, 2), (3, 4)]", "type": "list"}], "return": {"value": "(1, 0)", "type": "tuple"}}, {"args": [{"name": "S", "value": "[(0, 2), (0, 6), (1, 5), (2, 5), (2, 5), (4, 8), (7, 8)]", "type": "list"}], "return": {"value": "(5, 4)", "type": "tuple"}}]}], "classes": []}, "FR": {"name": "max_interval_intersec", "description": "Sweepline algorithme de la technique\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "max_interval_intersec", "description": "d\u00e9terminer une valeur qui est contenue dans un plus grand nombre\ndes intervalles r\u00e9guliers\n\n:param S: liste de la moiti\u00e9 ouvert intervalles\n:complexit\u00e9: O(n log n), o\u00f9 n = len(S)\n"}], "classes": []}}, {"EN": {"name": "anagrams", "description": "Anagrams\nchristoph d\u00fcrr - jill-j\u00eann vie - 2013-2019\n", "functions": [{"name": "anagrams", "description": "group a set of words into anagrams\n\n    :param S: set of strings\n    :returns: list of lists of strings\n\n    :complexity:\n        :math:`O(n k log k)` in average, for n words of length at most k.\n        :math:`O(n^2 k log k)` in worst case due to the usage of a dictionary.\n    ", "examples": [{"args": [{"name": "S", "value": "{'lui', 'chine', 'sa', 'marche', 'chien', 'niche', 'vers', 'et', 'pleine', 'limace', 'trouve', 'malice', 'fait', 'de', 'du', 'qui', 'nue', 'une', 'charme', 'le'}", "type": "set"}], "return": {"value": "[['chine', 'chien', 'niche'], ['marche', 'charme'], ['limace', 'malice'], ['nue', 'une']]", "type": "list"}}, {"args": [{"name": "S", "value": "{'baa', 'abb', 'aba'}", "type": "set"}], "return": {"value": "[['baa', 'aba']]", "type": "list"}}, {"args": [{"name": "S", "value": "{'aba'}", "type": "set"}], "return": {"value": "[]", "type": "list"}}, {"args": [{"name": "S", "value": "{}", "type": "dict"}], "return": {"value": "[]", "type": "list"}}]}], "classes": []}, "FR": {"name": "les anagrammes", "description": "Les anagrammes\nchristoph d\u00fcrr - jill-j\u00eann vie - 2013-2019\n", "functions": [{"name": "les anagrammes", "description": "groupe un ensemble de mots en anagrammes\n\n:param S: ensemble de cha\u00eenes\n:retourne: liste de listes de cha\u00eenes\n\n:complexit\u00e9:\n:math:`O(n k log k)` en moyenne, pour les n mots de longueur au plus k.\n:math:`O(n^2 k log k)` dans le pire des cas en raison de l'utilisation d'un dictionnaire.\n"}], "classes": []}}, {"EN": {"name": "scalar", "description": "Permute vector to minimize scalar product\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "min_scalar_prod", "description": "Permute vector to minimize scalar product\n\n    :param x:\n    :param y: x, y are vectors of same size\n    :returns: min sum x[i] * y[sigma[i]] over all permutations sigma\n    :complexity: O(n log n)\n    ", "examples": [{"args": [{"name": "x", "value": "[0, 4, 5, 7, 8, 1, 2, 9, 6, 3]", "type": "list"}, {"name": "y", "value": "[6, 9, 2, 4, 5, 8, 1, 3, 7, 0]", "type": "list"}], "return": {"value": "120", "type": "int"}}]}], "classes": []}, "FR": {"name": "scalaire", "description": "Permuter vecteur pour minimiser le produit scalaire\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "min_scalar_prod", "description": "Permuter vecteur pour minimiser le produit scalaire\n\n:param x:\n:param y: x, y sont des vecteurs de m\u00eame taille\n:retourne: min somme x[i] * y[sigma[i]] sur toutes les permutations sigma\n:complexit\u00e9: O(n log n)\n"}], "classes": []}}, {"EN": {"name": "closest_points", "description": "Closest pair of points\ntrouver la paire de points la plus proche\njill-j\u00eann vie, christoph d\u00fcrr et louis abraham - 2014-2019\n", "functions": [{"name": "cell", "description": " returns the grid cell coordinates containing the given point.\n    size is the side length of a grid cell\n\n    beware: in other languages negative coordinates need special care\n    in C++ for example int(-1.5) == -1 and not -2 as we need\n    hence we need floor(x / pas) in C++ using #include <cmath>\n    ", "examples": [{"args": [{"name": "point", "value": "(2229, 2229)", "type": "tuple"}, {"name": "size", "value": "1062.781492123381", "type": "float"}], "return": {"value": "(2, 2)", "type": "tuple"}}, {"args": [{"name": "point", "value": "(726, 726)", "type": "tuple"}, {"name": "size", "value": "1062.781492123381", "type": "float"}], "return": {"value": "(0, 0)", "type": "tuple"}}, {"args": [{"name": "point", "value": "(1170, 1170)", "type": "tuple"}, {"name": "size", "value": "1062.781492123381", "type": "float"}], "return": {"value": "(1, 1)", "type": "tuple"}}, {"args": [{"name": "point", "value": "(2229, 2229)", "type": "tuple"}, {"name": "size", "value": "313.9554108468271", "type": "float"}], "return": {"value": "(7, 7)", "type": "tuple"}}, {"args": [{"name": "point", "value": "(726, 726)", "type": "tuple"}, {"name": "size", "value": "313.9554108468271", "type": "float"}], "return": {"value": "(2, 2)", "type": "tuple"}}, {"args": [{"name": "point", "value": "(1170, 1170)", "type": "tuple"}, {"name": "size", "value": "313.9554108468271", "type": "float"}], "return": {"value": "(3, 3)", "type": "tuple"}}, {"args": [{"name": "point", "value": "(840, 840)", "type": "tuple"}, {"name": "size", "value": "313.9554108468271", "type": "float"}], "return": {"value": "(2, 2)", "type": "tuple"}}, {"args": [{"name": "point", "value": "(2229, 2229)", "type": "tuple"}, {"name": "size", "value": "80.61017305526642", "type": "float"}], "return": {"value": "(27, 27)", "type": "tuple"}}, {"args": [{"name": "point", "value": "(726, 726)", "type": "tuple"}, {"name": "size", "value": "80.61017305526642", "type": "float"}], "return": {"value": "(9, 9)", "type": "tuple"}}, {"args": [{"name": "point", "value": "(1170, 1170)", "type": "tuple"}, {"name": "size", "value": "80.61017305526642", "type": "float"}], "return": {"value": "(14, 14)", "type": "tuple"}}]}, {"name": "closest_points", "description": "Closest pair of points\n\n    :param S: list of points\n    :requires: size of S at least 2\n    :modifies: changes the order in S\n    :returns: pair of points p,q from S with minimum Euclidean distance\n    :complexity: expected linear time\n    ", "examples": [{"args": [{"name": "S", "value": "[(0, 0), (1, 1)]", "type": "list"}], "return": {"value": "((1, 1), (0, 0))", "type": "tuple"}}]}, {"name": "dist", "description": null, "examples": [{"args": [{"name": "p", "value": "(2229, 2229)", "type": "tuple"}, {"name": "q", "value": "(726, 726)", "type": "tuple"}], "return": {"value": "2125.562984246762", "type": "float"}}, {"args": [{"name": "p", "value": "(726, 726)", "type": "tuple"}, {"name": "q", "value": "(2229, 2229)", "type": "tuple"}], "return": {"value": "2125.562984246762", "type": "float"}}, {"args": [{"name": "p", "value": "(1170, 1170)", "type": "tuple"}, {"name": "q", "value": "(726, 726)", "type": "tuple"}], "return": {"value": "627.9108216936542", "type": "float"}}, {"args": [{"name": "p", "value": "(840, 840)", "type": "tuple"}, {"name": "q", "value": "(726, 726)", "type": "tuple"}], "return": {"value": "161.22034611053283", "type": "float"}}, {"args": [{"name": "p", "value": "(1074, 1074)", "type": "tuple"}, {"name": "q", "value": "(1170, 1170)", "type": "tuple"}], "return": {"value": "135.7645019878171", "type": "float"}}, {"args": [{"name": "p", "value": "(2280, 2280)", "type": "tuple"}, {"name": "q", "value": "(2229, 2229)", "type": "tuple"}], "return": {"value": "72.12489168102785", "type": "float"}}, {"args": [{"name": "p", "value": "(1092, 1092)", "type": "tuple"}, {"name": "q", "value": "(1074, 1074)", "type": "tuple"}], "return": {"value": "25.45584412271571", "type": "float"}}, {"args": [{"name": "p", "value": "(1167, 1167)", "type": "tuple"}, {"name": "q", "value": "(1170, 1170)", "type": "tuple"}], "return": {"value": "4.242640687119285", "type": "float"}}, {"args": [{"name": "p", "value": "(2226, 2226)", "type": "tuple"}, {"name": "q", "value": "(2223, 2223)", "type": "tuple"}], "return": {"value": "4.242640687119285", "type": "float"}}, {"args": [{"name": "p", "value": "(2226, 2226)", "type": "tuple"}, {"name": "q", "value": "(2229, 2229)", "type": "tuple"}], "return": {"value": "4.242640687119285", "type": "float"}}]}, {"name": "improve", "description": null, "examples": [{"args": [{"name": "S", "value": "[(1, 1), (0, 0)]", "type": "list"}, {"name": "d", "value": "1.4142135623730951", "type": "float"}], "return": {"value": "None", "type": "NoneType"}}]}], "classes": []}, "FR": {"name": "closest_points", "description": "Paire de points les plus proches\ntrouver la paire de points la plus proche\njill-j\u00eann vie, christoph d\u00fcrr et louis abraham - 2014-2019\n", "functions": [{"name": "la cellule", "description": " renvoie la grille des coordonn\u00e9es des cellules contenant le point donn\u00e9.\nla taille est la longueur du c\u00f4t\u00e9 d'une cellule de grille\n\nattention: dans d'autres langues des coordonn\u00e9es n\u00e9gatives besoin de soins sp\u00e9ciaux\nen C++ par exemple int(-1.5) == -1 et pas -2 comme nous avons besoin de\ndonc nous avons besoin d'\u00e9tage(x / pas) en C++ \u00e0 l'aide de #include <cmath>\n"}, {"name": "closest_points", "description": "Paire de points les plus proches\n\n:param S: liste des points de\n:n\u00e9cessite: taille du S au moins 2\n:modifie: change l'ordre dans S\n:retourne: paire de points p,q de S avec un minimum de distance Euclidienne\n:complexit\u00e9: attendu lin\u00e9aire dans le temps\n"}, {"name": "dist", "description": null}, {"name": "am\u00e9liorer", "description": null}], "classes": []}}, {"EN": {"name": "knapsack", "description": "Knapsack\njill-j\u00eann vie et christoph d\u00fcrr - 2015-2019\n", "functions": [{"name": "knapsack", "description": "Knapsack problem: select maximum value set of items if total size not\n    more than capacity\n\n    :param p: table with size of items\n    :param v: table with value of items\n    :param cmax: capacity of bag\n    :requires: number of items non-zero\n    :returns: value optimal solution, list of item indexes in solution\n    :complexity: O(n * cmax), for n = number of items\n    ", "examples": [{"args": [{"name": "p", "value": "[580, 1616, 1906, 1942, 50, 294]", "type": "list"}, {"name": "v", "value": "[874, 620, 345, 269, 360, 470]", "type": "list"}, {"name": "cmax", "value": "2000", "type": "int"}], "return": {"value": "(1704, [5, 4, 0])", "type": "tuple"}}, {"args": [{"name": "p", "value": "[2, 3, 5]", "type": "list"}, {"name": "v", "value": "[6, 4, 2]", "type": "list"}, {"name": "cmax", "value": "9", "type": "int"}], "return": {"value": "(10, [1, 0])", "type": "tuple"}}, {"args": [{"name": "p", "value": "[5, 4, 3, 2, 1]", "type": "list"}, {"name": "v", "value": "[30, 19, 20, 10, 20]", "type": "list"}, {"name": "cmax", "value": "10", "type": "int"}], "return": {"value": "(70, [4, 2, 0])", "type": "tuple"}}, {"args": [{"name": "p", "value": "[3, 3, 2, 2, 2]", "type": "list"}, {"name": "v", "value": "[40, 40, 10, 20, 30]", "type": "list"}, {"name": "cmax", "value": "7", "type": "int"}], "return": {"value": "(90, [4, 3, 0])", "type": "tuple"}}, {"args": [{"name": "p", "value": "[2]", "type": "list"}, {"name": "v", "value": "[42]", "type": "list"}, {"name": "cmax", "value": "1", "type": "int"}], "return": {"value": "(0, [])", "type": "tuple"}}, {"args": [{"name": "p", "value": "[1]", "type": "list"}, {"name": "v", "value": "[42]", "type": "list"}, {"name": "cmax", "value": "0", "type": "int"}], "return": {"value": "(0, [])", "type": "tuple"}}]}, {"name": "knapsack2", "description": "Knapsack problem: select maximum value set of items if total size not\n    more than capacity.\n    alternative implementation with same behavior.\n\n    :param p: table with size of items\n    :param v: table with value of items\n    :param cmax: capacity of bag\n    :requires: number of items non-zero\n    :returns: value optimal solution, list of item indexes in solution\n    :complexity: O(n * cmax), for n = number of items\n    "}], "classes": []}, "FR": {"name": "sac \u00e0 dos", "description": "Sac \u00e0 dos\njill-j\u00eann vie et christoph d\u00fcrr - 2015-2019\n", "functions": [{"name": "sac \u00e0 dos", "description": "Probl\u00e8me de sac-\u00e0-dos: s\u00e9lectionnez le maximum de valeur ensemble d'\u00e9l\u00e9ments si la taille totale pas\nplus de capacit\u00e9\n\n:param p: tableau avec la taille des \u00e9l\u00e9ments\n:param v: tableau avec la valeur des articles\n:param cmax: capacit\u00e9 du sac\n:n\u00e9cessite: le nombre d'\u00e9l\u00e9ments non nuls\n:retourne: valeur de la solution optimale, la liste de l'\u00e9l\u00e9ment d'index dans la solution\n:complexit\u00e9: O(n * cmax), pour n = nombre d'\u00e9l\u00e9ments\n"}, {"name": "knapsack2", "description": "Probl\u00e8me de sac-\u00e0-dos: s\u00e9lectionnez le maximum de valeur ensemble d'\u00e9l\u00e9ments si la taille totale pas\nplus de capacit\u00e9.\nla variante de mise en \u0153uvre avec le m\u00eame comportement.\n\n:param p: tableau avec la taille des \u00e9l\u00e9ments\n:param v: tableau avec la valeur des articles\n:param cmax: capacit\u00e9 du sac\n:n\u00e9cessite: le nombre d'\u00e9l\u00e9ments non nuls\n:retourne: valeur de la solution optimale, la liste de l'\u00e9l\u00e9ment d'index dans la solution\n:complexit\u00e9: O(n * cmax), pour n = nombre d'\u00e9l\u00e9ments\n"}], "classes": []}}, {"EN": {"name": "union_rectangles", "description": "Union of rectangles\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "rectangles_contains_point", "description": "Decides if at least one of the given rectangles contains a given point\n    either strictly or on its left or top border\n    ", "examples": [{"args": [{"name": "R", "value": "[(0, 0, 5, 10)]", "type": "list"}, {"name": "x", "value": "0", "type": "int"}, {"name": "y", "value": "0", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "R", "value": "[(0, 0, 3, 5), (1, 3, 2, 4), (0, 2, 5, 4), (4, 0, 6, 2), (7, 2, 10, 3)]", "type": "list"}, {"name": "x", "value": "0", "type": "int"}, {"name": "y", "value": "0", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "R", "value": "[(0, 0, 3, 5), (1, 3, 2, 4), (0, 2, 5, 4), (4, 0, 6, 2), (7, 2, 10, 3)]", "type": "list"}, {"name": "x", "value": "0", "type": "int"}, {"name": "y", "value": "2", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "R", "value": "[(0, 0, 3, 5), (1, 3, 2, 4), (0, 2, 5, 4), (4, 0, 6, 2), (7, 2, 10, 3)]", "type": "list"}, {"name": "x", "value": "0", "type": "int"}, {"name": "y", "value": "3", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "R", "value": "[(0, 0, 3, 5), (1, 3, 2, 4), (0, 2, 5, 4), (4, 0, 6, 2), (7, 2, 10, 3)]", "type": "list"}, {"name": "x", "value": "0", "type": "int"}, {"name": "y", "value": "4", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "R", "value": "[(0, 0, 3, 5), (1, 3, 2, 4), (0, 2, 5, 4), (4, 0, 6, 2), (7, 2, 10, 3)]", "type": "list"}, {"name": "x", "value": "1", "type": "int"}, {"name": "y", "value": "0", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "R", "value": "[(0, 0, 3, 5), (1, 3, 2, 4), (0, 2, 5, 4), (4, 0, 6, 2), (7, 2, 10, 3)]", "type": "list"}, {"name": "x", "value": "1", "type": "int"}, {"name": "y", "value": "2", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "R", "value": "[(0, 0, 3, 5), (1, 3, 2, 4), (0, 2, 5, 4), (4, 0, 6, 2), (7, 2, 10, 3)]", "type": "list"}, {"name": "x", "value": "1", "type": "int"}, {"name": "y", "value": "3", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "R", "value": "[(0, 0, 3, 5), (1, 3, 2, 4), (0, 2, 5, 4), (4, 0, 6, 2), (7, 2, 10, 3)]", "type": "list"}, {"name": "x", "value": "1", "type": "int"}, {"name": "y", "value": "4", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "R", "value": "[(0, 0, 3, 5), (1, 3, 2, 4), (0, 2, 5, 4), (4, 0, 6, 2), (7, 2, 10, 3)]", "type": "list"}, {"name": "x", "value": "2", "type": "int"}, {"name": "y", "value": "0", "type": "int"}], "return": {"value": "True", "type": "bool"}}]}, {"name": "union_intervals", "description": "Size of the union of a set of intervals\n\n    Sweep from left to right.\n    Maintain in a counter number of opened intervals\n    minus number of closed intervals.\n\n    :param intervals: Counter, which describes a multiset of intervals.\n        an interval is a pair of values.\n    :returns: size of the union of those intervals\n    :complexity: :math:`O(n \\log n)`\n    ", "examples": [{"args": [{"name": "intervals", "value": "Counter()", "type": "Counter"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "intervals", "value": "Counter({(0, 5): 1})", "type": "Counter"}], "return": {"value": "5", "type": "int"}}, {"args": [{"name": "intervals", "value": "Counter({(0, 3): 1})", "type": "Counter"}], "return": {"value": "3", "type": "int"}}, {"args": [{"name": "intervals", "value": "Counter({(0, 3): 1, (4, 6): 1})", "type": "Counter"}], "return": {"value": "5", "type": "int"}}, {"args": [{"name": "intervals", "value": "Counter({(0, 3): 1, (4, 6): 0})", "type": "Counter"}], "return": {"value": "3", "type": "int"}}, {"args": [{"name": "intervals", "value": "Counter({(0, 3): 1, (0, 5): 1, (4, 6): 0})", "type": "Counter"}], "return": {"value": "5", "type": "int"}}, {"args": [{"name": "intervals", "value": "Counter({(0, 3): 1, (0, 5): 1, (7, 10): 1, (4, 6): 0})", "type": "Counter"}], "return": {"value": "8", "type": "int"}}, {"args": [{"name": "intervals", "value": "Counter({(0, 3): 1, (0, 5): 1, (4, 6): 0, (7, 10): 0})", "type": "Counter"}], "return": {"value": "5", "type": "int"}}, {"args": [{"name": "intervals", "value": "Counter({(0, 3): 1, (0, 5): 1, (1, 2): 1, (4, 6): 0, (7, 10): 0})", "type": "Counter"}], "return": {"value": "5", "type": "int"}}, {"args": [{"name": "intervals", "value": "Counter({(0, 3): 1, (1, 2): 1, (4, 6): 0, (0, 5): 0, (7, 10): 0})", "type": "Counter"}], "return": {"value": "3", "type": "int"}}]}, {"name": "union_rectangles", "description": "Area of union of rectangles.\n\n    Sweep from top to bottom.\n    Maintain in a set the horizontal projection of rectangles,\n    for which the top border has been processed but not yet the bottom.\n\n    :param R: list of rectangles defined by (x1, y1, x2, y2)\n       where (x1, y1) is top left corner and (x2, y2) bottom right corner\n    :returns: area\n    :complexity: :math:`O(n^2 \\log n)`\n    ", "examples": [{"args": [{"name": "R", "value": "[]", "type": "list"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "R", "value": "[(0, 0, 5, 10)]", "type": "list"}], "return": {"value": "50", "type": "int"}}, {"args": [{"name": "R", "value": "[(0, 0, 3, 5), (1, 3, 2, 4), (0, 2, 5, 4), (4, 0, 6, 2), (7, 2, 10, 3)]", "type": "list"}], "return": {"value": "26", "type": "int"}}, {"args": [{"name": "R", "value": "[(0, 0, 1, 2), (0, 1, 1, 3)]", "type": "list"}], "return": {"value": "3", "type": "int"}}, {"args": [{"name": "R", "value": "[(0, 0, 2, 1), (1, 0, 3, 1)]", "type": "list"}], "return": {"value": "3", "type": "int"}}, {"args": [{"name": "R", "value": "[(0, 0, 2, 2), (0, 0, 2, 2)]", "type": "list"}], "return": {"value": "4", "type": "int"}}]}, {"name": "union_rectangles_fast", "description": "Area of union of rectangles\n\n    :param R: list of rectangles defined by (x1, y1, x2, y2)\n       where (x1, y1) is top left corner and (x2, y2) bottom right corner\n    :returns: area\n    :complexity: :math:`O(n^2)`\n    ", "examples": [{"args": [{"name": "R", "value": "[]", "type": "list"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "R", "value": "[(0, 0, 5, 10)]", "type": "list"}], "return": {"value": "50", "type": "int"}}, {"args": [{"name": "R", "value": "[(0, 0, 3, 5), (1, 3, 2, 4), (0, 2, 5, 4), (4, 0, 6, 2), (7, 2, 10, 3)]", "type": "list"}], "return": {"value": "26", "type": "int"}}, {"args": [{"name": "R", "value": "[(0, 0, 1, 2), (0, 1, 1, 3)]", "type": "list"}], "return": {"value": "3", "type": "int"}}, {"args": [{"name": "R", "value": "[(0, 0, 2, 1), (1, 0, 3, 1)]", "type": "list"}], "return": {"value": "3", "type": "int"}}, {"args": [{"name": "R", "value": "[(0, 0, 2, 2), (0, 0, 2, 2)]", "type": "list"}], "return": {"value": "4", "type": "int"}}]}, {"name": "union_rectangles_fastest", "description": "Area of union of rectangles\n\n    :param R: list of rectangles defined by (x1, y1, x2, y2)\n       where (x1, y1) is top left corner and (x2, y2) bottom right corner\n    :returns: area\n    :complexity: :math:`O(n \\log n)`\n    ", "examples": [{"args": [{"name": "R", "value": "[]", "type": "list"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "R", "value": "[(0, 0, 5, 10)]", "type": "list"}], "return": {"value": "50", "type": "int"}}, {"args": [{"name": "R", "value": "[(0, 0, 3, 5), (1, 3, 2, 4), (0, 2, 5, 4), (4, 0, 6, 2), (7, 2, 10, 3)]", "type": "list"}], "return": {"value": "26", "type": "int"}}, {"args": [{"name": "R", "value": "[(0, 0, 1, 2), (0, 1, 1, 3)]", "type": "list"}], "return": {"value": "3", "type": "int"}}, {"args": [{"name": "R", "value": "[(0, 0, 2, 1), (1, 0, 3, 1)]", "type": "list"}], "return": {"value": "3", "type": "int"}}, {"args": [{"name": "R", "value": "[(0, 0, 2, 2), (0, 0, 2, 2)]", "type": "list"}], "return": {"value": "4", "type": "int"}}]}, {"name": "union_rectangles_naive", "description": "Area of union of rectangles\n\n    :param R: list of rectangles defined by (x1, y1, x2, y2)\n       where (x1, y1) is top left corner and (x2, y2) bottom right corner\n    :returns: area\n    :complexity: :math:`O(n^3)`\n    ", "examples": [{"args": [{"name": "R", "value": "[]", "type": "list"}], "return": {"value": "0", "type": "int"}}, {"args": [{"name": "R", "value": "[(0, 0, 5, 10)]", "type": "list"}], "return": {"value": "50", "type": "int"}}, {"args": [{"name": "R", "value": "[(0, 0, 3, 5), (1, 3, 2, 4), (0, 2, 5, 4), (4, 0, 6, 2), (7, 2, 10, 3)]", "type": "list"}], "return": {"value": "26", "type": "int"}}, {"args": [{"name": "R", "value": "[(0, 0, 1, 2), (0, 1, 1, 3)]", "type": "list"}], "return": {"value": "3", "type": "int"}}, {"args": [{"name": "R", "value": "[(0, 0, 2, 1), (1, 0, 3, 1)]", "type": "list"}], "return": {"value": "3", "type": "int"}}, {"args": [{"name": "R", "value": "[(0, 0, 2, 2), (0, 0, 2, 2)]", "type": "list"}], "return": {"value": "4", "type": "int"}}]}], "classes": [{"name": "CoverQuery", "description": "Segment tree to maintain a set of integer intervals\n    and permitting to query the size of their union.\n    ", "methods": [{"name": "__init__", "description": "creates a structure, where all possible intervals\n        will be included in [0, L - 1].\n        "}, {"name": "_change", "description": null}, {"name": "change", "description": "when offset = +1, adds an interval [i, k],\n        when offset = -1, removes it\n        :complexity: O(log L)\n        "}, {"name": "cover", "description": ":returns: the size of the union of the stored intervals\n        "}]}]}, "FR": {"name": "union_rectangles", "description": "Union des rectangles\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "rectangles_contains_point", "description": "D\u00e9cide si au moins l'une des rectangles contient un point donn\u00e9\nsoit strictement ou sur sa gauche ou en haut de la fronti\u00e8re\n"}, {"name": "union_intervals", "description": "La taille de l'union d'un ensemble d'intervalles\n\nBalayage de gauche \u00e0 droite.\nMaintenir dans un num\u00e9ro de compteur d'intervalles ouverts\nmoins nombre d'intervalles ferm\u00e9s.\n\n:param intervalles: Compteur, qui d\u00e9crit un multiset d'intervalles.\nun intervalle est une paire de valeurs.\n:retourne: la taille de l'union de ces intervalles\n:complexit\u00e9: :math:`O(n \\log n)`\n"}, {"name": "union_rectangles", "description": "La zone de l'union des rectangles.\n\nBalayage du haut vers le bas.\nMaintenir dans un jeu de la projection horizontale de rectangles,\npour ce qui de la fronti\u00e8re sup\u00e9rieure a \u00e9t\u00e9 trait\u00e9e, mais pas encore la bas.\n\n:param R: liste de rectangles d\u00e9finis par (x1, y1, x2, y2)\no\u00f9 (x1, y1) est en haut \u00e0 gauche et (x2, y2) coin en bas \u00e0 droite\n:r\u00e9sultat: domaine\n:complexit\u00e9: :math:`O(n^2 \\log n)`\n"}, {"name": "union_rectangles_fast", "description": "La zone de l'union des rectangles\n\n:param R: liste de rectangles d\u00e9finis par (x1, y1, x2, y2)\no\u00f9 (x1, y1) est en haut \u00e0 gauche et (x2, y2) coin en bas \u00e0 droite\n:r\u00e9sultat: domaine\n:complexit\u00e9: :math:`O(n^2)`\n"}, {"name": "union_rectangles_fastest", "description": "La zone de l'union des rectangles\n\n:param R: liste de rectangles d\u00e9finis par (x1, y1, x2, y2)\no\u00f9 (x1, y1) est en haut \u00e0 gauche et (x2, y2) coin en bas \u00e0 droite\n:r\u00e9sultat: domaine\n:complexit\u00e9: :math:`O(n \\log n)`\n"}, {"name": "union_rectangles_naive", "description": "La zone de l'union des rectangles\n\n:param R: liste de rectangles d\u00e9finis par (x1, y1, x2, y2)\no\u00f9 (x1, y1) est en haut \u00e0 gauche et (x2, y2) coin en bas \u00e0 droite\n:r\u00e9sultat: domaine\n:complexit\u00e9: :math:`O(n^3)`\n"}], "classes": [{"name": "CoverQuery", "description": "Segment de l'arbre afin de maintenir un ensemble d'entiers \u00e0 intervalles\net de permettre \u00e0 la requ\u00eate de la taille de leur union.\n", "methods": [{"name": "__init__", "description": "cr\u00e9e une structure, o\u00f9 tout est possible intervalles\nseront inclus dans [0, L - 1].\n"}, {"name": "_change", "description": null}, {"name": "changement", "description": "quand offset = +1, ajoute un intervalle [i, k],\nquand offset = -1, la supprime\n:complexit\u00e9: O(log L)\n"}, {"name": "couvrir", "description": ":renvoie la taille de l'union de la stock\u00e9es intervalles\n"}]}]}}, {"EN": {"name": "bfs", "description": "Breadth-first search, bfs and OurQueue\nchristoph d\u00fcrr - jill-j\u00eann vie - 2015-2019\n", "functions": [{"name": "bfs", "description": "Shortest path in unweighted graph by BFS\n\n       :param graph: directed graph in listlist or listdict format\n       :param int start: source vertex\n       :returns: distance table, precedence table\n       :complexity: `O(|V|+|E|)`\n       ", "examples": [{"args": [{"name": "graph", "value": "[[1, 2, 3, 4, 5, 6], [0, 2, 3, 4, 5, 6], [0, 1, 3, 4, 5, 6], [0, 1, 2, 4, 5, 6], [0, 1, 2, 3, 5, 6], [0, 1, 2, 3, 4, 6], [0, 1, 2, 3, 4, 5], []]", "type": "list"}, {"name": "start", "value": "0", "type": "int"}], "return": {"value": "([0, 1, 1, 1, 1, 1, 1, inf], [None, 0, 0, 0, 0, 0, 0, None])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[], [2, 3], [4, 5, 1], [6, 7, 1], [8, 9, 2], [10, 11, 2], [12, 13, 3], [14, 15, 3], [4], [4], [5], [5], [6], [6], [7], [7]]", "type": "list"}, {"name": "start", "value": "1", "type": "int"}], "return": {"value": "([inf, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3], [None, None, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[]]", "type": "list"}, {"name": "start", "value": "0", "type": "int"}], "return": {"value": "([0], [None])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[{}]", "type": "list"}, {"name": "start", "value": "0", "type": "int"}], "return": {"value": "([0], [None])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[], []]", "type": "list"}, {"name": "start", "value": "0", "type": "int"}], "return": {"value": "([0, inf], [None, None])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[{}, {}]", "type": "list"}, {"name": "start", "value": "0", "type": "int"}], "return": {"value": "([0, inf], [None, None])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[[1], [0]]", "type": "list"}, {"name": "start", "value": "0", "type": "int"}], "return": {"value": "([0, 1], [None, 0])", "type": "tuple"}}, {"args": [{"name": "graph", "value": "[{1: None}, {0: None}]", "type": "list"}, {"name": "start", "value": "0", "type": "int"}], "return": {"value": "([0, 1], [None, 0])", "type": "tuple"}}]}], "classes": []}, "FR": {"name": "bfs", "description": "En largeur d'abord de recherche, bfs et OurQueue\nchristoph d\u00fcrr - jill-j\u00eann vie - la p\u00e9riode 2015-2019\n", "functions": [{"name": "bfs", "description": "Plus court chemin dans le graphe non pond\u00e9r\u00e9 par BFS\n\n:param graphe: graphe orient\u00e9 dans listlist ou listdict format\n:param int start: source: vertex\n:retourne: distance de table, table de pr\u00e9c\u00e9dence\n:complexit\u00e9: O(|V|+|E|)`\n"}], "classes": []}}, {"EN": {"name": "pq_tree", "description": "c.durr - 2017-2019\n\n\n    Solve the consecutive all ones column problem using PQ-trees\n\n    In short, a PQ-tree represents sets of total orders over a ground set. The\n    leafs are the values of the ground set. Inner nodes are of type P or Q. P\n    means all permutations of the children are allowed. Q means only the left\n    to right or the right to left order of the children is allowed.\n\n    The method restrict(S), changes the tree such that it represents only\n    total orders which would leave the elements of the set S consecutive.  The\n    complexity of restrict is linear in the tree size.\n\n    References:\n\n    [W] https://en.wikipedia.org/wiki/PQ_tree\n\n    [L10] Richard Ladner, slides.\n        https://courses.cs.washington.edu/courses/cse421/10au/lectures/PQ.pdf\n\n    [H00] Mohammad Taghi Hajiaghayi, notes.\n        http://www-math.mit.edu/~hajiagha/pp11.ps\n\n\n    Disclaimer: this implementation does not have the optimal time complexity.\n    And also there are more recent and easier algorithms for this problem.\n\n", "functions": [{"name": "consecutive_ones_property", "description": " Check the consecutive ones property.\n\n    :param list sets: is a list of subsets of the ground set.\n    :param groundset: is the set of all elements,\n                by default it is the union of the given sets\n    :returns: returns a list of the ordered ground set where\n              every given set is consecutive,\n              or None if there is no solution.\n    :complexity: O(len(groundset) * len(sets))\n    :disclaimer: an optimal implementation would have complexity\n                 O(len(groundset) + len(sets) + sum(map(len,sets))),\n                 and there are more recent easier algorithms for this problem.\n    ", "examples": [{"args": [{"name": "sets", "value": "[{2, 3, 4, 5, 6}, {3, 6, 7}, {4, 7}]", "type": "list"}, {"name": "universe", "value": "None", "type": "NoneType"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "sets", "value": "[{2, 3, 4, 5, 6}, {3, 6, 7}, {7}]", "type": "list"}, {"name": "universe", "value": "None", "type": "NoneType"}], "return": {"value": "[2, 4, 5, 3, 6, 7]", "type": "list"}}, {"args": [{"name": "sets", "value": "[{10, 2, 3}, {8, 3, 6}]", "type": "list"}, {"name": "universe", "value": "None", "type": "NoneType"}], "return": {"value": "[2, 10, 3, 6, 8]", "type": "list"}}, {"args": [{"name": "sets", "value": "[{2, 3, 4}, {1, 2, 3}, {4, 5}]", "type": "list"}, {"name": "universe", "value": "None", "type": "NoneType"}], "return": {"value": "[1, 2, 3, 4, 5]", "type": "list"}}, {"args": [{"name": "sets", "value": "[{3, 4}, {3, 4, 6}, {3, 4, 5}, {4, 5}, {2, 6}, {1, 2}, {4, 5}, {3, 5}]", "type": "list"}, {"name": "universe", "value": "None", "type": "NoneType"}], "return": {"value": "None", "type": "NoneType"}}, {"args": [{"name": "sets", "value": "[{1, 4}, {0, 2, 3, 4, 5}, {0, 2, 4, 5}, {2, 5}, {0, 2}]", "type": "list"}, {"name": "universe", "value": "None", "type": "NoneType"}], "return": {"value": "[1, 4, 5, 2, 0, 3]", "type": "list"}}, {"args": [{"name": "sets", "value": "[{1, 7}, {2, 10}, {1, 2, 9}, {1, 2, 4, 7, 8, 9, 10}]", "type": "list"}, {"name": "universe", "value": "{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}", "type": "set"}], "return": {"value": "[0, 3, 5, 6, 4, 8, 7, 1, 9, 2, 10]", "type": "list"}}]}], "classes": [{"name": "IsNotC1P", "description": "The given instance does not have the all consecutive ones property", "methods": []}, {"name": "PQNode", "description": null, "methods": [{"name": "__init__", "description": null}, {"name": "__str__", "description": null}, {"name": "add", "description": "Add one node as descendant\n        "}, {"name": "add_all", "description": null}, {"name": "add_group", "description": "Add elements of L as descendants of the node.\n        If there are several elements in L, group them in a P-node first\n        "}, {"name": "border", "description": "Append to L the border of the subtree.\n        "}]}, {"name": "PQTree", "description": null, "methods": [{"name": "__init__", "description": null}, {"name": "__str__", "description": "returns a string representation,\n        () for P nodes and [] for Q nodes\n        "}, {"name": "border", "description": "returns the list of the leafs in order\n        "}, {"name": "reduce", "description": null}]}]}, "FR": {"name": "pq_tree", "description": "c.durr - 2017-2019\n\n\nR\u00e9soudre cons\u00e9cutive, de tous ceux de la colonne de probl\u00e8me \u00e0 l'aide de PQ-arbres\n\nEn bref, un PQ-tree repr\u00e9sente des ensembles de commandes de plus de un terrain de jeu. L'\nleafs sont les valeurs de la terre ensemble. Int\u00e9rieure n\u0153uds sont de type P ou Q. P\nsignifie toutes les permutations de ces enfants sont autoris\u00e9s. Q signifie seulement la gauche\n\u00e0 droite ou de droite \u00e0 gauche des enfants est autoris\u00e9.\n\nLa m\u00e9thode restrict(S), les modifications de l'arbre tel qu'il ne repr\u00e9sente qu'\ntotal des commandes qui laisserait les \u00e9l\u00e9ments de l'ensemble S cons\u00e9cutifs. L'\nla complexit\u00e9 de restreindre l'est lin\u00e9aire en la taille de l'arbre.\n\nR\u00e9f\u00e9rences:\n\n[W] https://en.wikipedia.org/wiki/PQ_tree\n\n[L10] Richard Ladner, diapositives.\nhttps://courses.cs.washington.edu/courses/cse421/10au/lectures/PQ.pdf\n\n[H00] Mohammad Taghi Hajiaghayi, notes.\nhttp://www-math.mit.edu/~hajiagha/pp11.ps\n\n\nAvertissement: cette application n'a pas le temps optimal de la complexit\u00e9.\nEt aussi il y a de plus r\u00e9cent et le plus simple des algorithmes pour r\u00e9soudre ce probl\u00e8me.\n\n", "functions": [{"name": "consecutive_ones_property", "description": " V\u00e9rifier l'cons\u00e9cutifs \u00e0 la propri\u00e9t\u00e9.\n\n:param liste de jeux: une liste de sous-ensembles de la terre ensemble.\n:param groundset: est l'ensemble de tous les \u00e9l\u00e9ments,\npar d\u00e9faut, c'est l'union des ensembles\n:retourne: renvoie une liste de la commande, terrain de jeu o\u00f9\nchaque ensemble est cons\u00e9cutive,\nou Aucun si il n'y a pas de solution.\n:complexit\u00e9: O(len(groundset) * len(jeux))\n:avertissement: une mise en \u0153uvre optimale aurait complexit\u00e9\nO(len(groundset) + len(fixe) + somme(carte(len,jeux))),\net il y a de plus r\u00e9cent plus facile d'algorithmes pour r\u00e9soudre ce probl\u00e8me.\n"}], "classes": [{"name": "IsNotC1P", "description": "L'instance donn\u00e9e n'a pas du tout cons\u00e9cutifs de la propri\u00e9t\u00e9", "methods": []}, {"name": "PQNode", "description": null, "methods": [{"name": "__init__", "description": null}, {"name": "__str__", "description": null}, {"name": "ajouter", "description": "Ajouter un n\u0153ud descendant\n"}, {"name": "add_all", "description": null}, {"name": "add_group", "description": "Ajouter des \u00e9l\u00e9ments de L comme les descendants du n\u0153ud.\nSi il y a plusieurs \u00e9l\u00e9ments dans L, groupe dans un n\u0153ud-P premier\n"}, {"name": "la fronti\u00e8re", "description": "Ajouter \u00e0 L de la fronti\u00e8re de la sous-arborescence.\n"}]}, {"name": "PQTree", "description": null, "methods": [{"name": "__init__", "description": null}, {"name": "__str__", "description": "renvoie une repr\u00e9sentation sous forme de cha\u00eene,\n() pour les noeuds P et [] pour Q n\u0153uds\n"}, {"name": "la fronti\u00e8re", "description": "retourne la liste des maple leafs dans l'ordre\n"}, {"name": "r\u00e9duire", "description": null}]}]}}, {"EN": {"name": "laser_mirrors", "description": "Orienting mirrors to allow connectivity by a laser beam\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "laser_mirrors", "description": "Orienting mirrors to allow reachability by laser beam\n\n    :param int rows:\n    :param int cols: rows and cols are the dimension of the grid\n    :param mir: list of mirror coordinates, except\n                mir[0]= laser entrance,\n                mir[-1]= laser exit.\n    :complexity: :math:`O(2^n)`\n    ", "examples": [{"args": [{"name": "rows", "value": "2", "type": "int"}, {"name": "cols", "value": "2", "type": "int"}, {"name": "mir", "value": "[(0, 0), (0, 1), (1, 0), (1, 1)]", "type": "list"}], "return": {"value": "[1, 0, 1, 0]", "type": "list"}}, {"args": [{"name": "rows", "value": "7", "type": "int"}, {"name": "cols", "value": "8", "type": "int"}, {"name": "mir", "value": "[(0, 1), (0, 4), (0, 6), (2, 3), (2, 4), (4, 1), (4, 4), (4, 6), (6, 0), (6, 3), (6, 4)]", "type": "list"}], "return": {"value": "[1, None, 0, 0, 1, 1, 0, 0, None, 1, 0]", "type": "list"}}, {"args": [{"name": "rows", "value": "5", "type": "int"}, {"name": "cols", "value": "4", "type": "int"}, {"name": "mir", "value": "[(0, 0), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3), (3, 0), (3, 1), (3, 2), (3, 3), (4, 0), (4, 1), (4, 2), (4, 3)]", "type": "list"}], "return": {"value": "None", "type": "NoneType"}}]}, {"name": "solve", "description": "Can a laser leaving mirror i in direction direc reach exit ?\n\n    :param i: mirror index\n    :param direc: direction leaving mirror i\n    :param orient: orient[i]=orientation of mirror i\n    :param succ: succ[i][direc]=succ mirror reached\n                 when leaving i in direction direc\n    ", "examples": [{"args": [{"name": "succ", "value": "[[None, 4, 2, 1], [None, 0, 3, 5], [0, None, None, 3], [1, 2, None, None], [None, None, None, 0], [None, 1, None, None]]", "type": "list"}, {"name": "orien", "value": "[0, None, None, None, 0, 0]", "type": "list"}, {"name": "i", "value": "0", "type": "int"}, {"name": "direc", "value": "0", "type": "int"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "succ", "value": "[[None, 4, 2, 1], [None, 0, 3, 5], [0, None, None, 3], [1, 2, None, None], [None, None, None, 0], [None, 1, None, None]]", "type": "list"}, {"name": "orien", "value": "[1, None, 0, None, 0, 0]", "type": "list"}, {"name": "i", "value": "2", "type": "int"}, {"name": "direc", "value": "1", "type": "int"}], "return": {"value": "False", "type": "bool"}}, {"args": [{"name": "succ", "value": "[[None, 4, 2, 1], [None, 0, 3, 5], [0, None, None, 3], [1, 2, None, None], [None, None, None, 0], [None, 1, None, None]]", "type": "list"}, {"name": "orien", "value": "[1, 0, 1, 0, 0, 0]", "type": "list"}, {"name": "i", "value": "1", "type": "int"}, {"name": "direc", "value": "3", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "succ", "value": "[[None, 4, 2, 1], [None, 0, 3, 5], [0, None, None, 3], [1, 2, None, None], [None, None, None, 0], [None, 1, None, None]]", "type": "list"}, {"name": "orien", "value": "[1, None, 1, 0, 0, 0]", "type": "list"}, {"name": "i", "value": "3", "type": "int"}, {"name": "direc", "value": "0", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "succ", "value": "[[None, 4, 2, 1], [None, 0, 3, 5], [0, None, None, 3], [1, 2, None, None], [None, None, None, 0], [None, 1, None, None]]", "type": "list"}, {"name": "orien", "value": "[1, None, 1, None, 0, 0]", "type": "list"}, {"name": "i", "value": "2", "type": "int"}, {"name": "direc", "value": "3", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "succ", "value": "[[None, 4, 2, 1], [None, 0, 3, 5], [0, None, None, 3], [1, 2, None, None], [None, None, None, 0], [None, 1, None, None]]", "type": "list"}, {"name": "orien", "value": "[1, None, None, None, 0, 0]", "type": "list"}, {"name": "i", "value": "0", "type": "int"}, {"name": "direc", "value": "2", "type": "int"}], "return": {"value": "True", "type": "bool"}}, {"args": [{"name": "succ", "value": "[[None, 4, 2, 1], [None, 0, 3, 5], [0, None, None, 3], [1, 2, None, None], [None, None, None, 0], [None, 1, None, None]]", "type": "list"}, {"name": "orien", "value": "[None, None, None, None, 0, 0]", "type": "list"}, {"name": "i", "value": "4", "type": "int"}, {"name": "direc", "value": "3", "type": "int"}], "return": {"value": "True", "type": "bool"}}]}], "classes": []}, "FR": {"name": "laser_mirrors", "description": "Orienter les miroirs, pour permettre la connectivit\u00e9 par un faisceau laser\njill-j\u00eann vie et christoph d\u00fcrr - 2014-2019\n", "functions": [{"name": "laser_mirrors", "description": "Orienter les miroirs pour permettre l'accessibilit\u00e9 par faisceau laser\n\n:param int lignes:\n:param int cols: les lignes et les colonnes sont les dimension de la grille\n:param mir: liste de miroir coordonn\u00e9es, \u00e0 l'exception de\nmir[0]= laser d'entr\u00e9e,\nmir[-1]= sortie du laser.\n:complexit\u00e9: :math:`O(2^n)`\n"}, {"name": "r\u00e9soudre", "description": "Un laser peut-il quitter le miroir j'en direction direc atteindre la sortie ?\n\n:param i: miroir de l'indice de\n:param administration: la direction de quitter miroir, je\n:param orient: l'orient[i]=orientation du miroir, je\n:param succ: succ[i][administration]=succ miroir atteint\nau moment de quitter j'en direction direc\n"}], "classes": []}}]